# audio - Multimedia-Audio

{bdg-success}`Adapted` {bdg-primary}`Air101/Air103` {bdg-primary}`Air601` {bdg-primary}`Air105` {bdg-primary}`Air780E/Air700E`

```{note}
This page document is automatically generated by [this file](https://gitee.com/openLuat/LuatOS/tree/master/luat/../components/multimedia/luat_lib_multimedia_audio.c). If there is any error, please submit issue or help modify pr, thank youÔºÅ
```

```{tip}
This library has its own demo,[click this link to view audio's demo example](https://gitee.com/openLuat/LuatOS/tree/master/demo/multimedia)
```

## Constant

|constant | type | explanation|
|-|-|-|
|audio.PCM|number|PCM format, I .e. raw ADC data|
|audio.MORE_DATA|number|audio.on The value of the parameter passed in the callback function, indicating that after a piece of data is played at the bottom layer, more data can be passed in.|
|audio.DONE|number|audio.on The value of the parameter passed in by the callback function indicates that the bottom layer has played all the data.|
|audio.BUS_DAC|number|Hardware output bus, DAC type|
|audio.BUS_I2S|number|Hardware output bus, I2S type|
|audio.BUS_SOFT_DAC|number|Hardware output bus, software mode DAC type|


## audio.start(id, audio_format, num_channels, sample_rate, bits_per_sample, is_signed)



Start a multimedia channel ready to play audio

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Multimedia playback channel number, 0 or 1|
|int|Audio Format|
|int|Number of sound channels|
|int|Sampling frequency|
|int|Number of sampling bits|
|boolean|Symbols, default true|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Success true, failure false|

**Examples**

```lua
audio.start(0, audio.PCM, 1, 16000, 16)

```

---

## audio.write(id, data)



Write audio data to a multimedia channel

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|string|or zbuff Audio Data|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.write(0, "xxxxxx")

```

---

## audio.stop(id)



Stop the specified multimedia channel

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|audio id,For example 0|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.stop(0)

```

---

## audio.pause(id, pause)



Pause/resume specified multimedia channel

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|audio id,For example 0|
|boolean|onoff true Pause, false resume|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.pause(0, true) --Pause channel 0
audio.pause(0, false) --Recovery channel 0

```

---

## audio.on(id, event, func)



Register audio playback event callback

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|audio id, audio 0 Write 0, write audio 1 1|
|function|callback method, the parameters passed in during callback are 1, int channel ID 2, int message value, only audio.MORE_DATA and audio.DONE|

**Return Value**

|return value type | explanation|
|-|-|
|nil|No return value|

**Examples**

```lua
audio.on(0, function(audio_id, msg)
    log.info("msg", audio_id, msg)
end)

```

---

## audio.play(id, path, errStop)



Play or stop playing a file. After the play is completed, an audio.DONE message will be called back. pause can be used to pause or resume. Other API is not available. Considering the slow speed of reading SD card and slowing down the speed of luavm process, try to use this API

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|
|string/table|The file name. If it is empty, the playback is stopped. If it is table, multiple files are played continuously. It is mainly used for cloud speakers. Currently, only EC618 is supported and errStop parameters are used.|
|boolean|Indicates whether to stop decoding after a file fails to be decoded. This is only useful when multiple files are played continuously. The default value is true. If a decoding error occurs, the decoding is automatically stopped.|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.play(0, "xxxxxx")		--Start playing a file
audio.play(0)				--Stop playing a file

```

---

## audio.tts(id, data)



TTS Play or stop

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|
|string/zbuff|Content that needs to be played|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

None

---

## audio.playStop(id)



Stop playing the file, which is the same as audio.play(id).

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|audio id,For example 0|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.playStop(0)

```

---

## audio.isEnd(id)



Check whether the current file has finished playing

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Returns true on success, otherwise false|

**Examples**

```lua
audio.isEnd(0)


```

---

## audio.getError(id)



Get the latest playback result. Not all platforms support it. Currently, only EC618 supports it.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Whether all files are played successfully, true successfully, false|
|boolean|If playback fails, whether the user stops, true is, false is not|
|int|The first file failed, starting from 1|

**Examples**

```lua
local result, user_stop, file_no = audio.getError(0)

```

---

## audio.config(id, paPin, onLevel, dacDelay, paDelay, dacPin, dacLevel, dacTimeDelay)



Configure the characteristics of an audio channel, such as automatically controlling the PA switch. Note that this is not necessary. Generally, automatic control is only required when play is called. In other cases, for example, when you manually control the play, you can control the PA switch yourself.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|
|int|PA Control IO|
|int|PA Level when on|
|int|Redundancy time inserted before DAC startup, in 100ms, typically for external DAC|
|int|How long is the delay in turning on the PA after the DAC is started, unit 1ms|
|int|The external dac power supply controls IO. If it is not filled in, it means that the platform default IO is used. For example, Air780E uses DACEN pin, air105 is not enabled.|
|int|When the external dac is turned on, the power control IO level is pulled high by default|
|int|When audio playback is completed, the time interval between PA and DAC is turned off, in 1ms, default 0ms|

**Return Value**

None

**Examples**

```lua
audio.config(0, pin.PC0, 1)	--PA The control pin is PC0, the high level is turned on, air105 can be used with this configuration
audio.config(0, 25, 1, 6, 200)	--PA The control pin is GPIO25, the high level is turned on, and the Air780E cloud horn board can be used with this configuration.

```

---

## audio.vol(id, value)



Configure the volume adjustment of an audio channel to directly enlarge or reduce the original data. Not all platforms support it. It is recommended to use hardware methods to zoom

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio Channel|
|int|Volume, percentage, 1% ~ 1000, default 100, is not adjusted|

**Return Value**

|return value type | explanation|
|-|-|
|int|Current Volume|

**Examples**

```lua
local result = audio.vol(0, 90)	--The volume of channel 0 is adjusted to 90%,result stores the adjusted volume level, which may still be 100

```

---

## audio.setBus(id, bus_type)



Configure the hardware output bus of an audio channel, and set the corresponding type only if the corresponding SOC software and hardware platform supports it.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Audio channels, such 0|
|int|Bus type, such audio.BUS_SOFT_DAC|

**Return Value**

|return value type | explanation|
|-|-|
|nil|No return value|

**Examples**

```lua
audio.setBus(0, audio.BUS_SOFT_DAC)	--Hardware output channel for channel 0 is set to software DAC
audio.setBus(0, audio.BUS_I2S)	--The hardware output channel for channel 0 is set I2S

```

---

## audio.debug(on_off)



Configuring Debug Information Output

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|true On false off|

**Return Value**

None

**Examples**

None

---

