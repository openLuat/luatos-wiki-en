# ioqueue - io Sequence operation

{bdg-success}`Adapted` {bdg-primary}`Air105` {bdg-primary}`Air780EP`

```{note}
This page document is automatically generated by [this file](https://gitee.com/openLuat/LuatOS/tree/master/luat/../components/io_queue/luat_lib_io_queue.c). If there is any error, please submit issue or help modify pr, thank you！
```

```{tip}
This library has its own demo,[click this link to view ioqueue demo examples](https://gitee.com/openLuat/LuatOS/tree/master/demo/io_queue)
```

## ioqueue.init(hwtimer_id,cmd_cnt,repeat_cnt)



initialize an io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware timer id, default 0, according to the actual MCU, air105 is 0~5, shared with pwm, the same channel number cannot be both pwm and ioqueue|
|int|A full cycle requires more commands than the actual|
|int|The number of repetitions, the default is 1, if you write 0, it means an infinite number of loops.|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.init(0,10,5) --Initialize an io operation queue with timer0 as the clock source, with 10 valid commands, loop 5 times

```

---

## ioqueue.setdelay(hwtimer_id,time_us,time_tick,continue)



add a delay command to the io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|Delay time,0~65535us|
|int|Delay fine tuning time, 0~255tick, the total delay time is time_us * 1us_tick + time_tick|
|boolean|Whether it is continuous is continuous delay, the default is no, if it is, the timer will not stop but time again after the time is up.，|

**Return Value**

None

**Examples**

None

---

## ioqueue.delay(hwtimer_id)



add a repeat delay to the I/o operation queue. the delay must be setdelay and continuous.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.setdelay(0,9,15,true) --The delay is 9us 15 ticks, and when the delay command is encountered later, the delay will be 9us 15 ticks.tick
ioqueue.delay(0)

```

---

## ioqueue.setgpio(hwtimer_id,pin,is_input,pull_mode,init_level)



add the gpio command to the io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|pin|
|boolean|Whether input or not|
|int|pull-up mode, can only be 0,gpio.PULLUP,gpio.PULLDOWN|
|int|Initial output level|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.setgpio(0,pin.PB01,true,gpio.PULLUP,0) --PB01 Set to pull-up input
ioqueue.setgpio(0,pin.PB01,false,0,1)--PB01 Set to default pull-down output high level

```

---

## ioqueue.input(hwtimer_id,pin)



add the read gpio command to the io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|pin|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.input(0,pin.PB01)


```

---

## ioqueue.output(hwtimer_id,pin,level)



Adding Output GPIO Commands to the IO Operation Queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|pin|
|int|Output level|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.output(0,pin.PB01,0)

```

---

## ioqueue.setcap(hwtimer_id,pin,pull_mode,irq_mode,max_tick)



add settings to the io operation queue to capture a certain IO command

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|pin|
|int|pull-up mode, can only be 0,gpio.PULLUP,gpio.PULLDOWN|
|int|Break mode, can only be gpio.BOTH,gpio.RISING,gpio.FALLING|
|int|The maximum timer time of the timer takes into account that lua is of int type, with a minimum of 0x 10000 and a maximum of 0 x7fffffff, and the default is the maximum value.|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.setcap(0,pin.PB01,gpio.PULLUP,gpio.FALLING,48000000)

```

---

## ioqueue.capture(hwtimer_id)



Add a capture IO status command to the IO operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.capture(0)

```

---

## ioqueue.capend(hwtimer_id,pin)



Add the IO operation queue to end the capture of an IO command.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|int|pin|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.capend(0,pin.PB01)

```

---

## ioqueue.get(hwtimer_id, input_buff, capture_buff)



* get the data entered and captured in the io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|zbuff|The buff that stores IO input data, and stores data in the form of 1byte pin 1byte level|
|zbuff|The buff used to store IO capture data. The data is stored in the form of 1byte pin 1byte level 4byte tick.|

**Return Value**

|return value type | explanation|
|-|-|
|int|How many groups of IO input data are returned|
|int|How many groups of IO capture data are returned|

**Examples**

```lua
local input_cnt, capture_cnt = ioqueue.get(0, input_buff, capture_buff)

```

---

## ioqueue.start(hwtimer_id)



start io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.start(0)

```

---

## ioqueue.stop(hwtimer_id)



stop the io operation queue, you can start from the beginning

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|

**Return Value**

|return value type | explanation|
|-|-|
|int|Returns the number of cycles that have been performed. If it is 0, it means that none of the cycles have been completed.|
|int|Returns the number of cmds executed in a single loop. If it is 0, it may be that a loop has just ended.|

**Examples**

```lua
ioqueue.stop(0)

```

---

## ioqueue.release(hwtimer_id)



release the resources of the I/o operation queue. the resource must be re-used next time.init

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.clear(0)

```

---

## ioqueue.clear(hwtimer_id)



empty the io operation queue

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.clear(0)

```

---

## ioqueue.done(hwtimer_id)



Check whether the io operation queue has been completed

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Hardware Timer id|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Queue execution completed，|

**Examples**

```lua
local result = ioqueue.done(0)

```

---

## ioqueue.exti(pin,pull_mode,irq_mode,onoff)



Start/stop an external interrupt with a system tick return

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|pin|
|int|pull-up mode, can only be 0,gpio.PULLUP,gpio.PULLDOWN|
|int|Break mode, can only be gpio.BOTH,gpio.RISING,gpio.FALLING|
|boolean|Switch, the default is false off|
|return|None|

**Return Value**

None

**Examples**

```lua
ioqueue.exti(pin.PB01, gpio.PULLUP, gpio.BOTH, true)
ioqueue.exti(pin.PB01)

```

---

