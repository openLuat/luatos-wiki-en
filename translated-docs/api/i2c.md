# i2c - I2C Operation

{bdg-success}`Adapted` {bdg-primary}`Air780E/Air700E` {bdg-primary}`Air780EP` {bdg-primary}`Air601` {bdg-primary}`Air101/Air103` {bdg-primary}`Air105` {bdg-primary}`ESP32C3` {bdg-primary}`ESP32S3`

```{note}
This page document is automatically generated by [this file](https://gitee.com/openLuat/LuatOS/tree/master/luat/modules/luat_lib_i2c.c). If there is any error, please submit issue or help modify pr, thank youÔºÅ
```

```{tip}
This library has its own demo,[click this link to view the demo example of i2c](https://gitee.com/openLuat/LuatOS/tree/master/demo/i2c)
```

## Constant

|constant | type | explanation|
|-|-|-|
|i2c.FAST|number|High speed|
|i2c.SLOW|number|Low speed|


## i2c.exist(id)



i2c Number Existence

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|

**Return Value**

|return value type | explanation|
|-|-|
|bool|Returns true if it exists, otherwise it returns false|

**Examples**

```lua
-- Check if i2c1 exists
if i2c.exist(1) then
    log.info("Existence i2c1")
end

```

---

## i2c.setup(id, speed, pullup)



i2c Initialization

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Speed, for example i2c.FAST|
|bool|Whether the software is pulled up, the default is not turned on, and hardware support is required.|

**Return Value**

|return value type | explanation|
|-|-|
|int|Returns 1 on success, otherwise 0|

**Examples**

```lua
-- Initialization i2c1
i2c.setup(1, i2c.FAST) -- id Right is sure to succeed
-- To determine whether the i2c id is valid, use the i2c.exist function

```

---

## i2c.createSoft(scl,sda,delay)



Create a new software i2c object

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|i2c SCL Pin number (GPIO number)|
|int|i2c SDA Pin number (GPIO number)|
|int|Delay of each operation, unit us, default 5|

**Return Value**

|return value type | explanation|
|-|-|
|Software I2C object | can be used as the id of i2c|

**Examples**

```lua
-- Attention! This interface is a software simulation i2c, the speed may be slower than the hardware
-- No need to call the i2c.close interface
-- Initialize software i2c
local softI2C = i2c.createSoft(1, 2, 5)
i2c.send(softI2C, 0x5C, string.char(0x0F, 0x2F))
-- Note that the third parameter was added on 2023.06.19 delay
-- Increase or decrease the speed of I2C by adjusting the value of the delay parameter

```

---

## i2c.send(id, addr, data,stop)



i2c Send data

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|integer/string/table|Data to be sent, adaptive parameter type|
|integer|Optional parameter whether to send stop bit 1 send 0 does not send default send (105 not supported)|

**Return Value**

|return value type | explanation|
|-|-|
|true/false|Whether the sending was successful|

**Examples**

```lua
-- Send 1 byte of data to i2c0
i2c.send(0, 0x68, 0x75)
-- Send 2 bytes of data to i2c1
i2c.send(1, 0x5C, string.char(0x0F, 0x2F))
i2c.send(1, 0x5C, {0x0F, 0x2F})

```

---

## i2c.recv(id, addr, len)



i2c Receive data

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|int|Length of received data|

**Return Value**

|return value type | explanation|
|-|-|
|string|Data received|

**Examples**

```lua
-- Read 2 bytes of data from i2c1
local data = i2c.recv(1, 0x5C, 2)

```

---

## i2c.writeReg(id, addr, reg, data,stop)



i2c Write register data

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|int|register address|
|string|Data to be sent|
|integer|Optional parameter whether to send stop bit 1 send 0 does not send default send (105 not supported)|

**Return Value**

|return value type | explanation|
|-|-|
|true/false|Whether the sending was successful|

**Examples**

```lua
-- Write 2 bytes of data from register 0x 01 of device with address 0x5C of i2c1
i2c.writeReg(1, 0x5C, 0x01, string.char(0x00, 0xF2))

```

---

## i2c.readReg(id, addr, reg, len)



i2c Read register data

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|int|register address|
|int|Length of data to be received|
|integer|Optional parameter whether to send stop bit 1 send 0 does not send default send (105 not supported)|

**Return Value**

|return value type | explanation|
|-|-|
|string|Data received|

**Examples**

```lua
-- Read 2 bytes of data from register 0x 01 of the device with address 0x5C of i2c1
i2c.readReg(1, 0x5C, 0x01, 2)

```

---

## i2c.close(id)



Turn off the i2c device

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|

**Return Value**

|return value type | explanation|
|-|-|
|nil|No return value|

**Examples**

```lua
-- Close i2c1
i2c.close(1)

```

---

## i2c.readDHT12(id)



Read temperature and humidity data of DHT12 from i2c bus

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|DHT12 device address, default 0x5C|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|RETURNS ESS RETURNS TRUE, OTHERWISE RETURNS false|
|int|Humidity value in 0.1%, for example 591 59.1%|
|int|Temperature value in 0.1 degrees Celsius, for example, 292 represents 29.2 degrees Celsius|

**Examples**

```lua
-- Read from i2c0 DHT12
i2c.setup(0)
local re, H, T = i2c.readDHT12(0)
if re then
    log.info("dht12", H, T)
end

```

---

## i2c.readSHT30(id,addr)



Read temperature and humidity data of DHT30 from i2c bus (contributed by "Hour Star")

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|Device addr, device address of SHT30, default 0x44 bit7|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|RETURNS ESS RETURNS TRUE, OTHERWISE RETURNS false|
|int|Humidity value in 0.1%, for example 591 59.1%|
|int|Temperature value in 0.1 degrees Celsius, for example, 292 represents 29.2 degrees Celsius|

**Examples**

```lua
-- Read from i2c0 SHT30
i2c.setup(0)
local re, H, T = i2c.readSHT30(0)
if re then
    log.info("sht30", H, T)
end

```

---

## i2c.transfer(id, addr, txBuff, rxBuff, rxLen)



i2c General transmission includes three functions: sending n bytes, sending n bytes, receiving n bytes, and receiving n bytes. reStart signals are sent in the process of sending to receiving. to solve similar mlx90614, restart signals must be brought, but i2c.send cannot be used to control, for example air105

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|integer/string/zbuff|The data to be sent. The adaptive parameter type. If the parameter is nil, no data is sent.|
|zbuff|If the zbuff of the data to be received is not used, the received data will be returned in return.|
|int|The length of the data to be received. If it is 0 or nil, no data is received.|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|true/false Whether the sending was successful|
|string|or nil If parameter 5 is interger, the received data is returned|

**Examples**

```lua
local result, _ = i2c.transfer(0, 0x11, txbuff, rxbuff, 1)
local result, _ = i2c.transfer(0, 0x11, txbuff, nil, 0)	--Only send data in txbuff, not receive data. A typical application is to write registers, where register addresses and values are placed in txbuff
local result, _ = i2c.transfer(0, 0x11, "\x01\x02\x03", nil, 1) --Send 0x 01, 0x 02,0x 03, do not receive data, if it is eeprom, write 02 and 03 to the address of 0x 01, or write 03 to the address of 0x 0102, depending on the specific chip.
local result, rxdata = i2c.transfer(0, 0x11, "\x01\x02", nil, 1) --Send 0x 01, 0x 02, and then receive 1 byte. A typical application is eeprom
local result, rxdata = i2c.transfer(0, 0x11, 0x00, nil, 1) --Send 0x 00, then receive 1 byte, typical application of various sensors

```

---

## i2c.xfer(id, addr, txBuff, rxBuff, rxLen, transfer_done_topic, timeout)



i2c Non-blocking general transmission, similar to transfer, but will not wait until I2C transmission is completed before returning, calling this function will return immediately, after I2C transmission is completed, through the message callback

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|I2C Address of the sub-device, 7-bit address|
|zbuff|The data to be sent, due to the non-blocking model, can only use zbuff to ensure the validity of dynamic data. The data to be sent starts with zbuff.addr and has a length zbuff.used|
|zbuff|The zbuff of the data to be received. If it is nil, the following parameters are ignored and no data is received. The received data will be placed at the beginning of zbuff.addr and will overwrite the previous data. note that zhuff has enough reserved space.|
|int|The length of the data to be received. If it is 0 or nil, no data is received.|
|string|Message for callback after transfer completes|
|int|The timeout period. If nil is filled, it is 100ms|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|true/false Whether this transmission is started correctly, true, start, false, and cannot be started with errors. Message transfer_done_topic and boolean results are published when the transfer is complete|

**Examples**

```lua
local result = i2c.xfer(0, 0x11, txbuff, rxbuff, 1, "I2CDONE") if result then result, i2c_id, succ, error_code = sys.waitUntil("I2CDONE") end if not result or not succ then log.info("i2c fail, error code", error_code) else log.info("i2c ok") end


```

---

## i2c.scan(id,speed)



Scan for i2c devices

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The device ID, for example, the ID of i2c1 is 1, and the ID of i2c2 is 2|
|int|Speed, optional i2c.SLOW i2c.FAST i2c.PLUS i2c.HSMODE defaults to i2c.SLOW. If it cannot be detected, modify this item.|

**Return Value**

|return value type | explanation|
|-|-|
|nil|No current return value|

**Examples**

```lua
-- This function was added on 2023.07.04
-- The main goal of this function is to scan i2c devices during development
-- Some BSPs output logs when addr is unresponsive, causing the output to be scrambled.
i2c.scan()

```

---

