# mcu - encapsulation mcu some special operations

{bdg-success}`Adapted` {bdg-primary}`Air101/Air103` {bdg-primary}`Air601` {bdg-primary}`Air105` {bdg-primary}`ESP32C3` {bdg-primary}`ESP32S3` {bdg-primary}`Air780E/Air700E` {bdg-primary}`Air780EP`

```{note}
This page document is automatically generated by [this file](https://gitee.com/openLuat/LuatOS/tree/master/luat/modules/luat_lib_mcu.c). If there is any error, please submit issue or help modify pr, thank you！
```


## Constant

|constant | type | explanation|
|-|-|-|
|mcu.UART|number|Peripheral Type-Serial|
|mcu.I2C|number|Peripheral Type-I2C|
|mcu.SPI|number|Peripheral Type-SPI|
|mcu.PWM|number|Peripheral Type-PWM|
|mcu.GPIO|number|Peripheral Type-GPIO|
|mcu.I2S|number|Peripheral Type-I2S|
|mcu.LCD|number|Peripheral Type-LCD|
|mcu.CAM|number|Peripheral Type-CAM|


## mcu.setClk(mhz)



Set main frequency, unit MHZ

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The main frequency has different effective values according to different equipment, please refer to the manual|

**Return Value**

|return value type | explanation|
|-|-|
|bool|Returns true on success, otherwise false|

**Examples**

```lua
--  Please note that the main frequency is related to the main frequency of peripherals. For example, when the main frequency is 2M, the highest SPI can only 1M
-- Set 80MHZ
mcu.setClk(80)
sys.wait(1000)
-- Set 240MHZ
mcu.setClk(240)
sys.wait(1000)
-- Set 2MHZ
mcu.setClk(2)
sys.wait(1000)

```

---

## mcu.getClk()



Obtain the main frequency, unit MHZ

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|If it fails, return -1, otherwise return the main frequency value. If it is equal to 0, it may be in the power saving mode of 32k crystal oscillator.|

**Examples**

```lua
local mhz = mcu.getClk()
print("Boom", mhz)

```

---

## mcu.unique_id()



Obtain the unique id of the device. Note that it may contain invisible characters. If you need to view the recommended toHex(), print

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|string|The unique device ID. If not, an empty string is returned..|

**Examples**

```lua
local unique_id = mcu.unique_id()
print("unique_id", unique_id)

```

---

## mcu.ticks()



Get the tick number after startup, note that there will be overflow and negative numbers.

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|Current tick value|

**Examples**

```lua
local tick = mcu.ticks()
print("ticks", tick)

```

---

## mcu.hz()



Get the number of ticks per second

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|The number of ticks per second, typically 1000|

**Examples**

```lua
local hz = mcu.hz()
print("mcu.hz", hz)

```

---

## mcu.reg32(address, value, mask)



To read and write the 32-bit register or RAM of the mcu, use the write function carefully. Please be familiar with the register usage of the mcu before using it.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|register or ram address|
|int|The value written, if not, the current value is returned directly.|
|int|Bit mask, you can modify the bit in specific locations, the default is 0xffffffff, modify all 32bit|

**Return Value**

|return value type | explanation|
|-|-|
|int|Returns the currently registered value|

**Examples**

```lua
local value = mcu.reg32(0x2009FFFC, 0x01, 0x01) --For the value at the 0x2009FFFC address, modify bit0 1

```

---

## mcu.x32(value)



Convert decimal number to hexadecimal string output

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Values that need to be converted|

**Return Value**

|return value type | explanation|
|-|-|
|string|16 Hex String|

**Examples**

```lua
local value = mcu.x32(0x2009FFFC) --Output"0x2009fffc"

```

---

## mcu.tick64()



Obtain the high-precision tick after startup. If the bit64 library is supported, the converted bit64 structure can be directly output.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|Whether to output bit64 structure, true is, others are false, blank is also false, for compatibility with the old demo|

**Return Value**

|return value type | explanation|
|-|-|
|string|The current tick value, uint64 with 8 bytes, will output 9 bytes if the 64-bit library is supported and the 64-bit structure is required to be output at the same time string|
|int|1us There are several ticks, 0 means unknown|

**Examples**

```lua
local tick_str, tick_per = mcu.tick64()
print("ticks", tick_str, tick_per)

```

---

## mcu.dtick64(tick1, tick2, check_value)



Calculate the difference between two 64bit ticks

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|string|64bit of string|
|string|64bit of string|
|int|Reference value, optional, if 0, the first item in the returned result is true|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Compared with the reference value, if greater than or equal to true, otherwise.false|
|int|The difference tick1-tick2, if it exceeds 0 x7fffffff, the result may be wrong.|

**Examples**

```lua
local result, diff_tick = mcu.dtick64(tick1, tick2)
print("ticks", result, diff_tick)

```

---

## mcu.setXTAL(source_main, source_32k, delay)



Select clock source, currently only supported by air105

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|Whether the high-speed clock uses an external clock source, and does not change if it is empty|
|boolean|Whether the low-speed 32K uses an external clock source, if it is empty, it will not change|
|int|PLL Stabilization time. When switching high-speed clocks, according to the hardware environment, it is necessary to delay for a period of time to wait for PLL to stabilize. The default is 1200, which is not less than recommended.1024|

**Return Value**

None

**Examples**

```lua
mcu.setXTAL(true, true, 1248)	--High-speed clock using external clock, low-speed 32K using external crystal, delay1248

```

---

## mcu.hardfault(mode)



mcu Processing mode in case of crash, currently only applicable to EC618 platform

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Processing mode: 0 crash and stop, 1 crash and restart, 2 crash and try to submit error information to external tools and restart|

**Return Value**

None

**Examples**

```lua
mcu.hardfault(0)	--Shutdown after crash, generally used for debugging status
mcu.hardfault(1)	--Restart after crash, generally used for official products
mcu.hardfault(2)	--After the crash, try to submit the error information to an external tool and restart it, generally used for stress testing or official products.

```

---

## mcu.iomux(type, channel, value)



Before the peripheral is opened, the peripheral IO is multiplexed to the non-default configuration. Currently, only some Air780E peripherals are supported to be multiplexed to other configurations. This is a temporary interface. If there is a more suitable api in the future, this interface will not be updated.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Peripheral type, currently only mcu.UART,mcu.I2C|
|int|Bus serial number，0~N，|
|int|The new configuration needs to be decided according to the specific platform.|

**Return Value**

None

**Examples**

```lua
mcu.iomux(mcu.UART, 2, 1)	-- Air780E UART2 is multiplexed to gpio12 and gpio13(Air780EG default is this multiplexing, don't move)
mcu.iomux(mcu.UART, 2, 2)	-- Air780E UART2 is multiplexed to gpio6 and gpio7
mcu.iomux(mcu.I2C, 0, 1)	-- Air780E of I2C0 multiplexed to gpio12 and gpio13
mcu.iomux(mcu.I2C, 0, 2)	-- Air780E The I2C0 is multiplexed to gpio16 and gpio17
mcu.iomux(mcu.I2C, 1, 1)	-- Air780E of I2C1 multiplexing to gpio4 and gpio5

```

---

## mcu.altfun(type, sn, pad_index, alt_fun, is_input)



IO Peripheral function multiplexing selection, note that the common MCU uses GPIO number as the serial number, but the dedicated SOC, such as CAT1, uses PAD number as the serial number. This function is not applicable to all platforms

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Peripheral types, currently mcu.UART,mcu.I2C,mcu.SPI,mcu.PWM,mcu.GPIO,mcu.I2S,mcu.LCD,mcu.CAM, depending on the platform|
|int|Bus serial number, 0 ~ N, if it is mcu.GPIO, it is GPIO number. Specifically look at the platform's IOMUX multiplexing table.|
|int|pad No., if left blank, it means to clear the configuration and use the default configuration of the platform. Specifically look at the platform's IOMUX multiplexing table.|
|int|Serial number of multiplexing function, 0 ~ N. Specifically look at the platform's IOMUX multiplexing table.|
|boolean|Whether it is an input function, true is, and blank is false|

**Return Value**

None

**Examples**

```lua
mcu.altfun(mcu.GPIO, 46, 32, 1, 0)
mcu.altfun(mcu.GPIO, 46)

```

---

