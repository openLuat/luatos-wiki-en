# mcu - encapsulation mcu some special operations

{bdg-success}`Adapted` {bdg-primary}`Air780E` {bdg-primary}`Air780EP` {bdg-primary}`Air780EPS`

```{note}
This page document is automatically generated by [this file](https://gitee.com/openLuat/LuatOS/tree/master/luat/modules/luat_lib_mcu.c). If there is any error, please submit issue or help modify pr, thank you！
```


## Constant

|constant | type | explanation|
|-|-|-|
|mcu.UART|number|Peripheral Type-Serial|
|mcu.I2C|number|Peripheral Type-I2C|
|mcu.SPI|number|Peripheral Type-SPI|
|mcu.PWM|number|Peripheral Type-PWM|
|mcu.GPIO|number|Peripheral Type-GPIO|
|mcu.I2S|number|Peripheral Type-I2S|
|mcu.LCD|number|Peripheral Type-LCD|
|mcu.CAM|number|Peripheral Type-CAM|


## mcu.setClk(mhz)



Set main frequency, unit MHZ

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|The main frequency has different effective values according to different equipment, please refer to the manual|

**Return Value**

|return value type | explanation|
|-|-|
|bool|Returns true on success, otherwise false|

**Examples**

```lua

-- Note: Not all modules support frequency adjustment, please refer to the manual
-- Air101/Air103/Air601 Support setting to 2/40/80/160/240. Special reminder, after setting to 2M, if you want to sleep, you must first set 80M
-- ESP32 Series support is set to 40/80/160/240, requiring firmware after 2024.1.1
-- Air780 Series, Air105, does not support setting the main frequency
-- Air780 Series, automatically reduce the frequency to when entering sleep mode 24M

-- Set 80MHZ
mcu.setClk(80)
sys.wait(1000)
-- Set 240MHZ
mcu.setClk(240)
sys.wait(1000)
-- Set 2MHZ
mcu.setClk(2)
sys.wait(1000)

```

---

## mcu.getClk()



Obtain the main frequency, unit MHZ

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|If it fails, return -1, otherwise return the main frequency value. If it is equal to 0, it may be in the power saving mode of 32k crystal oscillator.|

**Examples**

```lua
local mhz = mcu.getClk()
print("Boom", mhz)

```

---

## mcu.unique_id()



Obtain the unique id of the device. Note that it may contain invisible characters. If you need to view the recommended toHex(), print

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|string|The unique device ID. If not, an empty string is returned..|

**Examples**

```lua
local unique_id = mcu.unique_id()
print("unique_id", unique_id)

```

---

## mcu.ticks()



Gets the number of ticks after startup. It is an unsigned value in the range of 0 to 0xffffffff. Lua is a signed calculation. If the value exceeds 0x7fffffff, the value becomes negative.

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|Current tick value|

**Examples**

```lua
local tick = mcu.ticks()
print("ticks", tick)
-- If you need a value that will not overflow, you can use mcu.ticks32(), which was added in 2024.5.7.

```

---

## mcu.hz()



Get the number of ticks per second

**Parameters**

None

**Return Value**

|return value type | explanation|
|-|-|
|int|The number of ticks per second, typically 1000|

**Examples**

```lua
local hz = mcu.hz()
print("mcu.hz", hz)

```

---

## mcu.reg32(address, value, mask)



To read and write the 32-bit register or RAM of the mcu, use the write function carefully. Please be familiar with the register usage of the mcu before using it.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|register or ram address|
|int|The value written, if not, the current value is returned directly.|
|int|Bit mask, you can modify the bit in specific locations, the default is 0xffffffff, modify all 32bit|

**Return Value**

|return value type | explanation|
|-|-|
|int|Returns the currently registered value|

**Examples**

```lua
local value = mcu.reg32(0x2009FFFC, 0x01, 0x01) --For the value at the 0x2009FFFC address, modify bit0 1

```

---

## mcu.x32(value)



Convert decimal number to hexadecimal string output

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Values that need to be converted|

**Return Value**

|return value type | explanation|
|-|-|
|string|16 Hex String|

**Examples**

```lua
local value = mcu.x32(0x2009FFFC) --Output"0x2009fffc"

```

---

## mcu.tick64()



Obtain the high-precision tick after startup. If the bit64 library is supported, the converted bit64 structure can be directly output.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|Whether to output bit64 structure, true is, others are false, blank is also false, for compatibility with the old demo|

**Return Value**

|return value type | explanation|
|-|-|
|string|The current tick value, uint64 with 8 bytes, will output 9 bytes if the 64-bit library is supported and the 64-bit structure is required to be output at the same time string|
|int|1us There are several ticks, 0 means unknown|

**Examples**

```lua
local tick_str, tick_per = mcu.tick64()
print("ticks", tick_str, tick_per)

```

---

## mcu.dtick64(tick1, tick2, check_value)



Calculate the difference between two 64bit ticks

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|string|64bit of string|
|string|64bit of string|
|int|Reference value, optional, if 0, the first item in the returned result is true|

**Return Value**

|return value type | explanation|
|-|-|
|boolean|Compared with the reference value, if greater than or equal to true, otherwise.false|
|int|The difference tick1-tick2, if it exceeds 0 x7fffffff, the result may be wrong.|

**Examples**

```lua
local result, diff_tick = mcu.dtick64(tick1, tick2)
print("ticks", result, diff_tick)

```

---

## mcu.setXTAL(source_main, source_32k, delay)



Select clock source, currently only supported by air105

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|Whether the high-speed clock uses an external clock source, and does not change if it is empty|
|boolean|Whether the low-speed 32K uses an external clock source, if it is empty, it will not change|
|int|PLL Stabilization time. When switching high-speed clocks, according to the hardware environment, it is necessary to delay for a period of time to wait for PLL to stabilize. The default is 1200, which is not less than recommended.1024|

**Return Value**

None

**Examples**

```lua
mcu.setXTAL(true, true, 1248)    --High-speed clock using external clock, low-speed 32K using external crystal, delay1248

```

---

## mcu.hardfault(mode)



mcu Processing mode in case of crash, currently only applicable to EC618 platform

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|processing mode: 0 crash and stop, 1 restart after crash, 2 try to submit error information to external tools and restart after crash 3. write key information to flash when crash and restart immediately|

**Return Value**

None

**Examples**

```lua
mcu.hardfault(0)    --Shutdown after crash, generally used for debugging status
mcu.hardfault(1)    --Restart after crash, generally used for official products
mcu.hardfault(2)    --After the crash, try to submit the error information to an external tool and restart it, generally used for stress testing or official products.

```

---

## mcu.iomux(type, channel, value)



Before the peripheral is opened, the peripheral IO is multiplexed to the non-default configuration. Currently, only some Air780E peripherals are supported to be multiplexed to other configurations. This is a temporary interface. If there is a more suitable api in the future, this interface will not be updated.

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Peripheral type, currently only mcu.UART,mcu.I2C|
|int|Bus serial number，0~N，|
|int|The new configuration needs to be decided according to the specific platform.|

**Return Value**

None

**Examples**

```lua
mcu.iomux(mcu.UART, 2, 1)    -- Air780E UART2 is multiplexed to gpio12 and gpio13(Air780EG default is this multiplexing, don't move)
mcu.iomux(mcu.UART, 2, 2)    -- Air780E UART2 is multiplexed to gpio6 and gpio7
mcu.iomux(mcu.I2C, 0, 1)    -- Air780E of I2C0 multiplexed to gpio12 and gpio13
mcu.iomux(mcu.I2C, 0, 2)    -- Air780E The I2C0 is multiplexed to gpio16 and gpio17
mcu.iomux(mcu.I2C, 1, 1)    -- Air780E of I2C1 multiplexing to gpio4 and gpio5

```

---

## mcu.altfun(type, sn, pad_index, alt_fun, is_input)



IO Peripheral function multiplexing selection, note that the common MCU uses GPIO number as the serial number, but the dedicated SOC, such as CAT1, uses PAD number as the serial number. This function is not applicable to all platforms

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|Peripheral types, currently mcu.UART,mcu.I2C,mcu.SPI,mcu.PWM,mcu.GPIO,mcu.I2S,mcu.LCD,mcu.CAM, depending on the platform|
|int|Bus serial number, 0 ~ N, if it is mcu.GPIO, it is GPIO number. Specifically look at the platform's IOMUX multiplexing table.|
|int|pad No., if left blank, it means to clear the configuration and use the default configuration of the platform. Specifically look at the platform's IOMUX multiplexing table.|
|int|Serial number of multiplexing function, 0 ~ N. Specifically look at the platform's IOMUX multiplexing table.|
|boolean|Whether it is an input function, true is, and blank is false|

**Return Value**

None

**Examples**

```lua
-- Take Air780EP for example
-- Map GPIO46 paddr 32 alt 1
mcu.altfun(mcu.GPIO, 46, 32, 1, 0)
-- mcu.altfun(mcu.GPIO, 46) -- Restore to default configuration

-- UART2 Reuse paddr 25/26 alt 3
mcu.altfun(mcu.UART,2,  25, 3, 1)
mcu.altfun(mcu.UART,2,  26, 3, 0)

```

---

## mcu.ticks2(mode)



Get high-precision counts

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|int|mode, see the following instructions|

**Return Value**

|return value type | explanation|
|-|-|
|int|The return value has different meanings depending on the mode|

**Examples**

```lua
-- This function was added in 2024.5.7
-- The difference with mcu.ticks() is that the underlying counter is 64bit and will not overflow in the foreseeable future
-- Therefore, the value returned by this function is always incremented, and the 32bit firmware can also handle it.

-- Mode optional values and corresponding return values
-- 0: Returns the number of microseconds, divided by seconds, for example 1234567890us returns 2 values: 1234, 567890
-- 1: Returns the number of milliseconds, divided by thousands of seconds, for example, 1234567890ms returns two values: 1234, 567890
-- 2: Returns the number of seconds, divided into millions of seconds, for example 1234567890s returns 2 values: 1234, 567890

local us_h, us_l = mcu.ticks2(0)
local ms_h, ms_l = mcu.ticks2(1)
local sec_h, sec_l = mcu.ticks2(2)
log.info("us_h", us_h, "us_l", us_l)
log.info("ms_h", ms_h, "ms_l", ms_l)
log.info("sec_h", sec_h, "sec_l", sec_l)

```

---

## mcu.XTALRefOutput(source_main, source_32k)



Crystal reference clock output

**Parameters**

|Incoming Value Type | Explanation|
|-|-|
|boolean|Whether the reference clock of high-speed crystal oscillator is output|
|boolean|Does the low-speed 32K crystal reference clock output|

**Return Value**

None

**Examples**

```lua
-- This function was added in 2024.5.17
-- Currently only Air780EP series support
mcu.XTALRefOutput(true, false)    --High-speed crystal reference clock output, low-speed 32K does not output

```

---

