按位非
bitwise non
按位非）操作。 行为和 "band" 操作类似。
bitwise not) operation. The behavior is similar to the "band" operation.
按位或
Bits or
按位或）操作。 行为和 "band" 操作类似。
bitwise or) operation. The behavior is similar to the "band" operation.
按位取反
bitwise inversion
按位异或
bitwise exclusive or
按位异或）操作。 行为和 "band" 操作类似。
bitwise XOR) operation. The behavior is similar to the "band" operation.
按位与
Bits and
按位与）操作。 行为和 "add" 操作类似， 不同的是 Lua 会在任何一个操作数无法转换为整数时 （参见 [§3.4.3](#3.4.3)）尝试取元方法。
bitwise and) operation. The behavior is similar to the "add" operation, except that Lua will try the element method when any of the operands cannot be converted to an integer (see [§ 3.4.3](#3.4.3)).
按选项 `op` 的方式对齐（忽略它的其它方面）的一个空条目
An empty entry aligned as the option `op` (ignoring other aspects of it)
把 `b` 作为一个布尔量压栈。
Put `B` as a Boolean quantity on the stack.
把 `data` 设为 _垃圾收集器步进倍率_ （参见 [§2.5](#2.5)），并返回之前设置的值。
Set `data` to_garbage collector step factor_(see [§ 2.5](#2.5)) and return to the previously set value.
把 `data` 设为 _垃圾收集器间歇率_ （参见 [§2.5](#2.5)），并返回之前设置的值。
Set `data` to_garbage collector intermittent rate_(see [§ 2.5](#2.5)) and return to the previously set value.
把 `L` 表示的线程压栈。 如果这个线程是当前状态机的主线程的话，返回
Stacks the thread represented by `L. If this thread is the main thread of the current state machine, return
把 `stdin` 当作一个文件运行，并中止对后面选项的处理。
Run `stdin` as a file and abort processing of the following options.
把 `t[i]` 的值压栈， 这里的 `t` 指给定的索引指代的值。 和在 Lua 里一样，这个函数可能会触发 "index" 事件的元方法 （参见
Stacks the value of`t [I] `, where `t` refers to the value referred to by the given index. As in Lua, this function may trigger the meta-method of the "index" event (see
把 `t[k]` 的值压栈， 这里的 `t` 是索引指向的值。 在 Lua 中，这个函数可能触发对应 "index" 事件对应的元方法 （参见
Stack the value of`t[k]`, where `t` is the value pointed to by the index. In Lua, this function may trigger the meta-method corresponding to the "index" event (see
把 `t[k]` 的值压栈， 这里的 `t` 是指给定索引处的表， `k` 是指针 `p` 对应的轻量用户数据。 这是一次直接访问；就是说，它不会触发元方法。
Stack the value of`t[k]`, where `t` refers to the table at a given index, and `k` is the lightweight user data corresponding to the pointer `p. This is a direct access; that is, it does not trigger the meta method.
把 `t[k]` 的值压栈， 这里的 `t` 是指索引指向的值， 而 `k` 则是栈顶放的值。
Stacks the value of`t[k]`, where `t` refers to the value pointed to by the index, and` k` is the value placed at the top of the stack.
把 `t[n]` 的值压栈， 这里的 `t` 是指给定索引处的表。 这是一次直接访问；就是说，它不会触发元方法。
Stacks the value of`t[n]`, where `t` refers to the table at the given index. This is a direct access; that is, it does not trigger the meta method.
把 `x` 设为伪随机数发生器的“种子”： 相同的种子产生相同的随机数列。
Set `x` as the "seed" of the pseudo-random number generator: the same seed produces the same random number sequence.
把 C 函数 `f` 设到全局变量 `name` 中。 它通过一个宏定义
Set C function `f` to global variable `name. It is defined by a macro
把从 `idx` 开始到栈顶的元素轮转 `n` 个位置。 对于 `n` 为正数时，轮转方向是向栈顶的； 当 `n` 为负数时，向栈底方向轮转 `-n` 个位置。 `n` 的绝对值不可以比参于轮转的切片长度大。
Rotate the elements starting from `idx` to the top of the stack by `n` positions. When `n` is a positive number, the rotation direction is to the top of the stack. When `n` is negative, it rotates `-n` positions to the bottom of the stack. The absolute value of `n` cannot be greater than the slice length of the rotation.
把浮点数转为字符串的地方，现在都对等于整数的浮点数加了 `.0` 后缀。 （例如，浮点数 2.0 会被打印成 `2.0`， 而不是 `2`。） 如果你需要定制数字的格式，就必须显式的格式化它们。
Where floating-point numbers are converted into strings, floating-point numbers equal to integers are now suffixed with `.0. (For example, floating point numbers 2.0 be printed as `2.0 `instead of `2`.) If you need to customize the format of numbers, you must explicitly format them.
把给定索引处的 Lua 值转换为 [`lua_Number`](#lua_Number) 这样一个 C 类型 （参见 lua\_Number ）。 这个 Lua 值必须是一个数字或是一个可转换为数字的字符串 （参见 [§3.4.3](#3.4.3)）； 否则， [`lua_tonumberx`](#lua_tonumberx) 返回
Converts the Lua value at the given index to a C type [lua_Number](#lua_Number) (see Lua \_Number). This Lua value must be a number or a string that can be converted to a number (see [§ 3.4.3](#3.4.3)); otherwise, [lua_tonumberx](#lua_tonumberx) returns
把给定索引处的 Lua 值转换为一个 C 函数。 这个值必须是一个 C 函数； 如果不是就返回
Converts the Lua value at the given index to a C function. This value must be a C function; if not, it returns
把给定索引处的 Lua 值转换为一个 C 中的布尔量（ 0 或是 1 ）。 和 Lua 中做的所有测试一样， [`lua_toboolean`](#lua_toboolean) 会把任何不同于 **false** 和 **nil** 的值当作真返回； 否则就返回假。 （如果你想只接收真正的 boolean 值， 就需要使用 [`lua_isboolean`](#lua_isboolean) 来测试值的类型
Converts the Lua value at a given index to a boolean (0 or 1) in C. As with all tests in Lua, [lua_toboolean](#lua_toboolean) will return any values other than **false** and **nil** as true; otherwise, it will return false. (If you want to receive only real boolean values, you need to use [`lua_isboolean`](#lua_isboolean) to test the type of the value
把给定索引处的 Lua 值转换为一个 C 字符串。 如果 `len` 不为 `NULL` ， 它还把字符串长度设到 `*len` 中。 这个 Lua 值必须是一个字符串或是一个数字； 否则返回 `NULL` 。 如果值是一个数字， `lua_tolstring` 还会 _把堆栈中的那个值的实际类型转换为一个字符串_。 （当遍历一张表的时候， 若把 `lua_tolstring` 作用在键上， 这个转换有可能导致 [`lua_next`](#lua_next) 弄错
Converts the Lua value at the given index to a C string. If `len` is not `NULL`, it also sets the string length to `* len. The Lua value must be a string or a number; otherwise, `NULL` is returned `. If the value is a number, lua_tolstring will also convert the actual type of that value on the stack to a string_. (When traversing a table, if the lua_tolstring is applied to the key, this conversion may cause [`lua_next`](#lua_next) to be wrong
把给定索引处的值转换为一般的 C 指针 (`void*`) 。 这个值可以是一个用户对象，表 ，线程或是一个函数； 否则， `lua_topointer` 返回 `NULL` 。 不同的对象有不同的指针。 不存在把指针再转回原有类型的方法。
Converts the value at the given index to a generic C pointer (`void * `). This value can be a user object, a table, a thread, or a function; otherwise, lua_topointer returns NULL `. Different objects have different pointers. There is no way to return a pointer to the original type.
把给定索引处的值转换为一个 Lua 线程 （表示为 `lua_State*`）。 这个值必须是一个线程； 否则函数返回
Converts the value at the given index to a Lua thread (denoted as `lua_State * `). This value must be a thread; otherwise the function returns
把函数导出成二进制代码块 。 函数接收栈顶的 Lua 函数做参数， 然后生成它的二进制代码块。 若被导出的东西被再次加载， 加载的结果就相当于原来的函数。 当它在产生代码块的时候， [`lua_dump`](#lua_dump) 通过调用函数 `writer` （参见 [`lua_Writer`](#lua_Writer) ） 来写入数据，后面的 `data` 参数会被传入
Export the function as a block of binary code. The function receives the Lua function at the top of the stack as an argument and then generates its binary code block. If the exported thing is loaded again, the result of the load is equivalent to the original function. When it generates a code block, [lua_dump](#lua_dump) writes data by calling the function `writer` (see [lua_Writer](#lua_Writer) ), followed by the `data` parameter.
把全局变量 name 里的值压栈，返回该值的类型。
Stacks the value in the global variable name and returns the type of the value.
把数组 `l` 中的所有函数 （参见 [`luaL_Reg`](#luaL_Reg)） 注册到栈顶的表中（该表在可选的上值之下，见下面的解说
Register all functions in array `l` (see [luaL_Reg](#luaL_Reg)) in a table at the top of the stack (the table is below the optional upper value, see the explanation below
把一段缓存加载为一个 Lua 代码块。 这个函数使用 [`lua_load`](#lua_load) 来加载 `buff` 指向的长度为 `sz` 的内存区。
Load a cache as a block of Lua code. This function uses [lua_load](#lua_load) to load the memory area of length `sz` pointed to by `buff.
把一个代码块当作一个拥有不定参数的匿名函数 （参见[§3.4.11](#3.4.11)）来处理。 正是这样，代码块内可以定义局部变量，它可以接收参数，返回若干值。 此外，这个匿名函数在编译时还为它的作用域绑定了一个外部局部变量 `_ENV` （参见 [§2.2](#2.2)）。 该函数总是把 `_ENV` 作为它唯一的一个上值， 即使这个函数不使用这个变量，它也存在。
Treat a block of code as an anonymous function with indefinite parameters (see [§ 3.4.11](#3.4.11)). In this way, local variables can be defined within the code block, which can receive parameters and return several values. In addition, the anonymous function is compiled with an external local variable `_ENV` bound to its scope (see [§ 2.2](#2.2)). The function always has `_ENV` as its only upper value, even if the function does not use this variable, it still exists.
把一个格式化过的字符串压栈， 然后返回这个字符串的指针。 它和 C 函数 `sprintf` 比较像， 不过有一些重要的区别
Stacks a formatted string and returns a pointer to the string. It is similar to the C function `sprintf`, but with some important differences.
把一个轻量用户数据压栈。
Stacks a lightweight user data.
把一个文件加载为 Lua 代码块。 这个函数使用 [`lua_load`](#lua_load) 加载文件中的数据。 代码块的名字被命名为 `filename`。 如果 `filename` 为 `NULL`， 它从标准输入加载。 如果文件的第一行以 `#` 打头，则忽略这一行。
Load a file as a Lua code block. This function uses [lua_load](#lua_load) to load data from a file. The name of the code block is called `filename `. If `filename` is `NULL`, it is loaded from standard input. If the first line of the file is prefixed with `#`, this line is ignored.
把一个新的 C 闭包压栈。
Put a new C closure on the stack.
把一个值为 `n` 的浮点数压栈。
Stacks a floating point number with a value of `n.
把一张表弹出栈，并将其设为给定索引处的值的元表。
Pop a table off the stack and make it the meta table for the value at the given index.
把栈顶元素放置到给定位置而不移动其它元素 （因此覆盖了那个位置处的值），然后将栈顶元素弹出。
The top-of-stack element is placed at a given position without moving other elements (thus overwriting the value at that position), and then the top-of-stack element is popped.
把栈顶元素移动到指定的有效索引处， 依次移动这个索引之上的元素。 不要用伪索引来调用这个函数， 因为伪索引没有真正指向栈上的位置。
Move the top element of the stack to the specified valid index, and then move the elements above this index. Do not call this function with a pseudo-index, because the pseudo-index does not really point to a location on the stack.
把栈上给定索引处的元素作一个副本压栈。
Stacks a copy of the element at a given index on the stack.
把正在运行中指定层次处函数压栈
Stacks the function at the specified level in the running.
把值为 `n` 的整数压栈。
Stacks an integer with the value `n.
把指定状态机的分配器函数换成带上用户数据 `ud` 的
Replace the allocator function of the specified state machine with the one with the user data` ud`
把指针 `s` 指向的长度为 `len` 的字符串压栈。 Lua 对这个字符串做一个内部副本（或是复用一个副本）， 因此 `s` 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途。 字符串内可以是任意二进制数据，包括零字符。
Stacks the string of length `len` pointed to by pointer`s. Lua makes an internal copy of this string (or reuses a copy), so the memory at `s` can be released or reused immediately after the function returns. Within the string can be any binary data, including zero characters.
包管理库
Package Management Library
包管理库提供了从 Lua 中加载模块的基础库。 只有一个导出函数直接放在全局环境中： [`require`](#pdf-require)。 所有其它的部分都导出在表 `package` 中。
The package management library provides the base for loading modules from Lua. Only one exported function is placed directly in the global environment: [`require`](#pdf-require). All other parts are exported in the table `package.
保存有一些特殊模块的加载器 （参见
holds a loader with some special modules (see
保有一个被称为 _全局环境_ 特别环境。它被保存在 C 注册表 （参见 [§4.5](#4.5)）的一个特别索引下。 在 Lua 中，全局变量 [`_G`](#pdf-_G) 被初始化为这个值。 （[`_G`](#pdf-_G) 不被内部任何地方使用
There is a special environment called_global environment. It is stored under a special index in the C registry (see [§ 4.5](#4.5)). In Lua, the global variable [`_G`](#pdf-_G) is initialized to this value. ([`_G`](#pdf-_G) is not used anywhere internally
被 [`lua_dump`](#lua_dump) 用到的写入器函数。 每次 [`lua_dump`](#lua_dump) 产生了一段新的代码块， 它都会调用写入器。 传入要写入的缓冲区 (`p`) 和它的尺寸 (`sz`) ， 以及传给 [`lua_dump`](#lua_dump) 的参数
Writer function used by [lua_dump](#lua_dump). Each time [lua_dump](#lua_dump) spawns a new block of code, it calls the writer. Pass in the buffer to be written (`p`) and its size (`sz`), and the parameters passed to [lua_dump](#lua_dump)
被 `_ENV` 用于值的那张表被称为 _环境
The table used by `_ENV` for values is called_environment
被调用函数内发生的错误将（通过 `longjmp` ）一直上抛。
Errors that occur within the called function will always be thrown up (via `longjmp`).
被调整为 1 个结果 （c 收到
were adjusted to 1 result (c received
被调整为 2 个结果
Adjusted for 2 results
被调整为 3 个结果
Adjusted for 3 results
被调整为一个结果
be adjusted to a result
被括号括起来的表达式永远被当作一个值。 所以， `(f(x,y,z))` 即使 `f` 返回多个值， 这个表达式永远是一个单一值。 （`(f(x,y,z))` 的值是 `f` 返回的第一个值。 如果 `f` 不返回值的话，那么它的值就是
An expression enclosed in parentheses is always treated as a value. So, `(f(x,y,z))` even though `f` returns multiple values, the expression will always be a single value. The value of (`(f(x,y,z))` is the first value returned by `f. If `f` does not return a value, then its value is
被用来结束 **while**、 **repeat**、或 **for** 循环， 它将跳到循环外接着之后的语句运行
Is used to end a **while**, **repeat**, or **for** loop, which jumps to the next statement outside the loop to run
被用于从函数或是代码块（其实它就是一个函数） 中返回值。 函数可以返回不止一个值，所以 **return** 的语法为
is used to return a value from a function or block of code (which is actually a function). A function can return more than one value, so the syntax for **return** is
被转译成
be translated
本章描述了语言的基本概念。
This chapter describes the basic concepts of language.
比较操作符
Comparison Operators
比较两个 Lua 值。 当索引 `index1` 处的值通过 `op` 和索引 `index2` 处的值做比较后条件满足，函数返回 1 。 这个函数遵循 Lua 对应的操作规则（即有可能触发元方法）。 反之，函数返回 0。 当任何一个索引无效时，函数也会返回
Compares two Lua values. When the value at index `index1` is compared with the value at index `index2` by `op`, the function returns 1. This function follows Lua`s corresponding operation rules (I. e., it is possible to trigger meta methods). Otherwise, the function returns 0. When either index is invalid, the function also returns
闭包
closure
编程接口
Programming Interface
变量
Variable
变量是储存值的地方。 Lua 中有三种变量： 全局变量、局部变量和表的域。
Variables are where values are stored. There are three types of variables in Lua: global variables, local variables, and fields of tables.
标签和没有内容的语句被称为_空语句_，它们不做任何操作。
Labels and statements without content are called_empty statements_and they do nothing.
标准库
Standard Library
标准库提供了一些有用的函数, 它们都是直接用 C API 实现的。 其中一些函数提供了原本语言就有的服务 （例如，[`type`](#pdf-type) 与 [`getmetatable`](#pdf-getmetatable)）； 另一些提供和“外部”打交道的服务（例如 I/O ）； 还有些本可以用 Lua 本身来实现，但在 C 中实现可以满足关键点上的性能需求 （例如
The standard library provides some useful functions that are implemented directly in the C API. Some of these functions provide services that are native to the language (e. g.,[`type`](#pdf-type) and [`getmetatable`](#pdf-getmetatable)); Others provide services that deal with "external" (e. g. I/O ); Still others could have been implemented in Lua itself, but implemented in C can meet key performance requirements (e. g.
标准输入输出库中用到的标准文件句柄结构。
The standard file handle structure used in the standard input and output library.
表 `io` 中也提供了三个 和 C 中含义相同的预定义文件句柄： `io.stdin`， `io.stdout`， 以及 `io.stderr`。 I/O 库永远不会关闭这些文件。
The table `io` also provides three predefined file handles with the same meaning as in C: `io.stdin`, `io.stdout`, and `io.stderr `. The I/O library never closes these files.
表，用户数据，以及线程都按引用比较： 只有两者引用同一个对象时才认为它们相等。 每次你创建一个新对象（一张表，一个用户数据，或一个线程）， 新对象都一定和已有且存在的对象不同。 相同引用的闭包一定相等。 有任何可察觉的差异（不同的行为，不同的定义）一定不等。
Tables, user data, and threads are all compared by reference: they are considered equal only if they refer to the same object. Every time you create a new object (a table, user data, or a thread), the new object must be different from the existing and existing object. Closure of the same reference must be equal. Any perceptible differences (different behaviors, different definitions) must be unequal.
表、函数、线程、以及完全用户数据在 Lua 中被称为 _对象_： 变量并不真的 _持有_ 它们的值，而仅保存了对这些对象的 _引用_。 赋值、参数传递、函数返回，都是针对引用而不是针对值的操作， 这些操作均不会做任何形式的隐式拷贝。
Tables, functions, threads, and full user data are called_objects_in Lua: variables do not really_hold_their values, but only_references_to these objects_. Assignments, parameter passing, and function returns are all operations on references rather than values, and none of these operations do any form of implicit copy.
表处理
Table Processing
表处理库现在在读写其中的元素时会考虑元方法。
The table processing library now considers meta methods when reading and writing elements within them.
表达式
Expression
表达式放在 [§3.4](#3.4) 中讨论。
Expressions are discussed in [§ 3.4](#3.4).
表放在索引 't' 处
Table placed at index't'
表构建
Table Construction
表构造子是一个构造表的表达式。 每次构造子被执行，都会构造出一张新的表。 构造子可以被用来构造一张空表， 也可以用来构造一张表并初始化其中的一些域。 一般的构造子的语法如下
A table constructor is an expression that constructs a table. Each time the constructor is executed, a new table is constructed. Constructors can be used to construct an empty table, or they can be used to construct a table and initialize some of its fields. The general constructor syntax is as follows
表和完全用户数据有独立的元表 （当然，多个表和用户数据可以共享同一个元表）。 其它类型的值按类型共享元表； 也就是说所有的数字都共享同一个元表， 所有的字符串共享另一个元表等等。 默认情况下，值是没有元表的， 但字符串库在初始化的时候为字符串类型设置了元表 （参见
Tables and full user data have separate meta tables (of course, multiple tables and user data can share the same meta table). Other types of values share a meta table by type; that is, all numbers share the same meta table, all strings share another meta table, and so on. By default, the value has no meta table, but the string library sets the meta table for the string type at initialization (see.
表控制
Table Control
表示 _set_ 的补集， 其中 _set_ 如上面的解释。
Represents the complement of_set_, where_set_is as explained above.
表示 _set_　中所有字符的联合。 可以以 '`-`' 连接，升序书写范围两端的字符来表示一个范围的字符集。 上面提到的 `%`_x_ 形式也可以在 _set_ 中使用 表示其中的一个元素。 其它出现在 _set_ 中的字符则代表它们自己。 例如，`[%w_]` （或 `[_%w]`） 表示所有的字母数字加下划线）， `[0-7]` 表示 8 进制数字， `[0-7%l%-]`　表示 8 进制数字加小写字母与 '`-`' 字符。
Represents the union of all characters in_set. Characters at both ends of a range can be written in ascending order to represent a range of character sets. The `%`_x_form mentioned above can also be used in_set_to represent one of the elements. Other characters that appear in_set_represent themselves. For example, `[%w_]` (or `[_%w]`) means all alphanumerics plus underscores), `[0-7]` means octuary digits, and `[0-7% l%-]` means octuary digits plus lowercase letters and ``-`` characters.
表示任何除空白符外的可打印字符。
Represents any printable character other than a white-space character.
表示任何控制字符。
Represents any control character.
表示任何数字。
Represents any number.
表示任何字母。
Indicates any letter.
表示所有 16 进制数字符号。
Represents all hexadecimal numeric symbols.
表示所有标点符号。
Represents all punctuation marks.
表示所有大写字母。
Indicates all uppercase letters.
表示所有空白字符。
Represents all white space characters.
表示所有小写字母。
Indicates all lowercase letters.
表示所有字母及数字。
Represents all letters and numbers.
表示一个可选的整数。） 除填充、空格、配置项（选项 "`xX <=>!`"）外， 每个选项都关联一个参数（对于 [`string.pack`](#pdf-string.pack)） 或结果（对于
Represents an optional integer.) Except padding, spaces, configuration items (option "`xX <=>! `"), each option is associated with a parameter (for [`string.pack`](#pdf-string.pack)) or a result (
表是 Lua 中唯一的数据结构， 它可被用于表示普通数组、序列、符号表、集合、记录、图、树等等。 对于记录，Lua 使用域名作为索引。 语言提供了 `a.name` 这样的语法糖来替代 `a["name"]` 这种写法以方便记录这种结构的使用。 在 Lua 中有多种便利的方式创建表（参见
Tables are the only data structures in Lua that can be used to represent ordinary arrays, sequences, symbolic tables, collections, records, graphs, trees, and so on. For records, Lua uses the domain name as an index. The language provides syntactic sugar such as `a.name` instead of `a["name"]`to facilitate the use of this structure. There are several convenient ways to create tables in Lua (cf.
捕获
Capture
不等于
not equal
不缓冲；输出操作立刻生效。
Not buffered; the output operation takes effect immediately.
不会对二进制代码块做健壮性检查。 恶意构造一个二进制块有可能把解释器弄崩溃。
Binary code blocks are not checked for robustness. Maliciously constructing a binary block has the potential to crash the interpreter.
不是一个序列，因为它有键 `4` 却没有键 `3`。 （因此，该表的正整数键集不等于 _{1..n}_ 集合，故而就不存在 _n_。） 注意，一张表是否是一个序列和它的非数字键无关。
is not a sequence because it has bond `4` but no bond `3 `. (Therefore, the set of positive integer keys for the table is not equal to the_{1 .. n}_set, so there is no_n_.) Note that whether a table is a sequence has nothing to do with its non-numeric keys.
不在主线程中或不在一个无法让出的 C 函数中时，当前协程是可让出的。
The current coroutation is transferable when it is not in the main thread or in a C function that cannot be transferred.
采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。 Lua 运行了一个 _垃圾收集器_ 来收集所有 _死对象_ （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。
Automatic memory management. This means that you don't have to worry about how the memory needed by newly created objects is allocated, or how to release the memory occupied by objects after they are no longer in use. Lua runs a_garbage collector_to collect all_dead objects_(that is, objects that are no longer accessible in Lua) to complete the work of automatic memory management. All memory used in Lua, such as strings, tables, user data, functions, threads, internal structures, etc., are subject to automatic management.
参见函数 [`next`](#pdf-next) 中关于迭代过程中修改表的风险。
See the function [`next`](#pdf-next) for the risk of modifying a table during an iteration.
参考手册
Reference Manual
参数 `f` 是钩子函数。 `mask` 指定在哪些事件时会调用： 它由下列一组位常量构成 `LUA_MASKCALL`， `LUA_MASKRET`， `LUA_MASKLINE`， `LUA_MASKCOUNT`。 参数 `count` 只在掩码中包含有 `LUA_MASKCOUNT` 才有意义。 对于每个事件，钩子被调用的情况解释如下
The parameter `f` is a hook function. `mask` specifies which events are called upon: it consists of the following set of bit constants LUA_MASKCALL, LUA_MASKRET, LUA_MASKLINE, LUA_MASKCOUNT `. The parameter `count` is meaningful only if it contains a LUA_MASKCOUNT in the mask. For each event, the case where the hook is called is explained as follows
参数 `f` 也可以是一个函数。 这种情况下，`getlocal` 仅返回函数形参的名字。
The parameter `f` can also be a function. In this case, `getlocal` returns only the name of the function parameter.
参数 `from` 表示协程从哪个协程中来延续 `L` 的。 如果不存在这样一个协程，这个参数可以是
The parameter `from` indicates from which the coroutation continues `L. If such a coroutage does not exist, this parameter can be
参数的个数
Number of parameters
参数的数量
Number of parameters
参数的语法如下
The syntax of the parameter is as follows
参数允许传入任何索引以及 0 。 它将把堆栈的栈顶设为这个索引。 如果新的栈顶比原来的大， 超出部分的新元素将被填为 **nil** 。 如果 `index` 为 0 ， 把栈上所有元素移除。
The parameter allows any index to be passed in as well as 0. It will set the top of the stack to this index. If the new top of the stack is larger than the original, the excess new elements will be filled with **nil * *. If `index` is 0, all elements on the stack are removed.
操作。 如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用元方法。 首先、Lua 检查第一个操作数（即使它是合法的）， 如果这个操作数没有为 "`__add`" 事件定义元方法， Lua 就会接着检查第二个操作数。 一旦 Lua 找到了元方法， 它将把两个操作数作为参数传入元方法， 元方法的结果（调整为单个值）作为这个操作的结果。 如果找不到元方法，将抛出一个错误。
Operation. If any value that is not a number (including a string that cannot be converted to a number) is added, Lua will try to call the meta method. First, Lua checks the first operand (even if it is legal). If this operand does not have a meta method defined for the "`__add`" event, Lua checks the second operand. Once Lua finds the meta-method, it will pass the two operands as parameters to the meta-method, and the result of the meta-method (adjusted to a single value) as the result of the operation. If the meta method cannot be found, an error will be thrown.
操作。 行为和 "add" 操作类似。
Operation. The behavior is similar to the "add" operation.
操作完全等价于 (`==`) 操作的反值。
The operation is completely equivalent to the inverse of the (`= =`) operation.
操作系统库
Operating System Library
层指当前正在运行的函数， 1 层指调用正在运行函数的函数， 依次类推。
Layer refers to the currently running function, layer 1 refers to the function that calls the running function, and so on.
查找第一个字符串 `s` 中匹配到的 `pattern` （参见 [§6.4.1](#6.4.1)）。 如果找到一个匹配，`find` 会返回 `s` 中关于它起始及终点位置的索引； 否则，返回 **nil**。 第三个可选数字参数 `init` 指明从哪里开始搜索； 默认值为 1 ，同时可以是负值。 第四个可选参数 `plain` 为 **true** 时， 关闭模式匹配机制。 此时函数仅做直接的 “查找子串”的操作， 而 `pattern` 中没有字符被看作魔法字符。 注意，如果给定了 `plain`　，就必须写上
Find the matching `pattern` in the first string `s` (see [§ 6.4.1](#6.4.1)). If a match is found, `find` returns the index in `s` about where it starts and ends; otherwise, **nil** is returned * *. The third optional numeric parameter `init` indicates where to start the search; it defaults to 1 and can be negative. When the fourth optional parameter `plain` is **true**, the pattern matching mechanism is disabled. At this point, the function only does the direct "find substring" operation, and no characters in `pattern` are regarded as magic characters. Note that if `plain` is given, it must be written on
查找器查找模块 `foo` 会依次尝试打开文件 `./foo.so`，`./foo.dll`， 以及 `/usr/local/foo/init.so`。 一旦它找到一个 C 库， 查找器首先使用动态链接机制连接该库。 然后尝试在该库中找到可以用作加载器的 C 函数。 这个 C 函数的名字是 "`luaopen_`" 紧接模块名的字符串， 其中字符串中所有的下划线都会被替换成点。 此外，如果模块名中有横线， 横线后面的部分（包括横线）都被去掉。 例如，如果模块名为 `a.b.c-v2.1`， 函数名就是
The finder lookup module `foo` attempts to open the files `./foo.so`,`./foo.dll`, and `/usr/local/foo/init.so`. Once it finds a C library, the finder first connects to the library using a dynamic linking mechanism. Then try to find a C function in that library that you can use as a loader. The name of this C function is "`luaopen_`" a string immediately following the module name, where all underscores in the string are replaced with dots. In addition, if there is a horizontal line in the module name, the part after the horizontal line (including the horizontal line) is removed. For example, if the module is named `a. B. c-v2.1, `the function name is
成功。
Success.
成功时，函数返回 `file`。 否则返回 **nil** 加错误描述字符串。
On success, the function returns `file `. Otherwise, **nil** plus the error description string is returned.
乘法
Multiplication
乘方
power
乘方和浮点除法 （`/`） 总是把操作数转换成浮点数进行，其结果总是浮点数。 乘方使用 ISO C 函数 `pow`， 因此它也可以接受非整数的指数。
The power and floating-point division (`/`) always converts the operand to a floating-point number, and the result is always a floating-point number. The power uses the ISO C function `pow`, so it can also accept non-integer exponents.
程序可以通过 `__len` 元方法（参见 [§2.4](#2.4)） 来修改对字符串类型外的任何值的取长度操作行为。
The `__len` meta-method (see [§ 2.4](#2.4)) can be used to modify the behavior of the length operation on any value outside of the string type.
初始化缓存 `B`。 这个函数不会分配任何空间； 缓存必须以一个变量的形式声明 （参见
Initialize cache `B`. This function does not allocate any space; the cache must be declared as a variable (cf.
初始化域表可以在最后多一个分割符， 这样设计可以方便由机器生成代码。
The initialization domain table can have one more separator at the end, so that the design can be easily generated by the machine.
除 `-i` 与 `-E` 外所有的选项都按次序处理。 例如，这样调用
All options except `-I` and `-E` are processed in order. For example, this call
除非另有说明， 当一个函数需要一个字节位置的参数时， 都假定这个位置要么从字节序列的开始计算， 要么从字符串长度加一的位置算。 和字符串库一样，负的索引从字符串末尾计起。
Unless otherwise stated, when a function requires an argument for a byte position, it is assumed that the position is calculated either from the beginning of the byte sequence or from the position of the string length plus one. As with string libraries, negative indexes start at the end of the string.
除非另有说明， 任何可以接受有效索引的函数同时也接受 _伪索引_。 伪索引指代一些可以被 C code 访问得到 Lua 值，而它们又不在栈内。 这用于访问注册表以及 C 函数的上值（参见
Unless otherwise noted, any function that can accept a valid index also accepts a_pseudo-index_. Pseudo-indexes refer to Lua values that can be accessed by C code, but they are not on the stack. This is used to access the registry as well as the upper value of the C function (see
除非另有说明， I/O 函数在出错时都返回 **nil** （第二个返回值为错误消息，第三个返回值为系统相关的错误码）。 成功时返回与 **nil** 不同的值。 在非 POSIX 系统上， 根据错误码取出错误消息的过程可能并非线程安全的， 因为这使用了 C 的全局变量
Unless otherwise noted, I/O functions return **nil** when an error occurs (the second return value is the error message, and the third return value is the system-related error code). A value different from **nil** is returned on success. On non-POSIX systems, the process of fetching error messages based on error codes may not be thread-safe because it uses C's global variables
除了 Lua 状态，延续函数还有两个参数： 一个是调用最后的状态码，另一个一开始由 [`lua_pcallk`](#lua_pcallk) 传入的上下文 （`ctx`）。 （Lua 本身不使用这个值；它仅仅从原函数转发这个值给延续函数。） 对于 [`lua_pcallk`](#lua_pcallk) 而言， 状态码和 [`lua_pcallk`](#lua_pcallk) 本应返回值相同，区别仅在于发生过让出后才执行完时，状态码为 [`LUA_YIELD`](#pdf-LUA_YIELD)（而不是 [`LUA_OK`](#pdf-LUA_OK)）。 对于 [`lua_yieldk`](#lua_yieldk) 和 [`lua_callk`](#lua_callk) 而言， 调用延续函数传入的状态码一定是 [`LUA_YIELD`](#pdf-LUA_YIELD)。 （对这两个函数，Lua 不会因任何错误而调用延续函数。 因为它们并不处理错误。） 同样，当你使用 [`lua_callk`](#lua_callk) 时， 你应该用 [`LUA_OK`](#pdf-LUA_OK) 作为状态码来调用延续函数。 （对于 [`lua_yieldk`](#lua_yieldk)， 几乎没有什么地方需要直接调用延续函数， 因为 [`lua_yieldk`](#lua_yieldk) 本身并不会返回
In addition to the Lua state, the continuation function has two parameters: one is the last state code of the call, and the other is the context (`ctx`) initially passed in by [lua_pcallk](#lua_pcallk). (Lua does not use this value itself; it simply forwards the value from the original function to the continuation function.) For [`lua_pcallk`](#lua_pcallk), the status code and [`lua_pcallk`](#lua_pcallk) should return the same value, except that the status code is [`LUA_YIELD`](#pdf-LUA_YIELD)(instead of [`LUA_OK `](#pdf-LUA_ OK)) when the execution is completed after a release. For [`lua_yieldk`](#lua_yieldk) and [`lua_callk`](#lua_callk), the status code passed in by calling the continuation function must be [`LUA_YIELD`](#pdf-LUA_YIELD). (For these two functions, Lua does not call continuation functions for any errors, because they do not handle errors.) Similarly, when you use [lua_callk](#lua_callk), you should use [`LUA_OK `](#pdf-LUA_ OK) as the status code to call the continuation function. (For [lua_yieldk](#lua_yieldk), there is almost no place to call the continuation function directly, because [lua_yieldk](#lua_yieldk) itself does not return
除了乘方和浮点除法运算， 数学运算按如下方式工作： 如果两个操作数都是整数， 该操作以整数方式操作且结果也将是一个整数。 否则，当两个操作数都是数字或可以被转换为数字的字符串 （参见 [§3.4.3](#3.4.3)）时， 操作数会被转换成两个浮点数， 操作按通常的浮点规则（一般遵循 IEEE 754 标准） 来进行，结果也是一个浮点数。
With the exception of power and floating-point division operations, mathematical operations work as follows: If both operands are integers, the operation operates as an integer and the result will also be an integer. Otherwise, when both operands are numbers or strings that can be converted to numbers (see [§ 3.4.3](#3.4.3)), the operands are converted to two floating-point numbers, and the operation is performed according to the usual floating-point rules (generally following the IEEE 754 standard), and the result is also a floating-point number.
除了第一个（预加载）搜索器外，每个搜索器都会返回 它找到的模块的文件名。 这和 [`package.searchpath`](#pdf-package.searchpath) 的返回值一样。 第一个搜索器没有返回值。
Except for the first (preloaded) searcher, each searcher returns the filename of the module it finds. This is the same as the return value of [`package.searchpath`](#pdf-package.searchpath). The first searcher has no return value.
除了基础库和包管理库， 其它库都把自己的函数放在一张全局表的域中， 或是以对象方法的形式提供。
With the exception of the base library and the package management library, all libraries place their functions in a domain of a global table, or provide them as object methods.
除了在内嵌函数中，以及在内嵌语句块中定义了同名标签，的情况外， 标签对于它定义所在的整个语句块可见。 只要 goto 没有进入一个新的局部变量的作用域，它可以跳转到任意可见标签处。
The label is visible to the entire statement block in which it is defined, except in the case where a label with the same name is defined in an embedded function and in an embedded statement block. As long as goto does not enter the scope of a new local variable, it can jump to any visible label.
处理输入非默认整数类型的宏 （`luaL_checkint`， `luaL_optint`， `luaL_checklong`， `luaL_optlong`） 废弃掉了。 直接使用 [`lua_Integer`](#lua_Integer) 加一个类型转换就可以替代 （或是只要有可能，就在你的代码中使用
Macros that handle input of non-default integer types (luaL_checkint, luaL_optint, luaL_checklong, luaL_optlong) are deprecated. Use [`lua_Integer`](#lua_Integer) directly plus a type conversion to replace (or use it in your code whenever possible
传入参数，以 _保护模式_ 调用函数 `f` 。 这意味着 `f` 中的任何错误不会抛出； 取而代之的是，`pcall` 会将错误捕获到，并返回一个状态码。 第一个返回值是状态码（一个布尔量）， 当没有错误时，其为真。 此时，`pcall` 同样会在状态码后返回所有调用的结果。 在有错误时，`pcall` 返回 **false** 加错误消息。
Pass in the parameter to call the function `f` in_protected mode `. This means that any error in `f` will not be thrown; instead, `pcall` will catch the error and return a status code. The first return value is the status code (a boolean), which is true when there are no errors. In this case, `pcall` will also return the results of all calls after the status code. When there is an error, `pcall` returns **false** plus the error message.
创建一个新的 Lua 状态机。 它以一个基于标准 C 的 `realloc` 函数实现的内存分配器 调用 [`lua_newstate`](#lua_newstate) 。 并把可打印一些出错信息到标准错误输出的 panic 函数（参见 [§4.6](#4.6)） 设置好，用于处理致命错误。
Create a new Lua state machine. It calls [lua_newstate](#lua_newstate) with a memory allocator based on the standard C implementation of the `realloc` function. And set up a panic function (see [§ 4.6](#4.6)) that prints some error information to the standard error output to handle fatal errors.
创建一个运行在新的独立的状态机中的线程。 如果无法创建线程或状态机（由于内存有限）则返回 `NULL`。 参数 `f` 是一个分配器函数； Lua 将通过这个函数做状态机内所有的内存分配操作。 第二个参数 `ud` ，这个指针将在每次调用分配器时被转入。
Create a thread that runs in a new independent state machine. Returns `NULL` if the thread or state machine cannot be created (due to limited memory) `. Parameter `f` is an allocator function; Lua will use this function to do all memory allocation operations within the state machine. The second parameter `ud`, this pointer will be transferred in each call to the allocator.
创建一个主体函数为 `f` 的新协程。 `f` 必须是一个 Lua 的函数。 返回一个函数， 每次调用该函数都会延续该协程。 传给这个函数的参数都会作为 `resume` 的额外参数。 和 `resume` 返回相同的值， 只是没有第一个布尔量。 如果发生任何错误，抛出这个错误。
Create a new coprocess with a body function of `f. `f` must be a Lua function. Returns a function that continues the coroutation each time it is called. The arguments passed to this function will be extra arguments to `resume. and `resume` return the same value, just without the first boolean. If any error occurs, throw this error.
创建一个主体函数为 `f` 的新协程。 `f` 必须是一个 Lua 的函数。 返回这个新协程，它是一个类型为 `"thread"` 的对象。
Create a new coprocess with a body function of `f. `f` must be a Lua function. Returns this new coprocess, which is an object of type `"thread.
创建一条新线程，并将其压栈， 并返回维护这个线程的 [`lua_State`](#lua_State) 指针。 这个函数返回的新线程共享原线程的全局环境， 但是它有独立的运行栈。
Creates a new thread, pushes it on the stack, and returns the [`lua_State`](#lua_State) pointer that maintains this thread. The new thread returned by this function shares the global context of the original thread, but it has a separate run stack.
创建一张空表，并将其压栈。 它等价于
Create an empty table and stack it. It is equivalent
创建一张新的表，并把列表 `l` 中的函数注册进去。
Create a new table and register the functions in the list `l.
创建一张新的表，并预分配足够保存下数组 `l` 内容的空间（但不填充）。 这是给 [`luaL_setfuncs`](#luaL_setfuncs) 一起用的 （参见
Create a new table and pre-allocate enough space to hold the contents of array `l` (but not fill it). This is for use with [`luaL_setfuncs](#luaL_setfuncs) (cf.
创建一张新的空表压栈。 参数 `narr` 建议了这张表作为序列使用时会有多少个元素； 参数 `nrec` 建议了这张表可能拥有多少序列之外的元素。 Lua 会使用这些建议来预分配这张新表。 如果你知道这张表用途的更多信息，预分配可以提高性能。 否则，你可以使用函数
Creates a new empty table pressure stack. The parameter `narr` suggests how many elements the table will have when used as a sequence; the parameter `nrec` suggests how many elements outside the sequence the table may have. Lua will use these suggestions to pre-allocate the new table. If you know more about the purpose of this table, pre-allocation can improve performance. Otherwise, you can use the function
创建这个函数的代码块的名字。 如果 `source` 以 '`@`' 打头， 指这个函数定义在一个文件中，而 '`@`' 之后的部分就是文件名。 若 `source` 以 '`=`' 打头， 剩余的部分由用户行为来决定如何表示源码。 其它的情况下，这个函数定义在一个字符串中， 而 `source` 正是那个字符串。
The name of the block of code that created the function. If 'source' is preceded by ''@'', it means that the function is defined in a file, and the part after ''@'' is the file name. If 'source' is first with ''='', the rest is determined by user behavior how to represent the source code. In other cases, the function is defined in a string, and 'source' is exactly that string.
创建这个函数的代码块的名字。 如果 `source` 以 ``@`` 打头， 指这个函数定义在一个文件中，而 ``@`` 之后的部分就是文件名。 若 `source` 以 ``=`` 打头， 剩余的部分由用户行为来决定如何表示源码。 其它的情况下，这个函数定义在一个字符串中， 而 `source` 正是那个字符串。
The name of the block of code that created the function. If `source` is preceded by ``@``, it means that the function is defined in a file, and the part after ``@`` is the file name. If `source` is first with ``=``, the rest is determined by user behavior how to represent the source code. In other cases, the function is defined in a string, and `source` is exactly that string.
词法约定
lexical convention
此函数的返回值和 [`lua_load`](#lua_load) 相同， 不过它还可能产生一个叫做 `LUA_ERRFILE` 的出错码。这种错误发生于无法打开或读入文件时，或是文件的模式错误。
The return value of this function is the same as [lua_load](#lua_load), but it may also generate an error code called LUA_ERRFILE. This error occurs when the file cannot be opened or read, or the file has an incorrect mode.
此函数的返回值和 [`lua_load`](#lua_load) 相同。
The return value of this function is the same as [lua_load](#lua_load).
此函数返回函数 `f` 的第 `up` 个上值的名字和值。 如果该函数没有那个上值，返回
This function returns the name and value of the `up` top value of function `f. If the function does not have that upper value, return
此函数返回在栈的 `f` 层处函数的索引为 `local` 的局部变量 的名字和值。 这个函数不仅用于访问显式定义的局部变量，也包括形参、临时变量等。
This function returns the name and value of the function`s local variable with index `local` at the `f` level of the stack. This function is not only used to access explicitly defined local variables, but also includes formal parameters, temporary variables, etc.
此函数和 [`luaL_checkudata`](#luaL_checkudata) 类似。 但它在测试失败时会返回 `NULL` 而不是抛出错误。
This function is similar to [luaL_checkudata](#luaL_checkudata). But it returns `NULL` instead of throwing an error when the test fails.
此外， 传入一个不为零的 `count` ， 钩子将在每运行 `count` 条指令时调用。
In addition, a non-zero `count` is passed in, and the hook will be called every time the `count` instruction is run.
此引用是一个唯一的整数键。 只要你不向表 `t` 手工添加整数键， [`luaL_ref`](#luaL_ref) 可以保证它返回的键的唯一性。 你可以通过调用 `lua_rawgeti(L, t, r)` 来找回由 `r` 引用的对象。 函数 [`luaL_unref`](#luaL_unref) 用来释放一个引用关联的对象
This reference is a unique integer key. As long as you don`t manually add integer keys to table `t`, [luaL_ref](#luaL_ref) guarantees the uniqueness of the keys it returns. You can retrieve the object referenced by `r` by calling `lua_rawgeti(L, t, r). Function [`luaL_unref `](#luaL_unref) is used to release a reference to the associated object
次方）操作。 行为和 "add" 操作类似。
power) operation. The behavior is similar to the "add" operation.
从当前位置开始读取整个文件。 如果已在文件末尾，返回空串。
Reads the entire file from the current location. Returns an empty string if it is already at the end of the file.
从堆栈上弹出一个值，并将其设为全局变量 `name` 的新值。
Pop a value off the stack and set it to the new value of the global variable `name.
从给定活动记录或从一个函数中获取一个局部变量的信息。
Gets information about a local variable from a given activity record or from a function.
从给定有效索引处移除一个元素， 把这个索引之上的所有元素移下来填补上这个空隙。 不能用伪索引来调用这个函数，因为伪索引并不指向真实的栈上的位置。
Removes an element from a given valid index and removes all elements above that index to fill the gap. This function cannot be called with a pseudo index, because the pseudo index does not point to a real location on the stack.
从数字转换为字符串使用非指定的人可读的格式。 若想完全控制数字到字符串的转换过程， 可以使用字符串库中的 `format` 函数 （参见
Converts a number to a string using a non-specified human-readable format. To fully control the number-to-string conversion process, you can use the `format` function in the string library (see
从索引 `fromidx` 处复制一个值到一个有效索引 `toidx` 处，覆盖那里的原有值。 不会影响其它位置的值。
Copy a value from index `fromidx` to a valid index `toidx`, overwriting the original value there. Values in other locations are not affected.
从语法上说，可能有两种解释方式
Grammatically, there are two possible ways of interpretation
从栈顶弹出一个键， 然后把索引指定的表中的一个键值对压栈 （弹出的键之后的 “下一” 对）。 如果表中以无更多元素， 那么 [`lua_next`](#lua_next) 将返回 0 （什么也不压栈
Pop a key from the top of the stack, and then push a key-value pair in the table specified by the index (the "next" pair after the popped key). If there are no more elements in the table, then [lua_next](#lua_next) will return 0 (nothing is pushed on the stack
从栈上弹出一个值并将其设为给定索引处用户数据的关联值。
Pops a value from the stack and sets it as the associated value for the user data at the given index.
从栈中弹出 `n` 个元素。
Pop `n` elements from the stack.
从字符串到数字的转换过程遵循以下流程： 首先，遵循按 Lua 词法分析器的规则分析语法来转换为对应的 整数或浮点数。 （字符串可以有前置或后置的空格以及一个符号。） 然后，结果数字再按前述规则转换为所需要的类型（浮点或整数
The conversion process from a string to a number follows the following process: First, the syntax is analyzed according to the rules of the Lua lexer to convert to the corresponding integer or floating point number. (Strings can have leading or trailing spaces and a symbol.) The resulting number is then converted to the desired type (floating point or integer
错误处理
Error handling
打包和解包用到的格式串
Format string used for packaging and unpacking
打开该名字的文件，并执行文件中的 Lua 代码块。 不带参数调用时， `dofile` 执行标准输入的内容（`stdin`）。 返回该代码块的所有返回值。 对于有错误的情况，`dofile` 将错误反馈给调用者 （即，`dofile` 没有运行在保护模式下
Open the file with that name and execute the Lua code block in the file. When called without parameters, `dofile` performs the contents of the standard input (`stdin`). Returns all return values for this code block. For the case of errors, `dofile` feeds back the error to the caller (ie, `dofile` is not running in protected mode
打开指定状态机中的所有 Lua 标准库。
Opens all Lua standard libraries in the specified state machine.
打印版本信息
Print version information
大多数 API 函数都有可能抛出错误， 例如在内存分配错误时就会抛出。 每个函数的文档都会注明它是否可能抛出错误。
Most API functions have the potential to throw errors, such as when there is a memory allocation error. The documentation for each function notes whether it might throw an error.
大小比较操作以以下方式进行。 如果参数都是数字， 它们按二元操作的常规进行。 否则，如果两个参数都是字符串， 它们的值按当前的区域设置来比较。 再则，Lua 就试着调用 "lt" 或是 "le" 元方法 （参见 [§2.4](#2.4)）。 `a > b` 的比较被转译为 `b < a`， `a >= b` 被转译为
The size comparison operation is performed in the following manner. If the arguments are all numbers, they proceed in the regular of a binary operation. Otherwise, if both parameters are strings, their values are compared by the current locale. Then, Lua tries to call the "lt" or "le" meta-method (see [§ 2.4](#2.4)). The comparison of `a> B `is translated as` B <a` and `a >= B `is translated
大小端遵循本地设置
Size side follows local settings
大于
Greater
大于等于
Greater than or equal
代码块
Code Block
代码块可以被保存在文件中，也可以作为宿主程序内部的一个字符串。 要执行一个代码块， 首先要让 Lua _加载_ 它， 将代码块中的代码预编译成虚拟机中的指令， 而后，Lua 用虚拟机解释器来运行编译后的代码。
The code block can be saved in a file or as a string inside the host program. To execute a block of code, first have Lua load it, pre-compile the code in the block into instructions in the virtual machine, and then Lua uses the virtual machine interpreter to run the compiled code.
代码块可以被预编译为二进制形式； 参见程序 `luac` 以及函数 [`string.dump`](#pdf-string.dump) 可获得更多细节。 用源码表示的程序和编译后的形式可自由替换； Lua 会自动检测文件格式做相应的处理 （参见
A block of code can be pre-compiled into binary form; see the program `luac` and the function [`string.dump`](#pdf-string.dump) for more details. Programs expressed in source code and compiled forms can be freely replaced; Lua will automatically detect the file format for corresponding processing (see
带上值的函数只保存上值的数目。 当（再次）加载时，这些上值被更新为 **nil** 的实例。 （你可以使用调试库按你需要的方式来序列化上值，并重载到函数中
The function with values only holds the number of values. When loaded (again), these upper values are updated to instances of **nil. (You can use the debug library to serialize the upper value in the way you need and overload it into the function.
单步运行垃圾收集器。 步长“大小”由 `arg` 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回
Step into the garbage collector. The step size is controlled by `arg. When 0 is passed in, the collector is stepped (indivisible) by one step. Passing in a non-zero value, the collector collects the equivalent of Lua allocating these multiple (K bytes) of memory. If the collector ends a loop will return
单个名字可以指代一个全局变量也可以指代一个局部变量 （或者是一个函数的形参，这是一种特殊形式的局部变量
A single name can refer to a global variable or a local variable (or a formal parameter of a function, which is a special form of local variable.
单个字符类跟一个 '`-`'， 将匹配零或更多个该类的字符。 和 '`*`' 不同， 这个条目总是匹配尽可能短的串
A single character class followed by a ``-`` will match zero or more characters of that class. Unlike ``*``, this entry always matches the shortest possible string
单个字符类跟一个 '`?`'， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个
A single character class followed by a ''?'' will match zero or one character of that class. Whenever possible, it will match a
单个字符类跟一个 '`*`'， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串
A single character class followed by a ''*'' will match zero or more characters of that class. This entry always matches the longest possible string
单个字符类跟一个 '`+`'， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串
A single character class followed by a '''''' will match one or more characters of that class. This entry always matches the longest possible string
单个字符类跟一个 ``?``， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个
A single character class followed by a ``?`` will match zero or one character of that class. Whenever possible, it will match a
单个字符类跟一个 ``*``， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串
A single character class followed by a ``*`` will match zero or more characters of that class. This entry always matches the longest possible string
单个字符类跟一个 ``+``， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串
A single character class followed by a `````` will match one or more characters of that class. This entry always matches the longest possible string
单个字符类匹配该类别中任意单个字符
A single character class matches any single character in that class
当 `funcname` 为 "`*`"， 它仅仅连接该库，让库中的符号都导出给其它动态链接库使用。 否则，它查找库中的函数 `funcname` ，以 C 函数的形式返回这个函数。 因此，`funcname` 必须遵循原型 [`lua_CFunction`](#lua_CFunction) （参见
When `funcname` is "`*`", it only connects to the library and allows the symbols in the library to be exported to other dynamic link libraries. Otherwise, it looks for the function `funcname` in the library and returns it as a C function. Therefore, `funcname` must follow the prototype [`lua_CFunction](#lua_CFunction) (cf.
当 `locale` 是一个空串， 当前区域被设置为一个在实现中定义好的本地区域。 当 `locale` 为字符串 "`C`"， 当前区域被设置为标准 C 区域。
When `locale` is an empty string, the current region is set to a local region defined in the implementation. When `locale` is the string "`C`", the current area is set to the standard C area.
当 `n` 为零时， 这个函数将创建出一个 _轻量 C 函数_， 它就是一个指向 C 函数的指针。 这种情况下，不可能抛出内存错误。
When `n` is zero, this function creates a lightweight C function, which is a pointer to a C function. In this case, it is not possible to throw a memory error.
当 `nsize` 不是零时， 分配器必须和 `realloc` 行为类似。 如果分配器无法完成请求，返回 `NULL`。 Lua 假定在 `osize >= nsize` 成立的条件下， 分配器绝不会失败。
When `nsize` is not zero, the allocator must behave like `realloc. If the allocator cannot complete the request, it returns `NULL `. Lua assumes that the allocator will never fail if `osize >= nsize` holds.
当 `nsize` 是零时， 分配器必须和 `free` 行为类似并返回
When `nsize` is zero, the allocator must behave like `free` and return
当 `seek` 成功时，返回最终从文件开头计算起的文件的位置。 当 `seek` 失败时，返回 **nil** 加上一个错误描述字符串。
When `seek` succeeds, returns the position of the file finally calculated from the beginning of the file. When `seek` fails, return **nil** plus an error description string.
当 C 函数被创建出来， 我们有可能会把一些值关联在一起， 也就是创建一个 _C 闭包_ （参见 [`lua_pushcclosure`](#lua_pushcclosure)）； 这些被关联起来的值被叫做 _上值_ ， 它们可以在函数被调用的时候访问的到。
When a C function is created, it is possible to associate some values together, I .e. create a_C closure_(see [lua_pushcclosure](#lua_pushcclosure)); these associated values are called_upper values_, and they can be accessed when the function is called.
当 C 函数调用了 [`lua_yieldk`](#lua_yieldk)， 当前运行的协程会挂起， 启动这个线程的 [`lua_resume`](#lua_resume) 调用返回。 参数 `nresults` 指栈上需返回给 [`lua_resume`](#lua_resume) 的返回值的个数。
When the C function calls [`lua_yieldk`](#lua_yieldk), the currently running coroutine will be suspended, and the [`lua_resume`](#lua_resume) call that started this thread will return. The parameter `nresults` is the number of values returned to [lua_resume](#lua_resume) on the stack.
当 Lua 加载一个代码块，`_ENV` 这个上值的默认值就是这个全局环境 （参见 [`load`](#pdf-load)）。 因此，在默认情况下，Lua 代码中提及的自由名字都指的全局环境中的相关项 （因此，它们也被称为 _全局变量_ ）。 此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。 你可以用 [`load`](#pdf-load) （或 [`loadfile`](#pdf-loadfile)）加载代码块，并赋予它们不同的环境。 （在 C 里，当你加载一个代码块后，可以通过改变它的第一个上值来改变它的环境
When Lua loads a block of code, the default value of `_ENV` is the global environment (see [`load`](#pdf-load)). Therefore, by default, the free names mentioned in Lua code refer to the relevant items in the global environment (therefore, they are also called_global variables_). In addition, all standard libraries are loaded into the global environment, and some functions also operate on this environment. You can load blocks of code with [`load`](#pdf-load) (or [`loadfile`](#pdf-loadfile)) and give them different environments. (In C, when you load a block of code, you can change its environment by changing its first upper value.
当 Lua 运行在一个钩子内部时， 它将屏蔽掉其它对钩子的调用。 也就是说，如果一个钩子函数内再调回 Lua 来执行一个函数或是一个代码块 ， 这个执行操作不会触发任何的钩子。
When Lua runs inside a hook, it masks other calls to the hook. In other words, if a hook function is called back to Lua to execute a function or a block of code, the execution operation will not trigger any hooks.
当 message 是一个字符串时，通常 `error` 会把一些有关出错位置的信息附加在消息的前头。 `level` 参数指明了怎样获得出错位置。 对于 level 1 （默认值），出错位置指 `error` 函数调用的位置。 Level 2 将出错位置指向调用 `error`的函数的函数；以此类推。 传入 level 0 可以避免在消息前添加出错位置信息。
When the message is a string, `error` usually prepends some information about where the error occurred. The `level` parameter indicates how to obtain the error location. For level 1 (the default), the error location refers to the location of the `error` function call. Level 2 points the error location to the function calling the function of `error`; and so on. Pass-in level 0 to avoid adding error location information before the message.
当把一个整数转换为浮点数时， 若整数值恰好可以表示为一个浮点数，那就取那个浮点数。 否则，转换会取最接近的较大值或较小值来表示这个数。 这种转换是不会失败的。
When converting an integer to a floating-point number, if the integer value happens to be represented as a floating-point number, then take that floating-point number. Otherwise, the conversion takes the nearest larger or smaller value to represent the number. This conversion will not fail.
当不传参数时，返回当前时刻。 如果传入一张表，就返回由这张表表示的时刻。 这张表必须包含域 `year`，`month`，及 `day`； 可以包含有　`hour` （默认为 12 ）， `min` （默认为 0）， `sec` （默认为 0），以及 `isdst` （默认为 **nil**）。 关于这些域的详细描述，参见 [`os.date`](#pdf-os.date) 函数。
When the parameter is not passed, the current time is returned. If a table is passed in, the time represented by this table is returned. The table must contain the fields `year`,`month`, and `day`; it can contain `hour` (default 12 ), `min` (default 0), `sec` (default 0), and `isdst` (default **nil**). For a detailed description of these fields, see the [`OS. date`](#pdf-os.date) function.
当不带参数调用时， 返回一个 _\[0,1)_ 区间内一致分布的浮点伪随机数。 当以两个整数 `m` 与 `n` 调用时， `math.random` 返回一个 _\[m, n\]_ 区间 内一致分布的整数伪随机数。 （值 _n-m_ 不能是负数，且必须在 Lua 整数的表示范围内。） 调用 `math.random(n)` 等价于
When called without arguments, returns a uniformly distributed floating-point pseudo-random number in the interval_\[0,1). When called with two integers `m` and `n`, `math.random` returns a uniformly distributed integer pseudo-random number in the interval_\[m, n\]. (The value_n-m_cannot be negative and must be within the representation of a Lua integer.) Calling `math.random(n)`is equivalent
当操作需要数字时，Lua 还会把字符串转换为数字。
Lua also converts the string to a number when the operation requires a number.
当传入 `base` 调用它时， `e` 必须是一个以该进制表示的整数字符串。 进制可以是 2 到 36 （包含 2 和 36）之间的任何整数。 大于 10 进制时，字母 '`A`' （大小写均可）表示 10 ， '`B`' 表示 11，依次到 '`Z`' 表示 35 。 如果字符串 `e` 不是该进制下的合法数字， 函数返回
When `base` is passed in to call it, `e` must be an integer string represented in that base. The base can be any integer between 2 and 36, inclusive. When greater than 10, the letter ``A`` (both upper and lower case) means 10 , ``B`` means 11, and ``Z`` means 35. If the string `e` is not a legal number in this base, the function returns
当创建了一个 C 函数后， 你可以给它关联一些值， 这就是在创建一个 C 闭包（参见 [§4.4](#4.4)）； 接下来无论函数何时被调用，这些值都可以被这个函数访问到。 为了将一些值关联到一个 C 函数上， 首先这些值需要先被压入堆栈（如果有多个值，第一个先压）。 接下来调用 [`lua_pushcclosure`](#lua_pushcclosure) 来创建出闭包并把这个 C 函数压到栈上。 参数 `n` 告之函数有多少个值需要关联到函数上。 [`lua_pushcclosure`](#lua_pushcclosure) 也会把这些值从栈上弹出。
When you create a C function, you can associate some values with it, which is creating a C closure (see [§ 4.4](#4.4)); these values can then be accessed by the function whenever the function is called. In order to associate some values to a C function, first these values need to be pushed onto the stack (if there are multiple values, the first one is pushed first). Next call [lua_pushcclosure](#lua_pushcclosure) to create the closure and push the C function onto the stack. The parameter `n` indicates how many values the function has to associate with the function. [lua_pushcclosure](#lua_pushcclosure) will also pop these values off the stack.
当第一个参数为 **nil** 时， 此函数仅返回当前区域指定分类的名字。
When the first parameter is **nil**, this function returns only the name of the specified category in the current region.
当给定索引的值是 **nil** 时，返回 1 ，否则返回
Returns 1 when the value of the given index is **nil**, otherwise
当给定索引的值是一个 C 函数时，返回 1 ，否则返回
Returns 1 when the value of the given index is a C function, otherwise
当给定索引的值是一个布尔量时，返回 1 ，否则返回
Returns 1 when the value of the given index is a boolean, otherwise
当给定索引的值是一个函数（ C 或 Lua 函数均可）时，返回 1 ，否则返回
Returns 1 when the value of the given index is a function (either a C or Lua function), otherwise it returns
当给定索引的值是一个轻量用户数据时，返回 1 ，否则返回
Returns 1 when the value of the given index is a lightweight user data, otherwise
当给定索引的值是一个数字，或是一个可转换为数字的字符串时，返回 1 ，否则返回
Returns 1 when the value of the given index is a number or a string that can be converted to a number, otherwise
当给定索引的值是一个用户数据（无论是完全的还是轻量的）时， 返回 1 ，否则返回
Returns 1 when the value of the given index is a user data (whether full or lightweight), otherwise
当给定索引的值是一个整数 （其值是一个数字，且内部以整数储存）， 时，返回 1 ，否则返回
Returns 1 when the value of the given index is an integer (its value is a number and is stored internally as an integer), otherwise it returns
当给定索引的值是一个字符串或是一个数字 （数字总能转换成字符串）时，返回 1 ，否则返回
Returns 1 when the value of the given index is a string or a number (a number can always be converted to a string), otherwise
当给定索引的值是一条线程时，返回 1 ，否则返回
Returns 1 when the value of the given index is a thread, otherwise
当给定索引的值是一张表时，返回 1 ，否则返回
Returns 1 when the value of the given index is a table, otherwise
当给定索引无效或其值是 **nil** 时， 返回 1 ，否则返回
Returns 1 when the given index is invalid or its value is **nil**, otherwise
当给定索引无效时，返回 1 ，否则返回
Returns 1 when the given index is invalid, otherwise
当钩子被调用时， 第一个参数是触发这次调用的事件： `"call"` （或 `"tail call"`）， `"return"`， `"line"`， `"count"`。 对于行事件， 钩子的第二个参数是新的行号。 在钩子内，你可以调用 `getinfo` ，指定第 2 层， 来获得正在运行的函数的详细信息 （0 层指 `getinfo` 函数， 1 层指钩子函数
When the hook is called, the first parameter is the event that triggered the call: `"call"` (or `"tail call"`), `"return"`, `"line"`, `"count"`. For row events, the second argument to the hook is the new row number. Within the hook, you can call` getinfo` and specify layer 2 to get the details of the running function (layer 0 refers to` getinfo` function and layer 1 refers to hook function
当关闭用 [`io.popen`](#pdf-io.popen) 创建出来的文件句柄时， [`file:close`](#pdf-file:close) 返回 [`os.execute`](#pdf-os.execute) 会返回的一样的值。
When closing a file handle created with [`io. pop`](#pdf-io.popen), [`file:close`](#pdf-file:close) returns the same value that [`OS. execute`](#pdf-os.execute) would return.
当脚本中出现了未保护的错误， 解释器向标准错误流报告错误。 如果错误对象并非一个字符串，但是却有元方法 `__tostring` 的话， 解释器会调用这个元方法生成最终的消息。 否则，解释器将错误对象转换为一个字符串，并把栈回溯信息加在前面。
When an unprotected error occurs in a script, the interpreter reports the error to the standard error stream. If the error object is not a string, but there is a meta method `__tostring`, the interpreter will call this meta method to generate the final message. Otherwise, the interpreter converts the error object to a string and prepends the stack backtrace information.
当你创建了一个新的 Lua 状态机， 其中的注册表内就预定义好了几个值。 这些预定义值可以用整数索引到， 这些整数以常数形式定义在 `lua.h` 中。 有下列常数
When you create a new Lua state machine, several values are predefined in the registry. These predefined values can be indexed to by integers, which are defined in the form of constants in `lua.h. have the following constants
当你调用一个 Lua 函数却没有指定要接收多少个返回值时 （参见 [`lua_call`](#lua_call)）， Lua 可以保证栈一定有足够的空间来接收所有的返回值， 但不保证此外留有额外的空间。 因此，在做了一次这样的调用后，如果你需要继续压栈， 则需要使用
When you call a Lua function without specifying how many return values to receive (see [lua_call](#lua_call)), Lua guarantees that there will be enough space on the stack to receive all the return values, but there is no guarantee that there will be extra space. Therefore, after making such a call, if you need to continue to push the stack, you need to use
当你关闭一个状态机（参见 [`lua_close`](#lua_close)）， Lua 将调用所有被标记了需要触发终结器对象的终结过程， 其次序为标记次序的逆序。 在这个过程中，任何终结器再次标记对象的行为都不会生效。
When you close a state machine (see [`lua_close`](#lua_close)), Lua will call all the finalization procedures marked as needing to trigger the finalizer object, in the reverse order of the marked order. Any act of the finalizer marking the object again does not take effect during this process.
当你使用 Lua API 时， 就有责任保证做恰当的调用。 特别需要注意的是， _你有责任控制不要堆栈溢出_。 你可以使用 [`lua_checkstack`](#lua_checkstack) 这个函数来扩大可用堆栈的尺寸。
When you use the Lua API, you are responsible for making the appropriate calls. In particular, it is your responsibility to control the stack overflow_. You can use the [lua_checkstack](#lua_checkstack) function to increase the size of the available stack.
当你运行它，将产生下列输出
When you run it, it produces the following output
当前的解析器总是用第一种结构来解析， 它会将开括号看成函数调用的参数传递开始处。 为了避免这种二义性， 在一条语句以小括号开头时，前面放一个分号是个好习惯
The current parser always uses the first structure to parse, and it will see the open parenthesis as the beginning of the parameter passing of the function call. To avoid this ambiguity, it is a good habit to put a semicolon in front of a statement when it begins with a parenthesis.
当然， Lua 解释器的位置对于你的机器来说可能不一样。 如果 `lua` 在你的 `PATH` 中， 写成
Of course, the location of the Lua interpreter may not be the same for your machine. If `lua` is in your `PATH`, write
当使用隐式文件句柄时， 所有的操作都由表 `io` 提供。 若使用显式文件句柄， [`io.open`](#pdf-io.open) 会返回一个文件句柄，且所有的操作都由该文件句柄的方法来提供。
When implicit file handles are used, all operations are provided by the table `io. If an explicit file handle is used, [`io.open`](#pdf-io.open) returns a file handle, and all operations are provided by the file handle`s methods.
当索引大于活动的局部变量的数量， 返回 `NULL` （无任何压栈
When the index is greater than the number of active local variables, return `NULL` (no stack
当索引大于活动局部变量的数量时，返回 `NULL` （什么也不弹出
When the index is greater than the number of active local variables, return `NULL` (nothing pops up.
当索引大于上值的数量时，返回 `NULL` （什么也不弹出
When the index is greater than the number of upper values, return `NULL` (nothing pops up
当索引号比上值数量大的时候， 返回 `NULL`（而且不会压入任何东西）。 对于 C 函数，所有上值的名字都是空串
Returns `NULL` when the index number is greater than the number of values above (and does not push anything). For C functions, the names of all upper values are empty strings.
当协程再次被延续时， Lua 调用延续函数 `k` 继续运行被挂起（参见 [§4.7](#4.7)）的 C 函数。 延续函数会从前一个函数中接收到相同的栈， 栈中的 `n` 个返回值被移除而压入了从 [`lua_resume`](#lua_resume) 传入的参数。 此外，延续函数还会收到传给 [`lua_yieldk`](#lua_yieldk) 的参数
When the coroutine is continued again, Lua calls the continuation function `k` to continue running the suspended C function (see [§ 4.7](#4.7)). The continuation function receives the same stack from the previous function, and the `n` return values in the stack are removed and the parameters passed in from [lua_resume](#lua_resume) are pushed. In addition, the continuation function receives an argument passed to [lua_yieldk](#lua_yieldk)
当一个被标记的对象成为了垃圾后， 垃圾收集器并不会立刻回收它。 取而代之的是，Lua 会将其置入一个链表。 在收集完成后，Lua 将遍历这个链表。 Lua 会检查每个链表中的对象的 `__gc` 元方法：如果是一个函数，那么就以对象为唯一参数调用它； 否则直接忽略它。
When a marked object becomes garbage, the garbage collector does not immediately recycle it. Instead, Lua puts it into a linked list. After the collection is complete, Lua will traverse the linked list. Lua will check the `__gc` meta-method of each object in the linked list: if it is a function, it will be called with the object as the only parameter; Otherwise, it will be ignored directly.
当一个函数被调用， 如果函数并非一个 _可变参数函数_， 即在形参列表的末尾注明三个点 ('`...`')， 那么实参列表就会被调整到形参列表的长度。 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过 _变长参数表达式_传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表， 看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用， 或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个， 就不会做调整了 （除非这最后一个参数被括号给括了起来
When a function is called, if the function is not a_variable parameter function_, that is, three points (''...'') are noted at the end of the formal parameter list, then the argument list is adjusted to the length of the formal parameter list. The variable-length parameter function does not adjust the argument list; instead, it will put all the extra arguments together and pass them to the function through the variable-length parameter expression, which is still written as three points. The value of this expression is a list of argument values, which looks like a function that can return multiple results. If a variable-length argument expression is used in another expression, or in the middle of another string of expressions, its return value is adjusted to a single value. If this expression is placed at the end of a series of expressions, no adjustment will be made (unless this last argument is enclosed in parentheses
当一个函数被调用， 如果函数并非一个 _可变参数函数_， 即在形参列表的末尾注明三个点 (``...``)， 那么实参列表就会被调整到形参列表的长度。 变长参数函数不会调整实参列表； 取而代之的是，它将把所有额外的参数放在一起通过 _变长参数表达式_传递给函数， 其写法依旧是三个点。 这个表达式的值是一串实参值的列表， 看起来就跟一个可以返回多个结果的函数一样。 如果一个变长参数表达式放在另一个表达式中使用， 或是放在另一串表达式的中间， 那么它的返回值就会被调整为单个值。 若这个表达式放在了一系列表达式的最后一个， 就不会做调整了 （除非这最后一个参数被括号给括了起来
When a function is called, if the function is not a_variable parameter function_, that is, three points (``...``) are noted at the end of the formal parameter list, then the argument list is adjusted to the length of the formal parameter list. The variable-length parameter function does not adjust the argument list; instead, it will put all the extra arguments together and pass them to the function through the variable-length parameter expression, which is still written as three points. The value of this expression is a list of argument values, which looks like a function that can return multiple results. If a variable-length argument expression is used in another expression, or in the middle of another string of expressions, its return value is adjusted to a single value. If this expression is placed at the end of a series of expressions, no adjustment will be made (unless this last argument is enclosed in parentheses
当一个线程处于未提供延续函数的 C 调用中，调用它会抛出一个错误。 从并非用延续方式（例如：主线程）启动的线程中调用它也会这样。
When a thread is in a C call that does not provide a continuation function, calling it will throw an error. Calling it from a thread that is not started with a continuation (for example, the main thread) will do the same.
当用于取得一次函数调用的信息时， 参数 `ar` 必须是一个有效的活动的记录。 这条记录可以是前一次调用 [`lua_getstack`](#lua_getstack) 得到的， 或是一个钩子 （参见 [`lua_Hook`](#lua_Hook) ）得到的参数。
When used to get information about a function call, the parameter `ar` must be a valid active record. This record can be the result of a previous call to [lua_getstack](#lua_getstack), or the result of a hook (see [lua_Hook](#lua_Hook) ).
当在遍历过程中你给表中并不存在的域赋值， `next` 的行为是未定义的。 然而你可以去修改那些已存在的域。 特别指出，你可以清除一些已存在的域。
When you assign a value to a field that does not exist in the table during traversal, the behavior of `next` is undefined. However, you can modify existing fields. In particular, you can clear some existing domains.
到 Lua 5.3 最大的变化是引入了数字的整数子类型。 虽然这个变化不会影响“一般”计算， 但一些计算 （主要是涉及溢出的） 会得到不同的结果。
The biggest change to Lua 5.3 is the introduction of integer subtypes for numbers. Although this change does not affect "general" calculations, some calculations (mainly involving overflow) will get different results.
的版本更替总是会修改一些 C API 并涉及源代码的改变。 例如一些常量的数字值，用宏来实现一些函数。 因此，你不能假设在不同的 Lua 版本间可以做到二进制兼容。 当你使用新版时，一定要将使用了 Lua API 的客户程序重新编译。
A version change always modifies some C API and involves changes to the source code. For example, some constant numeric values, using macros to implement some functions. Therefore, you cannot assume binary compatibility between different versions of Lua. When you use the new version, be sure to recompile the client program that uses the Lua API.
的变更
The change
的返回值可以是
The return value of can be
的默认值是 `"cur"`， `offset` 默认为 0 。 因此，调用 `file:seek()` 可以返回文件当前位置，并不改变它； 调用 `file:seek("set")` 将位置设为文件开头（并返回 0）； 调用 `file:seek("end")` 将位置设到文件末尾，并返回文件大小。
The default value of is `"cur"` and `offset` defaults to 0. Therefore, calling `file:seek()`returns the current location of the file without changing it; calling `file:seek("set")` sets the location to the beginning of the file (and returns 0); calling `file:seek("end") sets the location to the end of the file and returns the file size.
的内部会使用栈， 因此 reader 函数必须永远在每次返回时保留栈的原样。
The stack is used internally, so the reader function must always leave the stack as it is each time it returns.
的完整语法
The full syntax
的无符号版本。
The unsigned version.
的选项名不再用 '`*`' 打头。 但出于兼容性考虑，Lua 会继续忽略掉这个字符。
The option name of is no longer first. However, for compatibility reasons, Lua will continue to ignore this character.
的一个编译单元被称为一个 _代码块_。 从句法构成上讲，一个代码块就是一个语句块。
A compilation unit of is called a_code block_. In terms of syntactic composition, a code block is a statement block.
的值。
The value.
的值必须是下列常量中的一个
The value of must be one of the following constants
的最大值是
The maximum value of is
等价于
equivalent
等价于 [`lua_pushfstring`](#lua_pushfstring) ， 不过是用 `va_list` 接收参数，而不是用可变数量的实际参数。
Equivalent to [`lua_pushfstring`](#lua_pushfstring), but with `va_list` instead of a variable number of actual parameters.
等价于 [`luaL_loadbufferx`](#luaL_loadbufferx)， 其 `mode` 参数等于
Equivalent to [luaL_loadbufferx](#luaL_loadbufferx) with `mode` parameter equal
等价于 [`luaL_loadfilex`](#luaL_loadfilex)， 其 `mode` 参数等于
Equivalent to [luaL_loadfilex](#luaL_loadfilex) with `mode` parameter equal
等价于 [`luaL_prepbuffsize`](#luaL_prepbuffsize)， 其预定义大小为
Equivalent to [`luaL_prepbuffsize](#luaL_prepbuffsize) with a predefined size
等价于 `file:close()`。 不给出 `file` 时将关闭默认输出文件。
Equivalent to `file:close()`. The default output file is closed when `file` is not given.
等价于 `t[i] = v` ， 这里的 `t` 是指给定索引处的表， 而 `v` 是栈顶的值。
Equivalent to`t [I] = v`, where `t` refers to the table at the given index and `v` is the value at the top of the stack.
等价于 `t[k] = v` ， 这里的 `t` 是指给定索引处的表， `k` 是指针 `p` 对应的轻量用户数据。 而 `v` 是栈顶的值。
Equivalent to`t[k] = v`, where `t` refers to the table at the given index and `k` is the lightweight user data corresponding to pointer `p. And `v` is the value at the top of the stack.
等价于调用 [`lua_tointegerx`](#lua_tointegerx)， 其参数 `isnum` 为
is equivalent to calling [`lua_tointegerx](#lua_tointegerx) with parameter `isnum`
等价于调用 [`lua_tolstring`](#lua_tolstring) ， 其参数 `len` 为
Equivalent to calling [lua_tolstring](#lua_tolstring), whose argument `len` is
等价于调用 [`lua_tonumberx`](#lua_tonumberx)， 其参数 `isnum` 为
is equivalent to calling [`lua_tonumberx](#lua_tonumberx) with parameter `isnum`
等价于调用序列
Equivalent to call sequence
等于
Equal
等于）操作。 和 "add" 操作行为类似， 不同的是 Lua 仅在两个值都是表或都是完全用户数据 且它们不是同一个对象时才尝试元方法。 调用的结果总会被转换为布尔量。
equal to) operation. The behavior is similar to the "add" operation, except that Lua only tries meta methods when both values are tables or full user data and they are not the same object. The result of the call is always converted to a boolean.
等于操作 （`==`）先比较操作数的类型。 如果类型不同，结果就是 **false**。 否则，继续比较值。 字符串按一般的方式比较。 数字遵循二元操作的规则： 如果两个操作数都是整数， 它们按整数比较； 否则，它们先转换为浮点数，然后再做比较。
The equals operation (`= =`) compares the type of the operands first. If the types are different, the result is **false * *. Otherwise, continue to compare values. Strings are compared in the usual way. Numbers follow the rules of binary operations: if both operands are integers, they are compared as integers; otherwise, they are first converted to floating-point numbers and then compared.
等于操作不会将字符串转换为数字，反之亦然。 即，`"0"==0` 结果为 **false**， 且 `t[0]` 与 `t["0"]` 指代着表中的不同项。
Equals operations do not convert strings to numbers and vice versa. That is, `"0" = = 0` results in **false**, and`t[0]`and`t["0"]` refer to different items in the table.
第二个查找器用于查找 Lua 库的加载库。 它使用储存在 [`package.path`](#pdf-package.path) 中的路径来做查找工作。 查找过程和函数 [`package.searchpath`](#pdf-package.searchpath) 描述的一致。
The second finder is used to find loaded libraries for Lua libraries. It uses the path stored in [`package.path`](#pdf-package.path) to do the lookup. The search process is consistent with the description of the function [`package.searchpath`](#pdf-package.searchpath).
第二个返回值
Second Return Value
第二行是用于路径中的分割符。默认值是
The second line is the separator used in the path. The default value is
第三个查找器用于查找 C 库的加载库。 它使用储存在 [`package.cpath`](#pdf-package.path) 中的路径来做查找工作。 同样， 查找过程和函数 [`package.searchpath`](#pdf-package.searchpath) 描述的一致。 例如，如果 C 路径是这样一个字符串
The third finder is used to find the loaded library for the C library. It uses the path stored in [`package.cpath`](#pdf-package.path) to do the lookup. Similarly, the lookup process is identical to that described by the function [`package.searchpath`](#pdf-package.searchpath). For example, if the C path is such a string
第三行是用于标记模板替换点的字符串。 默认是
The third line is the string used to mark the template replacement point. The default is
第四个搜索器是　_一体化加载器_。 它从 C 路径中查找指定模块的根名字。 例如，当请求 `a.b.c`　时， 它将查找 `a` 这个 C 库。 如果找得到，它会在里面找子模块的加载函数。 在我们的例子中，就是找　`luaopen_a_b_c`。 利用这个机制，可以把若干 C 子模块打包进单个库。 每个子模块都可以有原本的加载函数名。
The fourth searcher is the_all-in-one loader_. It looks up the root name of the specified module from the C path. For example, when requesting `a. B. c`, it will look for `a` which is the C library. If it can find it, it will find the loading function of the submodule in it. In our case, we are looking for "luaopen_a_ B _c `. Using this mechanism, several C submodules can be packaged into a single library. Each submodule can have an original load function name.
第四行是在 Windows 中将被替换成执行程序所在目录的路径的字符串。 默认是
The fourth line is the string that will be replaced in the Windows with the path of the directory where the executable is located. The default is
第五行是一个记号，该记号之后的所有文本将在构建 `luaopen_` 函数名时被忽略掉。 默认是
The fifth line is a token, and all text after this token will be ignored when constructing the `luaopen_`function name. The default is
第一个查找器就是简单的在 [`package.preload`](#pdf-package.preload) 表中查找加载器。
The first finder is simply a loader in the [`package.preload`](#pdf-package.preload) table.
第一个返回值
First Return Value
第一个键
First Key
第一个形参或是定义的第一个局部变量的索引为 1 ， 然后遵循在代码中定义次序，以次类推。 其中只计算函数当前作用域的活动变量。 负索引指可变参数； -1 指第一个可变参数。 如果该索引处没有变量，函数返回 **nil**。 若指定的层次越界，抛出错误。 （你可以调用 [`debug.getinfo`](#pdf-debug.getinfo) 来检查层次是否合法
The index of the first parameter or the first local variable defined is 1, and then follows the order defined in the code, and so on. where only the active variables of the current scope of the function are evaluated. Negative index refers to the variable parameter; -1 refers to the first variable parameter. If there is no variable at that index, the function returns **nil * *. If the specified level is out of bounds, an error is thrown. (You can call [`debug.getinfo`](#pdf-debug.getinfo) to check if the hierarchy is legal
第一行是目录分割串。 对于 Windows 默认是 '`\`' ，对于其它系统是
The first line is a directory split string. The default is '''' for Windows, and for other systems.
第一行是目录分割串。 对于 Windows 默认是 ``\`` ，对于其它系统是
The first line is a directory split string. The default is ```` for Windows, and for other systems.
典型的遍历方法是这样的
The typical traversal method is like this
典型的用法中，错误处理函数被用来给错误消息加上更多的调试信息， 比如栈跟踪信息。 这些信息在 [`lua_pcall`](#lua_pcall) 返回后， 由于栈已经展开，所以收集不到了。
In typical usage, error handling functions are used to add more debugging information, such as stack trace information, to the error message. After [lua_pcall](#lua_pcall) returns, this information cannot be collected because the stack is already expanded.
调试接口
Debug Interface
调试库
Debug Library
调用 [`coroutine.resume`](#pdf-coroutine.resume) 函数执行一个协程。 第一次调用 [`coroutine.resume`](#pdf-coroutine.resume) 时，第一个参数应传入 [`coroutine.create`](#pdf-coroutine.create) 返回的线程对象，然后协程从其主函数的第一行开始执行。 传递给 [`coroutine.resume`](#pdf-coroutine.resume) 的其他参数将作为协程主函数的参数传入。 协程启动之后，将一直运行到它终止或 _让出
Call the [`coroutine.resume`](#pdf-coroutine.resume) function to execute a coroutine. When calling [`coroutine.resume`](#pdf-coroutine.resume) for the first time, the first parameter should pass in the thread object returned by [`coroutine.create`](#pdf-coroutine.create), and then the coroutine starts execution from the first line of its main function. Additional parameters passed to [`coroutine.resume`](#pdf-coroutine.resume) are passed in as arguments to the main coroutine function. After the coroute is started, it will run until it terminates or gives up.
调用 `io.lines()` （不传文件名） 等价于 `io.input():lines("*l")`； 即，它将按行迭代标准输入文件。 在此情况下，循环结束后它不会关闭文件。
Calling `io.lines()`(without passing a file name) is equivalent to `io.input():lines("* l")`; that is, it will iterate the standard input file by line. In this case, it does not close the file after the loop ends.
调用 `luaL_buffinit(L, &b)` 初始化它。
Call `luaL_buffinit(L, & B) `to initialize it.
调用 ISO C 函数 `exit` 终止宿主程序。 如果 `code` 为 **true**， 返回的状态码是 `EXIT_SUCCESS`； 如果 `code` 为 **false**， 返回的状态码是 `EXIT_FAILURE`； 如果 `code` 是一个数字， 返回的状态码就是这个数字。 `code` 的默认值为
Call the ISO C function `exit` to terminate the host program. If `code` is **true**, the returned status code is EXIT_SUCCESS. If `code` is **false**, the returned status code is EXIT_FAILURE. If `code` is a number, the returned status code is the number. The default value for `code` is
调用函数 [`coroutine.create`](#pdf-coroutine.create) 可创建一个协程。 其唯一的参数是该协程的主函数。 `create` 函数只负责新建一个协程并返回其句柄 （一个 _thread_ 类型的对象）； 而不会启动该协程。
Call the function [`coroutine.create`](#pdf-coroutine.create) to create a coprocess. Its only argument is the main function of the coroutine. The `create` function is only responsible for creating a coroutine and returning its handle (an object of type_thread_).
调用一个函数。
Call a function.
调用一个元方法。
Call a meta method.
调整为 0 个结果
Adjust to 0 results
迭代出字符串 `s` 中所有的字符。 这里的 `p` 是位置（按字节数）而 `c` 是每个字符的编号。 如果处理到一个不合法的字节序列，将抛出一个错误。
Iterate out all the characters in the string`s. Here `p` is the position (in bytes) and `c` is the number of each character. If an illegal sequence of bytes is processed, an error will be thrown.
定义了两个常量： `LUA_MININTEGER` 和 `LUA_MAXINTEGER` 来表示这个类型可以表示的最小和最大值。
Two constants are defined: LUA_MININTEGER and LUA_MAXINTEGER to represent the minimum and maximum values that this type can represent.
独立版
Independent Edition
读模式（默认
Read Mode (Default
读取一个不超过这个数量字节数的字符串。 当在文件末尾时，返回 **nil**。 如果 `number` 为零， 它什么也不读，返回一个空串。 当在文件末尾时，返回
Reads a string that does not exceed this number of bytes. When at the end of the file, returns **nil * *. If `number` is zero, it reads nothing and returns an empty string. When at the end of the file, returns
读取一个数字，根据 Lua 的转换文法，可能返回浮点数或整数。 （数字可以有前置或后置的空格，以及符号。） 只要能构成合法的数字，这个格式总是去读尽量长的串； 如果读出来的前缀无法构成合法的数字 （比如空串，"`0x`" 或 "`3.4e-`"）， 就中止函数运行，返回
Reads a number, depending on Lua`s conversion grammar, may return a floating point number or an integer. (Numbers can have leading or trailing spaces, as well as symbols.) As long as it can form a legal number, this format always reads as long as possible. If the read prefix cannot form a legal number (such as an empty string, "`0x`" or "` 3.4e-`"), the function will be aborted and returned
读取一行并保留行结束标记（如果有的话）， 当在文件末尾时，返回
Reads a line and retains the end-of-line tag (if any), when at the end of the file, returns
读取一行并忽略行结束标记。 当在文件末尾时，返回 **nil** 这是默认格式。
Reads a row and ignores the end-of-line tag. When at the end of the file, returns **nil** which is the default format.
读文件 `file`， 指定的格式决定了要读什么。 对于每种格式，函数返回读出的字符对应的字符串或数字。 若不能以该格式对应读出数据则返回 **nil**。 （对于最后这种情况， 函数不会读出后续的格式。） 当调用时不传格式，它会使用默认格式读下一行（见下面描述
Read the file `file`, the specified format determines what to read. For each format, the function returns the string or number corresponding to the read character. **nil** is returned if the data cannot be read in this format * *. (For this last case, the function does not read the subsequent format.) When called without passing the format, it reads the next line using the default format (see description below.
对齐行为按如下规则工作： 对每个选项，格式化时都会填充一些字节直到数据从一个特定偏移处开始， 这个位置是该选项的大小和最大对齐数中较小的那个数的倍数； 这个较小值必须是 2 个整数次方。 选项 "`c`" 及 "`z`" 不做对齐处理； 选项 "`s`" 对对齐遵循其开头的整数。
Alignment works according to the following rules: for each option, formatting will be filled with some bytes until the data starts at a specific offset, which is a multiple of the smaller of the size and maximum alignment number of the option; This smaller value must be 2 integer powers. Options "`c`" and "`z`" do not do alignment; option "`s`" follows its beginning integer for alignment.
对全局变量 `x` 的操作等价于操作 `_ENV.x`。 由于代码块编译的方式， `_ENV` 永远也不可能是一个全局名字 （参见
The operation on the global variable `x` is equivalent to the operation `_ENV.x`. Because of the way the code block is compiled, `_ENV` can never be a global name (cf.
对全局变量以及表的域的赋值操作的含义可以通过元表来改变。 对 `t[i] = val` 这样的变量索引赋值， 等价于 `settable_event(t,i,val)`。 （关于函数 `settable_event` 的详细说明，参见 [§2.4](#2.4)。 这个函数并没有在 Lua 中定义出来，也不可以被调用。 这里我们列出来，仅仅出于方便解释的目的
The meaning of assignment operations to global variables and fields of the table can be changed by the meta-table. Assigning a variable index such as`t [I] = val` is equivalent to `settable_event(t, I, val)`. (For a detailed description of the function `settable_event, `see [§ 2.4](#2.4). This function is not defined in Lua and cannot be called. We list them here for ease of explanation only.
对全局变量以及表的域之访问的含义可以通过元表来改变。 以索引方式访问一个变量 `t[i]` 等价于 调用 `gettable_event(t,i)`。 （参见 [§2.4](#2.4) ，有一份完整的关于 `gettable_event` 函数的说明。 这个函数并没有在 lua 中定义出来，也不能在 lua 中调用。这里我们把提到它只是方便说明问题
The meaning of access to global variables and the fields of the table can be changed through the meta-table. Indexing a variable`t [I] `is equivalent to calling gettable_event(t, I)`. (See [§ 2.4](#2.4) for a complete description of the gettable_event function. This function is not defined in lua and cannot be called in lua. Here we mention it only for convenience to illustrate the problem.
对一些类型和值的内部表示会在运行时做一些数学转换。 位操作总是将浮点操作数转换成整数。 乘方和浮点除法总是将整数转换为浮点数。 其它数学操作若针对混合操作数 （整数和浮点数）将把整数转换为浮点数； 这一点被称为 _通常规则_。 C API 同样会按需把整数转换为浮点数以及 把浮点数转换为整数。 此外，字符串连接操作除了字符串，也可以接受数字作为参数。
The internal representations of some types and values do some mathematical transformations at run time. Bit operations always convert floating-point operands to integers. Exponentiation and floating-point division always convert integers to floating-point numbers. Other mathematical operations convert integers to floating-point numbers for mixed operands (integers and floating-point numbers); this is known as the usual rule_. The C API also converts integers to floats and floats to integers on demand. In addition, string concatenation operations can also accept numbers as parameters in addition to strings.
对一张表的弱属性的修改仅在下次收集循环才生效。 尤其是当你把表由弱改强，Lua 还是有可能在修改生效前回收表内一些项目。
Modifications to a table's weak attributes take effect only on the next collection cycle. Especially when you change the table from weak to strong, Lua may still recycle some items in the table before the modification takes effect.
对于 call 事件，`event` 可以是 `LUA_HOOKCALL` 这个通常值， 或是 `LUA_HOOKTAILCALL` 表示尾调用； 后一种情况，没有对应的返回事件。
For the call event, `event` can be the usual value for `LUA_HOOKCALL, `or LUA_HOOKTAILCALL for tail call; in the latter case, there is no corresponding return event.
对于第二种情况，`ar` 必须填 `NULL` 。 需要探知的函数必须放在栈顶。 对于这种情况，只有 Lua 函数的形参是可见的 （没有关于还有哪些活动变量的信息） 也不会有任何值压栈。
For the second case, `ar` must be filled with `NULL `. Functions that need to be probed must be placed at the top of the stack. In this case, only the parameters of the Lua function are visible (there is no information about which other active variables are available) and no values are stacked.
对于第一个域，`o`， 指的是该函数会从栈上弹出多少个元素。 第二个域，`p`， 指该函数会将多少个元素压栈。 （所有函数都会在弹出参数后再把结果压栈。） `x|y` 这种形式的域表示该函数根据具体情况可能压入（或弹出） `x` 或 `y` 个元素； 问号 '`?`' 表示 我们无法仅通过参数来了解该函数会弹出/压入多少元素 （比如，数量取决于栈上有些什么）。 第三个域，`x`， 解释了该函数是否会抛出错误： '`-`' 表示该函数绝对不会抛出错误； '`e`' 表示该函数可能抛出错误； '`v`' 表示该函数可能抛出有意义的错误。
For the first field, 'o' refers to how many elements the function will pop from the stack. The second field, 'p', refers to how many elements the function will stack. (All functions will pop the parameters and then push the results on the stack.) The field of the form 'x | y' indicates that the function may push (or pop) 'x' or 'y' elements depending on the situation; the question mark ''?'' indicates that we cannot know how many elements the function will pop/push (for example, the number depends on what is on the stack) just by the argument. The third field, 'x', explains whether the function will throw an error: ''-'' means that the function will never throw an error; ''e'' means that the function may throw an error; ''v'' means that the function may throw a meaningful error.
对于第一个域，`o`， 指的是该函数会从栈上弹出多少个元素。 第二个域，`p`， 指该函数会将多少个元素压栈。 （所有函数都会在弹出参数后再把结果压栈。） `x|y` 这种形式的域表示该函数根据具体情况可能压入（或弹出） `x` 或 `y` 个元素； 问号 ``?`` 表示 我们无法仅通过参数来了解该函数会弹出/压入多少元素 （比如，数量取决于栈上有些什么）。 第三个域，`x`， 解释了该函数是否会抛出错误： ``-`` 表示该函数绝对不会抛出错误； ``e`` 表示该函数可能抛出错误； ``v`` 表示该函数可能抛出有意义的错误。
For the first field, `o` refers to how many elements the function will pop from the stack. The second field, `p`, refers to how many elements the function will stack. (All functions will pop the parameters and then push the results on the stack.) The field of the form `x | y` indicates that the function may push (or pop) `x` or `y` elements depending on the situation; the question mark ``?`` indicates that we cannot know how many elements the function will pop/push (for example, the number depends on what is on the stack) just by the argument. The third field, `x`, explains whether the function will throw an error: ``-`` means that the function will never throw an error; ``e`` means that the function may throw an error; ``v`` means that the function may throw a meaningful error.
对于第一种情况， 参数 `ar` 必须是一个有效的活动的记录。 这条记录可以是前一次调用 [`lua_getstack`](#lua_getstack) 得到的， 或是一个钩子 （参见 [`lua_Hook`](#lua_Hook) ）的参数。 索引 `n` 用于选择要检阅哪个局部变量； 参见 [`debug.getlocal`](#pdf-debug.getlocal) 中关于变量的索引和名字的介绍。
For the first case, the parameter `ar` must be a valid active record. This record can be the result of a previous call to [lua_getstack](#lua_getstack) or an argument to a hook (see [lua_Hook](#lua_Hook) ). The index `n` is used to select which local variable to review; see [`debug.getlocal`](#pdf-debug.getlocal) for the description of variable indexes and names.
对于后两种情况，`size` 以字节数为单位 指定缓冲区大小。 默认会有一个恰当的大小。
For the latter two cases, `size` specifies the buffer size in bytes. There will be an appropriate size by default.
对于那可以接受索引调用的函数， 无效索引被看作包含了一个虚拟类型 `LUA_TNONE` 的值， 这个值的行为和 nil 一致。
For functions that can accept index calls, the invalid index is considered to contain a value of virtual type LUA_TNONE, which behaves the same as nil.
对于那些只是需要栈中的值（例如查询函数） 而不需要指定一个栈位置的函数， 可以用一个可接受的索引去调用它们。 _可接受索引_ 不仅可以是任何包括伪索引在内的有效索引， 还可以是任何超过栈顶但落在为栈分配出来的空间内的正索引。 （注意 0 永远都不是一个可接受索引。） 除非另有说明，API 里的函数都接受可接受索引。
For functions that only need values in the stack (such as query functions) and do not need to specify a stack location, they can be called with an acceptable index. The acceptable index can be not only any valid index including a pseudo index, but also any positive index that exceeds the top of the stack but falls within the space allocated for the stack. (Note that 0 is never an acceptable index.) Unless otherwise noted, functions in the API accept acceptable indexes.
对于全局变量 `x = val` 的赋值等价于 `_ENV.x = val` （参见
The assignment to the global variable `x = val` is equivalent to `_ENV.x = val` (cf.
对于选项 "`!_n_`", "`s_n_`", "`i_n_`", "`I_n_`", `n` 可以是 1 到 16 间的整数。 所有的整数选项都将做溢出检查； [`string.pack`](#pdf-string.pack) 检查提供的值是否能用指定的字长表示； [`string.unpack`](#pdf-string.unpack) 检查读出的值能否置入 Lua 整数中。
For option "`! _n_`", "` s_n_`", "` I_n_`", "` I_n_`", `n` can be an integer between 1 and 16. All integer options will be checked for overflow; [`string.pack`](#pdf-string.pack) checks whether the supplied value can be expressed in the specified word length; [`string.unpack`](#pdf-string.unpack) checks whether the read value can be placed in a Lua integer.
对于一元操作符（取负、求长度、位反）， 元方法调用的时候，第二个参数是个哑元，其值等于第一个参数。 这样处理仅仅是为了简化 Lua 的内部实现 （这样处理可以让所有的操作都和二元操作一致）， 这个行为有可能在将来的版本中移除。 （使用这个额外参数的行为都是不确定的
For unary operators (negative, length, bit inversion), when the meta method is called, the second parameter is a dummy with a value equal to the first parameter. This treatment is only to simplify the internal implementation of Lua (this treatment allows all operations to be consistent with binary operations), and this behavior may be removed in future versions. (The behavior of using this additional parameter is uncertain.
对于用 UTF-8 编码的 Unicode 字符，你可以用 转义符 `\u{_XXX_}` 来表示 （这里必须有一对花括号）， 此处的 _XXX_ 是用 16 进制表示的字符编号。
For Unicode characters encoded in UTF-8, you can use the escape character `\u{_XXX_}` (there must be a pair of curly braces), where_XXX_is the hexadecimal character number.
对于右移和左移，均用零来填补空位。 移动的位数若为负，则向反方向位移； 若移动的位数的绝对值大于等于 整数本身的位数，其结果为零 （所有位都被移出
For both right and left shifts, the gaps are filled with zeros. If the number of bits moved is negative, it will be shifted in the opposite direction; If the absolute value of the number of bits moved is greater than or equal to the number of bits of the integer itself, the result is zero (all bits are moved out
对于整数数学运算的溢出问题， 这些操作采取的策略是按通常遵循的以 2 为补码的数学运算的 _环绕_ 规则。 （换句话说，它们返回其运算的数学结果对 _264_ 取模后的数字
For the overflow problem of integer mathematical operations, the strategy adopted by these operations is to follow the usual_wrap_rule for mathematical operations with 2 as the complement. (In other words, they return the number after the mathematical result of their operation is modulo_264_
对栈顶的两个值（或者一个，比如取反）做一次数学或位操作。 其中，栈顶的那个值是第二个操作数。 它会弹出压入的值，并把结果放在栈顶。 这个函数遵循 Lua 对应的操作符运算规则 （即有可能触发元方法
Do a mathematical or bit operation on the top two values (or one, say, inverted) of the stack. where the value at the top of the stack is the second operand. It pops the pushed value and puts the result on top of the stack. This function follows Lua's corresponding operator arithmetic rules (I. e., it is possible to trigger meta-methods.
对这个函数来说，模板前开始的 '`^`' 不会当成锚点。因为这样会阻止迭代。
For this function, the ``^`` that starts before the template will not be used as an anchor. Because this prevents iteration.
而不是
instead
二元操作符包含有数学运算操作符（参见 [§3.4.1](#3.4.1)）， 位操作符（参见 [§3.4.2](#3.4.2)）， 比较操作符（参见 [§3.4.4](#3.4.4)）， 逻辑操作符（参见 [§3.4.5](#3.4.5)）， 以及连接操作符（参见 [§3.4.6](#3.4.6)）。 一元操作符包括负号（参见 [§3.4.1](#3.4.1)）， 按位非（参见 [§3.4.2](#3.4.2)）， 逻辑非（参见 [§3.4.5](#3.4.5)）， 和取长度操作符（参见
Binary operators include mathematical operation operators (see [§ 3.4.1](#3.4.1)), bit operators (see [§ 3.4.2](#3.4.2)), comparison operators (see [§ 3.4.4](#3.4.4)), logical operators (see [§ 3.4.5](#3.4.5)), and concatenate operators (see [§ 3.4.6](#3.4.6)). The unary operators include the minus sign (see [§ 3.4.1](#3.4.1)), the bitwise NOT (see [§ 3.4.2](#3.4.2)), the logical NOT (see [§ 3.4.5](#3.4.5)), and the take-length operator (see
发起一步增量垃圾收集。
Initiates one-step incremental garbage collection.
发起一次完整的垃圾收集循环。
Initiate a full garbage collection cycle.
返回
Return
返回 _ex_ 的值 （`e` 为自然对数的底
Returns the value of_ex_(`e` is the base of the natural logarithm.
返回 `n` 个字符串 `s` 以字符串 `sep` 为分割符连在一起的字符串。 默认的 `sep` 值为空字符串（即没有分割符）。 如果 `n` 不是正数则返回空串。
Returns a string of `n` strings `s` concatenated with the string `sep` as the delimiter. The default `sep` value is an empty string (I. e. no delimiter). Returns an empty string if `n` is not a positive number.
返回 `s` 的子串， 该子串从 `i` 开始到 `j` 为止； `i` 和 `j` 都可以为负数。 如果不给出 `j` ，就当它是 -1 （和字符串长度相同）。 特别是， 调用 `string.sub(s,1,j)` 可以返回 `s` 的长度为 `j` 的前缀串， 而 `string.sub(s, -i)` 返回长度为 `i` 的后缀串。
Returns a substring of `s`, starting with `I` and ending with `j`; both `I` and `j` can be negative. If `j` is not given, it is assumed to be -1 (the same length as the string). In particular, the call `string.sub(s,1,j)`can return a prefix string of length `j` for `s`, while `string.sub(s, -I)` returns a suffix string of length `I.
返回 `tp` 表示的类型名， 这个 `tp` 必须是 [`lua_type`](#lua_type) 可能返回的值中之一。
Returns the name of the type represented by `tp`, which must be one of the possible values returned by [lua_type](#lua_type).
返回 `x` 除以 `y`，将商向零圆整后的余数
Returns the remainder after dividing `x` by `y` and rounding the quotient to zero
返回 `x` 的反余弦值（用弧度表示
Returns the inverse cosine of `x` (in radians
返回 `x` 的反正弦值（用弧度表示
Returns the arcsine of `x` (in radians
返回 `x` 的绝对值
Returns the absolute value of `x`
返回 `x` 的平方根。 （你也可以使用乘方 `x^0.5` 来计算这个值
Returns the square root of `x. (You can also use the power `x ^ 0.5 `to calculate this value
返回 `x` 的余弦（假定参数是弧度
Returns the cosine of `x` (assuming the argument is radians
返回 `x` 的整数部分和小数部分。 第二个结果一定是浮点数。
Returns the integer and fractional parts of `x. The second result must be a floating point number.
返回 `x` 的正切值（假定参数是弧度
Returns the tangent of `x` (assuming the argument is radian
返回 `x` 的正弦值（假定参数是弧度
Returns the sine of `x` (assuming the argument is radians
返回 `y/x` 的反正切值（用弧度表示）。 它会使用两个参数的符号来找到结果落在哪个象限中。 （即使 `x` 为零时，也可以正确的处理
Returns the arctangent of `y/x` in radians. It uses the sign of the two arguments to find which quadrant the result falls in. (Even if `x` is zero, it can be handled correctly
返回 f() 的所有返回结果
Returns all returned results of f()
返回 Lua 使用的内存总量（以 K 字节为单位
Returns the total amount of memory used by Lua (in K bytes
返回 x, y, 以及 f() 的所有返回值
Returns all values returned by x, y, and f()
返回包含有以二进制方式表示的（一个 _二进制代码块_ ）指定函数的字符串。 之后可以用 [`load`](#pdf-load) 调用这个字符串获得 该函数的副本（但是绑定新的上值）。 如果　`strip` 为真值， 二进制代码块不携带该函数的调试信息 （局部变量名，行号，等等
Returns a string containing the specified function in binary representation (a_binary code block_). You can then call this string with [`load`](#pdf-load) to get a copy of the function (but bind the new upper value). If `strip` is true, the binary code block does not carry debugging information for the function (local variable name, line number, etc.
返回保存在 Lua 内核中储存的版本数字的地址。 当调用时传入一个合法的 [`lua_State`](#lua_State) ， 返回创建该状态机时的版本地址。 如果用 `NULL` 调用， 返回调用者的版本地址。
Returns the address of the version number stored in the Lua kernel. When called, a legal [`lua_State`](#lua_State) is passed in, which returns the address of the version when the state machine was created. If called with `NULL`, return the caller`s version address.
返回编码在 `s` 中的第 `n` 个字符的开始位置（按字节数） （从位置 `i` 处开始统计）。 负 `n` 则取在位置 `i` 前的字符。 当 `n` 是非负数时，默认的 `i` 是 1， 否则默认为 `#s + 1`。 因此，`utf8.offset(s, -n)` 取字符串的倒数第 `n` 个字符的位置。 如果指定的字符不在其中或在结束点之后，函数返回
Returns the starting position (in bytes) of the `n` character encoded in `s` (counted from position `I`). Negative `n` takes the character before position `I. The default `I` is 1 when `n` is non-negative, otherwise it defaults to `#s 1`. Therefore, `utf8.offset(s, -n)`takes the position of the last `n` character of the string. If the specified character is not in it or after the end point, the function returns
返回表示收集器是否在工作的布尔值 （即未被停止
Returns a Boolean value that indicates whether the collector is working (that is, not stopped.
返回不大于 `x` 的最大整数值。
Returns the largest integer value not greater than `x.
返回不定数量参数的格式化版本， 格式化串为第一个参数（必须是一个字符串）。 格式化字符串遵循 ISO C 函数 `sprintf` 的规则。 不同点在于选项 `*`, `h`, `L`, `l`, `n`, `p` 不支持， 另外还增加了一个选项 `q`。 `q` 选项将一个字符串格式化为两个双引号括起，对内部字符做恰当的转义处理的字符串。 该字符串可以安全的被 Lua 解释器读回来。 例如，调用
Returns a formatted version of an indefinite number of arguments, formatted as the first argument (must be a string). The formatted string follows the rules of the ISO C function `sprintf. The difference is that the options `*`, `h`, `L`, `l`, `n`, `p` are not supported, and an option `q` is added `. The `q` option formats a string as a string surrounded by two double quotes, with appropriate escaping of internal characters. This string can be safely read back by the Lua interpreter. For example, calling
返回不小于 `x` 的最小整数值。
Returns the smallest integer value not less than `x.
返回参数中最大的值， 大小由 Lua 操作 `<` 决定
Returns the largest value in the parameter, the size is determined by the Lua operation `<`
返回参数中最小的值， 大小由 Lua 操作 `<` 决定
Returns the smallest value in the parameter, the size is determined by the Lua operation `<`
返回程序使用的按秒计 CPU 时间的近似值。
Returns an approximation of the CPU time in seconds used by the program.
返回从可变参数列表中接收到的所有参数
Returns all parameters received from the variable parameter list
返回当前的钩子函数。
Returns the current hook function.
返回当前的钩子计数。
Returns the current hook count.
返回当前的钩子掩码。
Returns the current hook mask.
返回当前内存使用量除以 1024 的余数。
Returns the remainder of the current memory usage divided by the 1024.
返回当前运行的函数（参见 [§4.4](#4.4)）的第 `i` 个上值的伪索引。
Returns the pseudo-index of the `I` top value of the currently running function (see [§ 4.4](#4.4)).
返回当前正在运行的协程加一个布尔量。 如果当前运行的协程是主线程，其为真。
Returns the current running coroutation plus a boolean. This is true if the currently running coroute is the main thread.
返回第一个可以用读模式打开（并马上关闭该文件）的文件的名字。 如果不存在这样的文件，返回 **nil** 加上错误消息。 （这条错误消息列出了所有尝试打开的文件名
Returns the name of the first file that can be opened in read mode (and closed immediately). If no such file exists, return **nil** plus an error message. (This error message lists all the file names you tried to open.
返回给定 `value` 的元表。 若其没有元表则返回
Returns the meta table for the given `value. Returns if it does not have a meta table
返回给定索引处值的固有“长度”： 对于字符串，它指字符串的长度； 对于表；它指不触发元方法的情况下取长度操作（'`#`'）应得到的值； 对于用户数据，它指为该用户数据分配的内存块的大小； 对于其它值，它为
Returns the inherent "length" of the value at the given index: for strings, it refers to the length of the string; for tables, it refers to the value that the take length operation (''#'') should get without triggering the meta-method; for user data, it refers to the size of the memory block allocated for that user data; for other values, it is
返回给定索引处值的固有“长度”： 对于字符串，它指字符串的长度； 对于表；它指不触发元方法的情况下取长度操作（``#``）应得到的值； 对于用户数据，它指为该用户数据分配的内存块的大小； 对于其它值，它为
Returns the inherent "length" of the value at the given index: for strings, it refers to the length of the string; for tables, it refers to the value that the take length operation (``#``) should get without triggering the meta-method; for user data, it refers to the size of the memory block allocated for that user data; for other values, it is
返回给定索引处值的类型名。
Returns the type name of the value at the given index.
返回给定索引的值的长度。 它等价于 Lua 中的 '`#`' 操作符 （参见 [§3.4.7](#3.4.7)）。 它有可能触发 "length" 事件对应的元方法 （参见 [§2.4](#2.4) ）。 结果压栈。
Returns the length of the value at the given index. It is equivalent to the ``#`` operator in Lua (see [§ 3.4.7](#3.4.7)). It is possible to trigger the meta-method corresponding to the "length" event (see [§ 2.4](#2.4) ). The result is stacked.
返回给定有效索引处值的类型， 当索引无效（或无法访问）时则返回 `LUA_TNONE`。 [`lua_type`](#lua_type) 返回的类型被编码为一些个在 `lua.h` 中定义的常量
Returns the type of the value at the given valid index, or LUA_TNONE when the index is invalid (or inaccessible) `. [`lua_type](#lua_type) The returned type is encoded as some constant defined in `lua.h`
返回给定状态机的内存分配器函数。 如果 `ud` 不是 `NULL` ， Lua 把设置内存分配函数时设置的那个指针置入
Returns the memory allocator function for the given state machine. If `ud` is not `NULL` , Lua puts the pointer set when setting the memory allocation function
返回关联在 `u` 上的 Lua 值。 如果 `u` 并非用户数据，返回
Returns the Lua value associated on `u. If `u` is not user data, return
返回关于一个函数信息的表。 你可以直接提供该函数， 也可以用一个数字 `f` 表示该函数。 数字 `f` 表示运行在指定线程的调用栈对应层次上的函数： 0 层表示当前函数（`getinfo` 自身）； 1 层表示调用 `getinfo` 的函数 （除非是尾调用，这种情况不计入栈）；等等。 如果 `f` 是一个比活动函数数量还大的数字， `getinfo` 返回
Returns a table of information about a function. You can provide the function directly, or you can use a number `f` to represent the function. The number `f` represents the function that runs on the corresponding level of the call stack of the specified thread: level 0 represents the current function (`getinfo` itself); level 1 represents the function that calls `getinfo` (unless it is a tail call, which is not included in the stack); and so on. If `f` is a number larger than the number of active functions, `getinfo` returns
返回进程环境变量 `varname` 的值， 如果该变量未定义，返回
Returns the value of the process environment variable `varname`, if the variable is not defined
返回列表中的元素。 这个函数等价于
Returns the elements in a list. This function is equivalent
返回内部副本的指针。
Returns a pointer to the internal copy.
返回入栈值的类型。
Returns the type of the push value.
返回三个表示线程钩子设置的值： 当前钩子函数，当前钩子掩码，当前钩子计数 （[`debug.sethook`](#pdf-debug.sethook) 设置的那些
Returns three values representing thread hook settings: the current hook function, the current hook mask, and those set by the current hook count ([`debug.sethook`](#pdf-debug.sethook)
返回三个值（迭代函数、表 `t` 以及 0 ）， 如此，以下代码
returns three values (iterated function, table `t`, and 0 ), so the following code
返回收集器是否在运行（即没有停止
Returns whether the collector is running (I. e. not stopped
返回索引 `funcindex` 处的闭包中 编号为 `n` 的上值的一个唯一标识符。 参数 `funcindex` 与 `n` 和 [`lua_getupvalue`](#lua_getupvalue) 中的一样 （参见 [`lua_getupvalue`](#lua_getupvalue) ）。 （但 `n` 不可以大于上值的数量
Returns a unique identifier for the upper value numbered `n` in the closure at index `funcindex. The parameter `funcindex` is the same as in `n` and [lua_getupvalue](#lua_getupvalue) (see [lua_getupvalue](#lua_getupvalue) ). (But `n` cannot be greater than the number of upper values.
返回线程 `L` 的状态。
Returns the status of thread `L.
返回新的状态机。 如果内存分配失败，则返回
Returns the new state machine. Returns if memory allocation fails
返回压入值的类型。
Returns the type of the pushed value.
返回一段大小为 `sz` 的空间地址。 你可以将字符串复制其中以加到缓存 `B` 内 （参见 [`luaL_Buffer`](#luaL_Buffer)）。 将字符串复制其中后，你必须调用 [`luaL_addsize`](#luaL_addsize) 传入字符串的大小，才会真正把它加入缓存。
Returns a space address of size `sz. You can copy the string into the cache `B` (see [luaL_Buffer](#luaL_Buffer)). After copying the string into it, you must call [`luaL_addsize`](#luaL_addsize) to pass in the size of the string before it will actually be added to the cache.
返回一个 Lua 状态机中关联的内存块指针。 程序可以把这块内存用于任何用途；而 Lua 不会使用它。
Returns a pointer to the associated memory block in the Lua state machine. Programs can use this memory for any purpose; Lua won't use it.
返回一个包含日期及时刻的字符串或表。 格式化方法取决于所给字符串
Returns a string or table containing the date and time of day. The formatting method depends on the given string
返回一个打包了（即以二进制形式序列化） `v1`, `v2` 等值的二进制字符串。 字符串 `fmt` 为打包格式（参见
Returns a binary string packed (I. e., serialized in binary form) with the values `v1`, `v2`, etc. The string `fmt` is in packed format (see.
返回一个迭代器函数， 每次调用迭代器时，都从文件中按指定格式读数据。 如果没有指定格式，使用默认值 "`l`" 。 看一个例子
Returns an iterator function that reads data from a file in the specified format each time the iterator is called. If no format is specified, the default value "`l`" is used `". look at an example
返回一个迭代器函数。 每次调用这个函数都会继续以 `pattern` （参见　[§6.4.1](#6.4.1)） 对 `s` 做匹配，并返回所有捕获到的值。 如果 `pattern` 中没有指定捕获，则每次捕获整个
Returns an iterator function. Each call to this function will continue to match `s` with `pattern` (see [§ 6.4.1](#6.4.1)) and return all captured values. If no capture is specified in `pattern`, the entire
返回一个可用于临时文件的文件名字符串。 这个文件在使用前必须显式打开，不再使用时需要显式删除。
Returns a filename string that can be used for a temporary file. This file must be explicitly opened before use and explicitly deleted when no longer in use.
返回一个已对齐指针 指向 Lua 状态机中的字符串。 这个字符串总能保证 （ C 要求的）最后一个字符为零 ('\\0') ， 而且它允许在字符串内包含多个这样的零。
Returns an aligned pointer to a string in the Lua state machine. This string always guarantees that the last character (required by C) is zero ('\0'), and it allows multiple such zeros to be contained within the string.
返回一个指定的函数或函数调用的信息。
Returns information about a specified function or function call.
返回一系列的值，可以让
Returns a series of values that allow
返回以格式 `fmt` （参见 [§6.4.2](#6.4.2)） 打包在字符串 `s` （参见 [`string.pack`](#pdf-string.pack)） 中的值。 选项 `pos`（默认为 1 ）标记了从 `s` 中哪里开始读起。 读完所有的值后，函数返回 `s` 中第一个未读字节的位置。
Returns a value packaged in a string `s` (see [`string.pack`](#pdf-string.pack)) in the format `fmt` (see [§ 6.4.2](#6.4.2)). The option `pos` (default is 1) marks where to start reading from`s. After reading all the values, the function returns the position of the first unread byte in`s.
返回以秒计算的时刻 `t1` 到 `t2` 的差值。 （这里的时刻是由 [`os.time`](#pdf-os.time) 返回的值）。 在 POSIX，Windows，和其它一些系统中，这个值就等于
Returns the difference in seconds from time `t1` to `t2. (Here the time is the value returned by [`OS. time`](#pdf-os.time)). On POSIX,Windows, and some other systems, this value is equal
返回以指定底的 `x` 的对数。 默认的 `base` 是 _e_ （因此此函数返回 `x` 的自然对数
Returns the logarithm of `x` at the specified base. The default `base` is_e_ (so this function returns the natural logarithm of `x`
返回以指定格式用 [`string.pack`](#pdf-string.pack) 打包的字符串的长度。 格式化字符串中不可以有变长选项 '`s`' 或 '`z`' （参见
Returns the length of a string packed with ['string.pack'](#pdf-string.pack) in the specified format. The variable-length options ''s'' or ''z'' are not allowed in the formatted string (see.
返回以指定格式用 [`string.pack`](#pdf-string.pack) 打包的字符串的长度。 格式化字符串中不可以有变长选项 ``s`` 或 ``z`` （参见
Returns the length of a string packed with [`string.pack`](#pdf-string.pack) in the specified format. The variable-length options ``s`` or ``z`` are not allowed in the formatted string (see.
返回用所有参数以键 1,2, 等填充的新表， 并将 "`n`" 这个域设为参数的总数。 注意这张返回的表不一定是一个序列。
Returns a new table populated with all parameters with keys 1,2, etc., and sets the field "`n`" to the total number of parameters. Note that the returned table is not necessarily a sequence.
返回栈顶元素的索引。 因为索引是从 1 开始编号的， 所以这个结果等于栈上的元素个数； 特别指出，0 表示栈为空。
Returns the index of the element at the top of the stack. Because the index is numbered from 1, this result is equal to the number of elements on the stack; specifically, 0 means the stack is empty.
返回值被调整为一个
The return value is adjusted to a
返回值的个数
Number of return values
返回值全部被舍弃
All return values are discarded
返回值是一个含义由你的系统决定的数字。 在 POSIX，Windows，和其它一些系统中， 这个数字统计了从指定时间（"epoch"）开始经历的秒数。 对于另外的系统，其含义未定义， 你只能把 `time` 的返回数字用于 [`os.date`](#pdf-os.date) 和 [`os.difftime`](#pdf-os.difftime) 的参数。
The return value is a number whose meaning is determined by your system. In POSIX,Windows, and some other systems, this number counts the number of seconds that have elapsed since a specified time ("epoch"). For other systems, the meaning is undefined, and you can only use the return number of `time` for the parameters of [`OS. date`](#pdf-os.date) and [` OS. difftime`](#pdf-os.difftime).
返回指定函数第 `n` 个上值的唯一标识符（一个轻量用户数据
Returns the unique identifier of the `n` upper value of the specified function (a lightweight user data
返回注册表（参见
return to the registry (see
返回字符 `s[i]`， `s[i+1]`， ...　，`s[j]` 的内部数字编码。 `i` 的默认值是 1 ； `j` 的默认值是 `i`。 这些索引以函数 [`string.sub`](#pdf-string.sub) 的规则修正。
Returns the internal numeric encoding of the characters `[I]`, `[I 1]`,... ,`[j]. The default value for `I` is 1; the default value for `j` is `I`. These indexes are modified by the rules of the function [`string.sub`](#pdf-string.sub).
返回字符串 `s` 的翻转串。
Returns the flipped string of the string`s.
返回字符串 `s` 中 从位置 `i` 到 `j` 间 （包括两端） UTF-8 字符的个数。 默认的 `i` 为 1 ，默认的 `j` 为 -1 。 如果它找到任何不合法的字节序列， 返回假值加上第一个不合法字节的位置。
Returns the number of UTF-8 characters in the string `s` from position `I` to `j` (both ends inclusive). The default `I` is 1, and the default `j` is -1. If it finds any illegal byte sequence, it returns a false value plus the position of the first illegal byte.
方便起见， 所有针对栈的 API 查询操作都不严格遵循栈的操作规则。 而是可以用一个 _索引_ 来指向栈上的任何元素： 正的索引指的是栈上的绝对位置（从1开始）； 负的索引则指从栈顶开始的偏移量。 展开来说，如果堆栈有 _n_ 个元素， 那么索引 1 表示第一个元素 （也就是最先被压栈的元素） 而索引 _n_ 则指最后一个元素； 索引 -1 也是指最后一个元素 （即栈顶的元素）， 索引 _\-n_ 是指第一个元素。
For convenience, all API query operations on the stack do not strictly follow the stack's operating rules. Instead, you can use an_index_to point to any element on the stack: a positive index refers to the absolute position on the stack (starting at 1); a negative index refers to the offset from the top of the stack. In terms of expansion, if the stack has_n_elements, then index 1 represents the first element (that is, the element that is pushed first) and index_n_refers to the last element; Index -1 also refers to the last element (that is, the element at the top of the stack), and index_\-n_refers to the first element.
方括号被用来对表作索引
Square brackets are used to index tables
分代垃圾收集器没有了。 （它是 Lua 5.2 中的一个试验性特性
The generational garbage collector is gone. (It is an experimental feature in Lua 5.2
否则，返回三个值：[`next`](#pdf-next) 函数， 表 `t`，以及 **nil**。 因此以下代码
Otherwise, three values are returned:[`next`](#pdf-next) function, table `t`, and **nil * *. So the following code
浮点除法
floating point division
浮点数 `HUGE_VAL`， 这个数比任何数字值都大。
Floating-point number HUGE_VAL, this number is greater than any numeric value.
辅助库
auxiliary library
辅助库_ 提供了一些便捷函数，方便在 C 中为 Lua 编程。 基础 API 提供了 C 和 Lua 交互用的主要函数， 而辅助库则为一些常见的任务提供了高阶函数。
The auxiliary library_provides some convenient functions for programming Lua in C. The base API provides the main functions for C and Lua interaction, while the auxiliary libraries provide higher-order functions for some common tasks.
辅助库中的所有函数都基于基础 API 实现。 故而它们并没有提供任何基础 API 实现不了的功能。 虽然如此，使用辅助库可以让你的代码更为健壮。
All functions in the auxiliary library are implemented based on the base API. Therefore, they do not provide any functions that the underlying API cannot implement. Nevertheless, using auxiliary libraries can make your code more robust.
赋值
Assignment
赋值语句首先让所有的表达式完成运算， 之后再做赋值操作。 因此，下面这段代码
The assignment statement first allows all expressions to complete the operation, and then the assignment operation. Therefore, the following code
该函数不会把 Lua 函数弹出堆栈。
This function does not pop Lua functions off the stack.
该宏有可能对其参数做多次取值。
The macro may take multiple values for its parameters.
该语句
The statement
格式 "`l`" 和 "`L`" 只能用于文本文件。
Formats "`l`" and "`L`" can only be used in text files.
格式串是由转换选项构成的序列。 这些转换选项列在后面
A format string is a sequence of conversion options. These conversion options are listed in
给定函数的一个合理的名字。 因为 Lua 中的函数是一等公民， 所以它们没有固定的名字： 一些函数可能是全局复合变量的值， 另一些可能仅仅只是被保存在一张表的某个域中。 `lua_getinfo` 函数会检查函数是怎样被调用的， 以此来找到一个适合的名字。 如果它找不到名字， `name` 就被设置为
Given a reasonable name for the function. Because functions in Lua are first-class citizens, they have no fixed names: some functions may be the values of global compound variables, others may simply be stored in a field in a table. The lua_getinfo function examines how the function was called to find an appropriate name. If it cannot find a name, `name` is set
给定函数正在执行的那一行。 当提供不了行号信息的时候， `currentline` 被设为
The line on which the given function is executing. When line number information is not available, `currentline` is set
给指定表设置元表。 （你不能在 Lua 中改变其它类型值的元表，那些只能在 C 里做。） 如果 `metatable` 是 **nil**， 将指定表的元表移除。 如果原来那张元表有 `"__metatable"` 域，抛出一个错误。
Sets the meta table for the specified table. (You can`t change the meta table for other types of values in Lua, those can only be done in C.) If `metatable` is **nil**, the meta table of the specified table is removed. If the original meta table has `__metatable` field, an error is thrown.
更为通用
More generic
更新模式，所有之前的数据都保留
Update mode, all previous data is retained
更新模式，所有之前的数据都删除
Update mode, all previous data is deleted
钩子函数不能有延续点， 即不能用一个非空的 `k` 调用 [`lua_yieldk`](#lua_yieldk)， [`lua_pcallk`](#lua_pcallk)，或
A hook function cannot have a continuation point, that is, it cannot call [`lua_yieldk`](#lua_yieldk), [`lua_pcallk`](#lua_pcallk) with a non-empty `k`, or
钩子函数可以在满足下列条件时让出： 只有行计数事件可以让出，且不能在让出时传出任何值； 从钩子里让出必须用 [`lua_yield`](#lua_yield) 来结束钩子的运行，且 `nresults` 必须为零。
The hook function can give up when the following conditions are met: only row count events can give up, and no value can be passed out when giving up; To give up from the hook, [`lua_yield](#lua_yield) must be used to end the operation of the hook, and` nresults` must be zero.
钩子可以通过设置 `mask` 为零屏蔽。
Hooks can be masked by setting `mask` to zero.
构造子中赋值的次序未定义。 （次序问题只会对那些键重复时的情况有影响
The order of assignments in the constructor is undefined. (The order problem will only affect the situation when those keys are repeated.
挂起正在调用的协程的执行。 传递给 `yield` 的参数都会转为 `resume` 的额外返回值。
Suspends execution of the calling corouty. Any parameter passed to `yield` is converted to an additional return value of `resume.
关闭 `file`。 注意，文件在句柄被垃圾回收时会自动关闭， 但是多久以后发生，时间不可预期的。
Close `file `. Note that the file is automatically closed when the handle is garbage collected, but how long after that happens is unpredictable.
关于变量索引和名字，参见
For variable indexes and names, see
关于迭代过程中修改被迭代的表的注意事项参见 [`next`](#pdf-next) 函数。
See the [`next`](#pdf-next) function for a note on modifying the table being iterated during the iteration.
关于函数可返回值的数量限制和系统有关。 这个限制一定大于
The limit on the number of values a function can return is system-dependent. This limit must be greater
关于协程的操作作为基础库的一个子库， 被放在一个独立表 `coroutine` 中。 协程的介绍参见
Operations on coroutines are placed in a separate table `coroutine` as a sublibrary of the base library. For the introduction of the association, see
关于语言的构成概念将用常见的扩展 BNF 表达式写出。 也就是这个样子： {_a_} 表示 0 或多个 _a_， \[_a_\] 表示一个可选的 _a_。 可以被分解的非最终符号会这样写 non-terminal ， 关键字会写成这样 **kword**， 而其它不能被分解的最终符号则写成这样 ‘**\=**’ 。 完整的 Lua 语法可以在本手册最后一章 [§9](#9) 找到。
Concepts about the composition of the language will be written in common extended BNF expressions. It looks like this: {_a_} means 0 or more_a_, and \[_a_\] means an optional_a_. Non-final symbols that can be decomposed are written as non-terminal, keywords are written as **kword**, and other final symbols that cannot be decomposed are written as' **\= * * '. The complete Lua syntax can be found in the last chapter of this manual [§ 9](#9).
关于这些选项的细节，参见
For details on these options, see
官方发布版的标准路径也可能随版本变化。
The standard path to the official release may also change depending on the version.
函数 [`lua_dump`](#lua_dump) 有了一个额外的参数 `strip`。 如果想和之前的行为一致，这个值传
The function [lua_dump](#lua_dump) has an extra parameter `strip `. If you want to be consistent with the previous behavior, this value passes
函数的类型。
The type of the function.
函数的上值个数。
The number of upper values of the function.
函数调用
function call
函数调用操作 `func(args)`。 当 Lua 尝试调用一个非函数的值的时候会触发这个事件 （即 `func` 不是一个函数）。 查找 `func` 的元方法， 如果找得到，就调用这个元方法， `func` 作为第一个参数传入，原来调用的参数（`args`）后依次排在后面。
The function calls the operation `func(args)`. This event is triggered when Lua tries to call a value that is not a function (I. e. `func` is not a function). Find the meta-method of` func`, and if you can find it, call this meta-method, `func` is passed in as the first parameter, and the originally called parameter (` args`) is followed by the order.
函数调用和赋值语句都可能以一个小括号打头， 这可能让 Lua 的语法产生歧义。 我们来看看下面的代码片断
Both function calls and assignment statements may be headed with a parenthesis, which may make Lua's syntax ambiguous. Let's take a look at the following code snippet
函数调用和可变参数表达式都可以放在多重返回值中。 如果函数调用被当作一条语句（参见 [§3.3.6](#3.3.6)）， 其返回值列表被调整为零个元素，即抛弃所有的返回值。 如果表达式被用于表达式列表的最后（或是唯一的）一个元素， 那么不会做任何调整（除非表达式被括号括起来）。 在其它情况下， Lua 都会把结果调整为一个元素置入表达式列表中， 即保留第一个结果而忽略之后的所有值，或是在没有结果时， 补单个
Both function calls and variable argument expressions can be placed in multiple return values. If a function call is treated as a statement (see [§ 3.3.6](#3.3.6)), its return value list is adjusted to zero elements, I .e. all return values are discarded. If the expression is used on the last (or only) element of the expression list, no adjustment is made (unless the expression is enclosed in parentheses). In other cases, Lua will adjust the result to an element and place it in the expression list, I .e. keep the first result and ignore all the values after it, or fill in the single when there is no result.
函数调用时， 第一步，prefixexp 和 args 先被求值。 如果 prefixexp 的值的类型是 _function_， 那么这个函数就被用给出的参数调用。 否则 prefixexp 的元方法 "call" 就被调用， 第一个参数是 prefixexp 的值， 接下来的是原来的调用参数 （参见
In the first step of a function call, prefixexp and args are evaluated first. If the type of the prefixexp value is_function_, then the function is called with the given arguments. Otherwise the prefixexp meta-method "call" is called, the first parameter is the prefixexp value, followed by the original call parameter (cf.
函数调用语句
function call statement
函数定义
Function Definition
函数定义的语法如下
The syntax for a function definition is as follows
函数定义结束处的行号。
The line number at the end of the function definition.
函数定义开始处的行号。
The line number at which the function definition begins.
函数固定形参个数 （对于 C 函数永远是
The number of function fixed parameters (for C functions will always be
函数和类型
Functions and Types
函数会返回下列常数 （定义在 `lua.h` 内）中的一个
function returns one of the following constants (defined in `lua.h`)
函数将返回压入值的类型。
function returns the type of the pushed value.
函数使用一个用户提供的 `reader` 函数来读取代码块（参见 [`lua_Reader`](#lua_Reader) ）。 `data` 参数会被传入 `reader` 函数。
function uses a user-supplied `reader` function to read a block of code (see [lua_Reader](#lua_Reader) ). The `data` parameter is passed into the `reader` function.
函数以错误消息处理器（参见 [§2.3](#2.3)）的方式运行； 错误消息在栈顶。 不同的是，它不保证栈空间。 做任何压栈操作前，panic 函数都必须先检查是否有足够的空间 （参见
The function operates as an error message handler (see [§ 2.3](#2.3)); the error message is at the top of the stack. The difference is that it does not guarantee stack space. Before doing any stack pressing, the panic function must first check whether there is enough space (see
和 [`load`](#pdf-load) 类似， 不过是从文件 `filename` 或标准输入（如果文件名未提供）中获取代码块。
Similar to [`load`](#pdf-load), but gets the code block from the file `filename` or standard input (if a file name is not provided).
和 [`lua_load`](#lua_load) 一样，这个函数仅加载代码块不运行。
Like [lua_load](#lua_load), this function only loads blocks of code and does not run.
和 `nresults` 的含义与 [`lua_call`](#lua_call) 中的相同。 如果在调用过程中没有发生错误， [`lua_pcall`](#lua_pcall) 的行为和 [`lua_call`](#lua_call) 完全一致。 但是，如果有错误发生的话， [`lua_pcall`](#lua_pcall) 会捕获它， 然后把唯一的值（错误消息）压栈，然后返回错误码。 同 [`lua_call`](#lua_call) 一样， [`lua_pcall`](#lua_pcall) 总是把函数本身和它的参数从栈上移除。
and `nresults` have the same meaning as in [lua_call](#lua_call). If no error occurs during the call, [lua_pcall](#lua_pcall) behaves exactly the same as [lua_call](#lua_call). However, if an error occurs, [lua_pcall](#lua_pcall) will catch it, then push the unique value (error message) on the stack, and return the error code. Like [lua_call](#lua_call), [lua_pcall](#lua_pcall) always removes the function itself and its arguments from the stack.
和索引一样，表中每个域的值也可以是任何类型。 需要特别指出的是：既然函数是一等公民，那么表的域也可以是函数。 这样，表就可以携带 _方法_ 了。 （参见
Like an index, the value of each field in a table can be of any type. It is important to note that since functions are first-class citizens, the fields of the table can also be functions. In this way, the table can carry_method. (See
后面在 [§3.2](#3.2) 以及 [§3.3.3](#3.3.3) 会讨论， 引用一个叫 `var` 的自由名字（指在任何层级都未被声明的名字） 在句法上都被翻译为 `_ENV.var` 。 此外，每个被编译的 Lua 代码块都会有一个外部的局部变量叫 `_ENV` （参见 [§3.3.2](#3.3.2)）， 因此，`_ENV` 这个名字永远都不会成为一个代码块中的自由名字。
As discussed later in [§ 3.2](#3.2) and [§ 3.3.3](#3.3.3), reference to a free name called `var` (referring to a name that is not declared at any level) is syntactically translated as `_ENV.var`. In addition, every compiled Lua code block will have an external local variable called `_ENV` (see [§ 3.3.2](#3.3.2)), so the name`_ENV` will never be a free name in a code block.
忽略环境变量
Ignore environment variables
环变量 `_var_i_` 对于循环来说是一个局部变量； 你不可以在 **for** 循环结束后继续使用。 如果你需要保留这些值，那么就在循环跳出或结束前赋值到别的变量里去。
The loop variable `_var_ I_` is local to the loop; you can`t use it after the loop ends. If you need to keep these values, assign them to other variables before the loop breaks out or ends.
环境与全局环境
Environment and Global Environment
会把 `a[3]` 设置为 20，而不会影响到 `a[4]` 。 这是因为 `a[i]` 中的 `i` 在被赋值为 4 之前就被计算出来了（当时是 3 ）。 简单说 ，这样一行
will set `a[3]`to 20 without affecting `a[4]`. This is because the `I` in `a [I] `is calculated before it is assigned to 4 (it was 3 at the time). Simply put, such a line
会把延续函数看作原函数。 延续函数将接收到和原函数相同的 Lua 栈，其接收到的 lua 状态也和 被调函数若返回后应该有的状态一致。 （例如， [`lua_callk`](#lua_callk) 调用之后， 栈中之前压入的函数和调用参数都被调用产生的返回值所替代。） 这时也有相同的上值。 等到它返回的时候，Lua 会将其看待成原函数的返回去操作。
Will treat the continuation function as the original function. The continuation function will receive the same Lua stack as the original function, and the lua state it receives is also consistent with the state the called function should have after returning. (For example, after the [lua_callk](#lua_callk) call, previously pushed functions and call parameters on the stack are replaced by the return value generated by the call.) It also has the same upper value. When it returns, Lua will treat it as the return of the original function to operate.
会被调整为一个结果
will be adjusted to a result
会产生字符串
will produce the string
会从文件当前位置开始，中不断读出字符。 和 [`io.lines`](#pdf-io.lines) 不同， 这个函数在循环结束后不会关闭文件。
The characters are continuously read out from the current position in the file. Unlike [`io.lines`](#pdf-io.lines), this function does not close the file after the loop ends.
会交换 `x` 和 `y` 的值， 及
would swap the values of `x` and `y`, and
会轮换 `x`，`y`，`z` 的值。
The values of `x`,`y`,`z` will be rotated.
会自动检测代码块是文本的还是二进制的， 然后做对应的加载操作（参见程序 `luac` ）。 字符串 `mode` 的作用和函数 [`load`](#pdf-load) 一致。 它还可以是 `NULL` 等价于字符串
It will automatically detect whether the code block is text or binary, and then do the corresponding loading operation (see program `luac`). The string `mode` is the same as the function [`load`](#pdf-load). It can also be `NULL` equivalent to a string
获取解释器的运行时栈的信息。
Gets information about the interpreter's runtime stack.
获取一个闭包的上值信息。 （对于 Lua 函数，上值是函数需要使用的外部局部变量， 因此这些变量被包含在闭包中。） [`lua_getupvalue`](#lua_getupvalue) 获取第 `n` 个上值， 把这个上值的值压栈， 并且返回它的名字。 `funcindex` 指向闭包在栈上的位置。 （ 因为上值在整个函数中都有效，所以它们没有特别的次序。 因此，它们以字母次序来编号
Gets information about the upper value of a closure. (For Lua functions, the upper values are external local variables that the function needs to use, so these variables are included in the closure.) [`lua_getupvalue`](#lua_getupvalue) gets the `n` top value, stacks the value of this top value, and returns its name. The `funcindex` points to the location of the closure on the stack. (Because the upper values are valid throughout the function, they have no particular order. Therefore, they are numbered in alphabetical order
基本概念
Basic concepts
基础 UTF-8 支持
Basic UTF-8 support
基础函数
basic function
基础库
Base Library
基础库提供了 Lua 核心函数。 如果你不将这个库包含在你的程序中， 你就需要小心检查程序是否需要自己提供其中一些特性的实现。
The base library provides the Lua core functions. If you don't include this library in your program, you need to be careful to check whether the program needs to provide its own implementation of some of these features.
基点为 0 （文件开头
Base point is 0 (beginning of document
基点为当前位置
Base point is current position
基点为文件尾
Base point is end of document
记住，无论何时，若一个操作需要取表的长度， 这张表必须是一个真序列，或是拥有 `__len` 元方法 （参见 [§3.4.7](#3.4.7) ）。 所有的函数都忽略传入参数的那张表中的非数字键。
Remember that whenever an operation needs to take the length of a table, the table must be a true sequence or have a `__len` meta method (see [§ 3.4.7](#3.4.7) ). All functions ignore the non-numeric keys in the table of incoming arguments.
加法
Addition
加载并运行指定的文件。 它是用下列宏定义出来
Loads and runs the specified file. It is defined by the following macro
加载并运行指定的字符串。 它是用下列宏定义出来
Loads and runs the specified string. It is defined by the following macro
加载一段 Lua 代码块，但不运行它。 如果没有错误， `lua_load` 把一个编译好的代码块作为一个 Lua 函数压到栈顶。 否则，压入错误消息。
Loads a block of Lua code, but does not run it. If there are no errors, lua_load push a compiled block of code to the top of the stack as a Lua function. Otherwise, push the error message.
加载一个代码块。
Load a block of code.
加载一个模块。 这个函数首先查找 [`package.loaded`](#pdf-package.loaded) 表， 检测 `modname` 是否被加载过。 如果被加载过，`require` 返回 `package.loaded[modname]` 中保存的值。 否则，它试着为模块寻找 _加载器
Load a module. This function first looks up the [`package.loaded`](#pdf-package.loaded) table to check if the `modname` has been loaded. If loaded, `require` returns the value saved in `package.loaded[modname]. Otherwise, it tries to find the_loader for the module.
假定分配器函数会遵循以下行为
The allocator function is assumed to follow the following behavior
假设正在运行的线程在执行被调函数时让出。 当再次延续这条线程，它希望继续被调函数的运行。 然而，被调函数不可能返回到原函数中。 这是因为之前的让出操作破坏了 C 栈的栈帧。 作为替代品，Lua 调用那个作为被调函数参数给出的 _延续函数_ 。 正如其名，延续函数将延续原函数的任务。
Suppose the running thread gives up when executing the called function. When the thread is continued again, it wants to continue the function being called. However, the called function cannot be returned to the original function. This is because the previous yield operation destroyed the stack frame of the C stack. As an alternative, Lua calls the_continuation function_given as an argument to the called function_. As the name suggests, a continuation function will continue the task of the original function.
减法
subtraction
检查 `cond` 是否为真。 如果不为真，以标准信息形式抛出一个错误 （参见
Check if `cond` is true. If it is not true, an error is thrown in the form of standard information (see
检查 `obj` 是否是合法的文件句柄。 如果 `obj` 它是一个打开的文件句柄，返回字符串 `"file"`。 如果 `obj` 是一个关闭的文件句柄，返回字符串 `"closed file"`。 如果 `obj` 不是文件句柄，返回
Check if `obj` is a valid file handle. If `obj` it is an open file handle, return the string `"file"`. If `obj` is a closed file handle, return the string `"closed file"`. If `obj` is not a file handle, return
检查调用它的内核是否是创建这个 Lua 状态机的内核。 以及调用它的代码是否使用了相同的 Lua 版本。 同时也检查调用它的内核与创建该 Lua 状态机的内核 是否使用了同一片地址空间。
Check that the kernel that called it is the kernel that created the Lua state machine. and whether the code that calls it uses the same Lua version. It also checks whether the kernel that called it and the kernel that created the Lua state machine use the same piece of address space.
检查函数的第 `arg` 个参数的类型是否是 `t`。 参见 [`lua_type`](#lua_type) 查阅类型 `t` 的编码。
Checks if the type of the `arg` parameter of the function is`t `. See [lua_type](#lua_type) to look up the encoding of type`t.
检查函数的第 `arg` 个参数是否是一个 数字，并返回这个数字。
Checks whether the `arg` parameter of the function is a number and returns this number.
检查函数的第 `arg` 个参数是否是一个 整数（或是可以被转换为一个整数） 并以 [`lua_Integer`](#lua_Integer) 类型返回这个整数值。
Checks whether the `arg` parameter of the function is an integer (or can be converted to an integer) and returns the integer value as type [lua_Integer](#lua_Integer).
检查函数的第 `arg` 个参数是否是一个 字符串，并返回该字符串； 如果 `l` 不为 `NULL` ， 将字符串的长度填入
Check whether the `arg` parameter of the function is a string and return the string; If `l` is not `NULL`, fill in the length of the string
检查函数的第 `arg` 个参数是否是一个 字符串，并在数组 `lst` （比如是零结尾的字符串数组） 中查找这个字符串。 返回匹配到的字符串在数组中的索引号。 如果参数不是字符串，或是字符串在数组中匹配不到，都将抛出错误。
Check whether the `arg` parameter of the function is a string and look for this string in the array `lst` (e. g. a zero-terminated string array). Returns the index number of the matched string in the array. If the argument is not a string, or if the string does not match in the array, an error is thrown.
检查函数的第 `arg` 个参数是否是一个 字符串并返回这个字符串。
Checks whether the `arg` parameter of the function is a string and returns the string.
检查函数的第 `arg` 个参数是否是一个类型为 `tname` 的用户数据 （参见 [`luaL_newmetatable`](#luaL_newmetatable) )。 它会返回该用户数据的地址 （参见
Check that the `arg` parameter of the function is user data of type `tname` (see [luaL_newmetatable](#luaL_newmetatable) ). It returns the address of the user data (see.
检查函数在 `arg` 位置是否有任何类型（包括 **nil**）的参数。
Checks if the function has parameters of any type (including **nil**) at the `arg` position.
简介
Introduction
将 `arg` 设为收集器的 _步进倍率_ （参见 [§2.5](#2.5)）。 返回 _步进倍率_ 的前一个值。
Set `arg` to the_step factor_of the collector (see [§ 2.5](#2.5)). Returns the previous value of_step magnification.
将 `arg` 设为收集器的 _间歇率_ （参见 [§2.5](#2.5)）。 返回 _间歇率_ 的前一个值。
Set `arg` to the collector`s_intermittent rate_(see [§ 2.5](#2.5)). Returns the previous value of_intermittent rate.
将 `value` 的元表设为 `table` （可以是 **nil**）。 返回
Set the meta table for `value` to `table` (can be **nil**). Return
将 `value` 设为 `udata` 的关联值。 `udata` 必须是一个完全用户数据。
Set `value` to the associated value of `udata. `udata` must be a full user data.
将把 _name_ 作循环变量。 从第一个 _exp_ 开始起，直到第二个 _exp_ 的值为止， 其步长为第三个 _exp_ 。 更确切的说，一个 **for** 循环看起来是这个样子
_name_will be used as a loop variable. Starting from the first_exp_until the value of the second_exp_, the step size is the third_exp_. More specifically, a **for** loop looks like this
将变量的值压栈，并返回其名字。
Stacks the value of a variable and returns its name.
将参数的类型编码为一个字符串返回。 函数可能的返回值有 "`nil`" （一个字符串，而不是 **nil** 值
Encodes the type of the argument as a string returned. The possible return value of the function is "`nil`" (a string, not a **nil** value
将参数的值逐个写入 `file`。 参数必须是字符串或数字。
Write the values of the parameters to `file` one by one `. Argument must be a string or a number.
将打印出 "`-e`" 。 如果提供了脚本名， 就以 `arg[1]`, ···, `arg[#arg]` 为参数调用脚本。 （和 Lua 所有的代码块一样， 脚本被编译成一个可变参数函数
"`-e`" will be printed out` ". If a script name is provided, the script is called with `arg[1]`,..., `arg[#arg]` as arguments. (Like all Lua code blocks, the script is compiled into a variable parameter function.
将迭代键值对（`1,t[1]`) ，(`2,t[2]`)， ... ，直到第一个空值。
The key-value pairs (`1,t[1]`) ,(`2,t[2]`),... will be iterated until the first null value.
将浮点数转为整数的过程会检查 浮点数能否被准确的表达为一个整数 （即，浮点数是一个整数值且在整数可以表达的区间）。 如果可以，结果就是那个数，否则转换失败。
The process of converting a floating-point number to an integer checks whether the floating-point number can be accurately expressed as an integer (I. e., the floating-point number is an integer value and is within the range that the integer can express). If you can, the result is that number, otherwise the conversion fails.
将给定索引处的 Lua 值转换为带符号的整数类型 [`lua_Integer`](#lua_Integer)。 这个 Lua 值必须是一个整数，或是一个可以被转换为整数 （参见 [§3.4.3](#3.4.3)）的数字或字符串； 否则，`lua_tointegerx` 返回
Converts the Lua value at the given index to the signed integer type [lua_Integer](#lua_Integer). The Lua value must be an integer, or a number or string that can be converted to an integer (see [§ 3.4.3](#3.4.3)); otherwise, lua_tointegerx returns
将给定索引处的 Lua 值转换为一个相应格式的 C 字符串。 结果串不仅会压栈，还会由函数返回。 如果 `len` 不为 `NULL` ， 它还把字符串长度设到 `*len` 中。
Converts the Lua value at the given index to a C string in the appropriate format. The result string will not only be pushed on the stack, but will also be returned by the function. If `len` is not `NULL`, it also sets the string length to `* len.
将给定索引处的用户数据所关联的 Lua 值压栈。
Stacks the Lua value associated with the user data at a given index.
将角 `x` 从弧度转换为角度。
Converts angle `x` from radians to angles.
将角 `x` 从角度转换为弧度。
Converts angle `x` from angles to radians.
将空值压栈。
Stacks a null value.
将名字为 `oldname` 的文件或目录更名为 `newname`。 如果函数失败，返回 **nil** 加一个错误描述串及出错码。
Renames the file or directory named `oldname` to `newname `. If the function fails, return **nil** plus an error description string and error code.
将全局环境压栈。
Stacks the global environment.
将索引 `obj` 处对象的元表中 `e` 域的值压栈。 如果该对象没有元表，或是该元表没有相关域， 此函数什么也不会压栈并返回
Stacks the value of the `e` field in the meta table of the object at index `obj. If the object does not have a meta table, or if the meta table does not have a related field, this function does not stack anything and returns
将先把 `a` 设为 1，然后打印 `a` 的值， 最后运行文件 `script.lua` 并不带参数。 （这里的 `$` 是命令行提示。你的命令行提示可能不一样
You will first set `a` to 1, then print the value of `a`, and finally run the file `script.lua` without parameters. (The `$` here is the command line prompt. Your command line prompt may not be the same
将写入的数据保存到 `file` 中。
Save the written data to `file.
将一个 C 函数压栈。 这个函数接收一个 C 函数指针， 并将一个类型为 `function` 的 Lua 值压栈。 当这个栈顶的值被调用时，将触发对应的 C 函数。
Stacks a C function. This function takes a C function pointer and stacks a Lua value of type `function. When this value at the top of the stack is called, the corresponding C function is triggered.
将一个 Lua 浮点数转换为一个 Lua 整数。 这个宏假设 `n` 有对应的整数值。 如果该值在 Lua 整数可表示范围内， 就将其转换为一个整数赋给 `*p`。 宏的结果是一个布尔量，表示转换是否成功。 （注意、由于圆整关系，这个范围测试不用此宏很难做对
Converts a Lua floating-point number to a Lua integer. This macro assumes that `n` has a corresponding integer value. If the value is in the range of Lua integer representation, it is converted to an integer and assigned to `* p`. The result of the macro is a Boolean quantity that indicates whether the conversion was successful. (Note that due to rounding, this range test is difficult to do correctly without this macro
将一个函数作为钩子函数设入。 字符串 `mask` 以及数字 `count` 决定了钩子将在何时调用。 掩码是由下列字符组合成的字符串，每个字符有其含义
Set a function as a hook function. The string `mask` and the number `count` determine when the hook will be called. A mask is a string of the following characters, each of which has a meaning
将一个可接受的索引 `idx` 转换为绝对索引 （即，一个不依赖栈顶在哪的值
Convert an acceptable index `idx` to an absolute index (that is, a value that does not depend on where the top of the stack is
将一个零结尾的字符串 `s` 转换为一个数字， 将这个数字压栈，并返回字符串的总长度（即长度加一）。 转换的结果可能是整数也可能是浮点数， 这取决于 Lua 的转换语法（参见 [§3.1](#3.1)）。 这个字符串可以有前置和后置的空格以及符号。 如果字符串并非一个有效的数字，返回 0 并不把任何东西压栈。 （注意，这个结果可以当成一个布尔量使用，为真即转换成功
Converts a zero-terminated string `s` to a number, stacks the number, and returns the total length of the string (I. e. length plus one). The result of the conversion may be an integer or a floating point number, depending on Lua`s conversion syntax (see [§ 3.1](#3.1)). This string can have leading and trailing spaces and symbols. If the string is not a valid number, returning 0 does not put anything on the stack. (Note that this result can be used as a Boolean quantity, and if it is true, the conversion is successful.
将一个用于表示 `lvl` 层栈的控制点位置的字符串压栈。 这个字符串遵循下面的格式
A string representing the control point location of the `lvl` layer stack is stacked. This string follows the following format
将一个字符串加载为 Lua 代码块。 这个函数使用 [`lua_load`](#lua_load) 加载一个零结尾的字符串
Loads a string as a Lua code block. This function uses [lua_load](#lua_load) to load a zero-terminated string
将一张表压栈，这张表中的整数索引用于描述函数中哪些行是有效行。 （_有效行_指有实际代码的行，即你可以置入断点的行。 无效行包括空行和只有注释的行
A table is stacked, and the integer index in this table is used to describe which rows in the function are valid rows. (_valid line_refers to the line with the actual code, that is, the line where you can put the breakpoint. Invalid lines include blank lines and lines with comments only
将元素从表 `a1` 移到表 `a2`。 这个函数做了次等价于后面这个多重赋值的等价操作： `a2[t],··· = a1[f],···,a1[e]`。 `a2` 的默认值为 `a1`。 目标区间可以和源区间重叠。 索引 `f` 必须是正数。
Move element from table `a1` to table `a2 `. This function does the equivalent of the following multiple assignment: `a2[t],... = a1[f],..., a1[e]`. The default value for `a2` is `a1 `. The target interval may overlap with the source interval. Index `f` must be a positive number.
将栈 `L1` 的栈回溯信息压栈。 如果 `msg` 不为 `NULL` ，它会附加到栈回溯信息之前。 `level` 参数指明从第几层开始做栈回溯。
Stack backtracking information of stack `L1` is pressed. If `msg` is not `NULL`, it will be appended to the stack before the backtrace information. The `level` parameter indicates the layer from which to do stack backtracking.
将栈空间扩展到 `top + sz` 个元素。 如果扩展不了，则抛出一个错误。 `msg` 是用于错误消息的额外文本 （`NULL` 表示不需要额外文本
Extend stack space to `top sz` elements. If it does not extend, an error is thrown. `msg` is the extra text for the error message (`NULL` means no extra text is needed
将指针 s 指向的零结尾的字符串压栈。Lua 对这个字符串做一个内部副本（或是复用一个副本）， 因此 `s` 处的内存在函数返回后，可以释放掉或是立刻重用于其它用途。
Stacks the zero-terminated string pointed to by pointer s. Lua makes an internal copy of this string (or reuses a copy), so the memory at `s` can be released or reused immediately after the function returns.
将注册表中 `tname` 对应的元表 （参见 [`luaL_newmetatable`](#luaL_newmetatable)）压栈。 如果没有 `tname` 对应的元表，则将 **nil** 压栈并返回假。
Stack the meta table corresponding to `tname` in the registry (see [luaL_newmetatable](#luaL_newmetatable)). If there is no meta table corresponding to `tname`, **nil** is pushed on the stack and false is returned.
将注册表中 `tname` 关联元表 （参见 [`luaL_newmetatable`](#luaL_newmetatable)） 设为栈顶对象的元表。
Set the `tname` associated meta table (see [luaL_newmetatable](#luaL_newmetatable)) in the registry as the meta table of the top-of-stack object.
将字符串 `s` 生成一个副本， 并将其中的所有字符串 `p` 都替换为字符串 `r` 。 将结果串压栈并返回它。
Generate a copy of the string `s` and replace all of the string `p` with the string `r `. Stacks the result string and returns it.
将字符串 `s` 中，所有的（或是在 `n` 给出时的前 `n` 个） `pattern` （参见 [§6.4.1](#6.4.1)）都替换成 `repl` ，并返回其副本。 `repl` 可以是字符串、表、或函数。 `gsub` 还会在第二个返回值返回一共发生了多少次匹配。 `gsub` 这个名字来源于
Replace all (or the first `n` when `n` is given) `pattern` (see [§ 6.4.1](#6.4.1)) in the string `s` with `repl`, and return its copy. `repl` can be a string, a table, or a function. `gsub` will also return the total number of matches in the second return value. The name `gsub` comes from
将最大对齐数设为 `n` （默认遵循本地对齐设置
Set the maximum number of alignments to `n` (default follows local alignment settings
交叉使用类和范围的行为未定义。 因此，像 `[%a-z]` 或 `[a-%%]` 这样的模式串没有意义。
The behavior of cross-using classes and scopes is undefined. Therefore, pattern strings like `[%a-z]` or `[a-%%]` have no meaning.
交换同一个状态机下不同线程中的值。
Swap values in different threads under the same state machine.
接收零或多个整数， 将每个整数转换成对应的 UTF-8 字节序列，并返回这些序列连接到一起的字符串。
Receives zero or more integers, converts each integer into a corresponding sequence of UTF-8 bytes, and returns a string of these sequences concatenated together.
接收零或更多的整数。 返回和参数数量相同长度的字符串。 其中每个字符的内部编码值等于对应的参数值。
Receives zero or more integers. Returns a string of the same length as the number of arguments. The internal encoding value of each character is equal to the corresponding parameter value.
接收任意数量的参数，并将它们的值打印到 `stdout`。 它用 [`tostring`](#pdf-tostring) 函数将每个参数都转换为字符串。 `print` 不用于做格式化输出。仅作为看一下某个值的快捷方式。 多用于调试。 完整的对输出的控制，请使用 [`string.format`](#pdf-string.format) 以及
Receive any number of parameters and print their values to `stdout `. It uses the [`tostring`](#pdf-tostring) function to convert each argument to a string. `print` is not used to do formatted output. Just as a shortcut to look at a value. More for debugging. For complete control of the output, use [`string.format`](#pdf-string.format) and
接收一个字符串，返回其长度。 空串 `""` 的长度为 0 。 内嵌零也统计在内，因此 `"a\000bc\000"` 的长度为
Receives a string and returns its length. The length of the empty string `""` is 0. Embedded zeros are also counted, so the length of `"a\000bc\000"` is
接收一个字符串，将其中的大写字符都转为小写后返回其副本。 其它的字符串不会更改。 对大写字符的定义取决于当前的区域设置。
Receives a string, converts all uppercase characters in it to lowercase, and returns a copy of it. Other strings do not change. The definition of uppercase characters depends on the current locale.
接收一个字符串，将其中的小写字符都转为大写后返回其副本。 其它的字符串不会更改。 对小写字符的定义取决于当前的区域设置。
Receives a string, converts all lowercase characters to uppercase, and returns a copy. Other strings do not change. The definition of lowercase characters depends on the current locale.
接下来是元表可以控制的事件的详细列表。 每个操作都用对应的事件名来区分。 每个事件的键名用加有 '`__`' 前缀的字符串来表示； 例如 "add" 操作的键名为字符串
Next is a detailed list of the events that the meta table can control. Each operation is distinguished by the corresponding event name. The key name of each event is represented by a string prefixed with ``__``; for example, the key name of the "add" operation is a string
接着将字符串复制入这个空间。
Then copy the string into this space.
结果由 **return** 来返回（参见 [§3.3.4](#3.3.4)）。 如果执行到函数末尾依旧没有遇到任何 **return** 语句， 函数就不会返回任何结果。
The result is returned by **return** (see [§ 3.3.4](#3.3.4)). If you execute to the end of the function without encountering any **return** statements, the function will not return any results.
结束对缓存 `B` 的使用，将最终的字符串留在栈顶。
End the use of cache `B`, leaving the final string at the top of the stack.
尽管名字取成这样， 这个事件的元方法其实可以是一个函数也可以是一张表。 如果它是一个函数，则以 `table` 和 `key` 作为参数调用它。 如果它是一张表，最终的结果就是以 `key` 取索引这张表的结果。 （这个索引过程是走常规的流程，而不是直接索引， 所以这次索引有可能引发另一次元方法
Despite the name, the meta-method for this event can actually be a function or a table. If it is a function, it is called with `table` and `key` as arguments. If it is a table, the final result is the result of indexing the table with `key. (This indexing process is a regular process, not a direct index, so this index may trigger another meta-method.
进入一个用户交互模式，运行用户输入的每个字符串。 使用简单的命令以及其它调试设置，用户可以检阅全局变量和局部变量， 改变变量的值，计算一些表达式，等等。 输入一行仅包含 `cont` 的字符串将结束这个函数， 这样调用者就可以继续向下运行。
Enter a user interaction mode and run each string entered by the user. Using simple commands and other debugging settings, users can review global and local variables, change the value of variables, evaluate some expressions, and so on. Entering a line containing only `cont` will end the function so that the caller can continue to run down.
局部变量的可见性规则在 [§3.5](#3.5) 中解释。
The visibility rules for local variables are explained in [§ 3.5](#3.5).
局部变量可以在语句块中任何地方声明。 声明可以包含一个初始化赋值操作
Local variables can be declared anywhere in the statement block. A declaration can contain an initialization assignment operation
局部声明
Local declaration
开始或继续协程 `co` 的运行。 当你第一次延续一个协程，它会从主体函数处开始运行。 `val1`, ... 这些值会以参数形式传入主体函数。 如果该协程被让出，`resume` 会重新启动它； `val1`, ... 这些参数会作为让出点的返回值。
Start or continue the operation of the coroutine `co. When you first continue a coroutine, it will start running from the main function. `val1`,... These values are passed in as arguments to the body function. If the coroutine is relinquished, `resume` will restart it; `val1`,... these parameters will be used as the return value of the relinquished point.
可见性规则
Visibility Rules
可以调用（以及操作）用 Lua 或 C （参见 [§3.4.10](#3.4.10)）编写的函数。 这两种函数有统一类型
Functions written in Lua or C (see [§ 3.4.10](#3.4.10)) can be called (and operated). These two functions have a uniform type
可以接收任何类型，它将其转换为人可阅读的字符串形式。 浮点数总被转换为浮点数的表现形式（小数点形式或是指数形式）。 （如果想完全控制数字如何被转换，可以使用
Can receive any type, it converts it to human-readable string form. Floating-point numbers are always converted to the representation of floating-point numbers (decimal or exponential). (If you want full control over how numbers are converted, you can use
可以用来调用 "方法"。 这是 Lua 支持的一种语法糖。 像 `v:name(args)` 这个样子， 被解释成 `v.name(v,args)`， 这里的 `v` 只会被求值一次。
Can be used to call a "method". This is a syntactic sugar supported by Lua. Like `v:name(args)`, it is interpreted as `v.name(v,args)`, where `v` is evaluated only once.
可以在 Lua 代码中调用 [`error`](#pdf-error) 函数来显式地抛出一个错误。 如果你需要在 Lua 中捕获这些错误， 可以使用 [`pcall`](#pdf-pcall) 或 [`xpcall`](#pdf-xpcall) 在 _保护模式_ 下调用一个函数。
You can call the [`error`](#pdf-error) function in Lua code to explicitly throw an error. If you need to catch these errors in Lua, you can use [`pcall`](#pdf-pcall) or [`xpcall`](#pdf-xpcall) to call a function in_protected mode.
空格）忽略
spaces) ignore
控制结构
control structure
控制结构中的条件表达式可以返回任何值。 **false** 与 **nil** 两者都被认为是假。 所有不同于 **nil** 与 **false** 的其它值都被认为是真 （特别需要注意的是，数字 0 和空字符串也被认为是真
A conditional expression in a control structure can return any value. **false** and **nil** are both considered false. All values other than **nil** and **false** are considered true (in particular, the number 0 and the empty string are also considered true.
控制垃圾收集器。
Controls the garbage collector.
库的变更
Changes to the library
库废弃了。 使用一个外部兼容库很容易， 不过最好直接用对应的位操作符来替换它。 （注意 `bit32` 只能针对 32 位整数运算， 而标准 Lua 中的位操作可以用于 64 位整数
The library is abandoned. It`s easy to use an external compatibility library, but it`s best to replace it directly with the corresponding bit operator. (Note that `bit32` can only be operated on 32-bit integers, while the bit operations in standard Lua can be used on 64-bit integers
库函数 [`type`](#pdf-type) 用于以字符串形式返回给定值的类型。 （参见
The library function [`type`](#pdf-type) is used to return the type of a given value as a string. (See
库提供了两套不同风格的文件处理接口。 第一种风格使用隐式的文件句柄； 它提供设置默认输入文件及默认输出文件的操作， 所有的输入输出操作都针对这些默认文件。 第二种风格使用显式的文件句柄。
The library provides two different styles of file handling interfaces. The first style uses implicit file handles; it provides operations to set default input files and default output files, and all input and output operations are against these default files. The second style uses explicit file handles.
库中所有的 Lua API 函数都不去检查参数是否相容及有效。 然而，你可以在编译 Lua 时加上打开一个宏开关 `LUA_USE_APICHECK` 来改变这个行为。
All Lua API functions in the library do not check whether the parameters are compatible and valid. However, you can change this behavior by adding a macro switch `LUA_USE_APICHECK when compiling Lua.
垃圾收集
Garbage collection
垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。 增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度。 不要把这个值设得小于 100 ， 那样的话收集器就工作的太慢了以至于永远都干不完一个循环。 默认值是 200 ，这表示收集器以内存分配的“两倍”速工作。
The garbage collector step rate controls the rate at which the collector operates relative to the memory allocation rate. Increasing this value not only makes the collector more aggressive, but also increases the length of each incremental step. Don't set this value less than 100, then the collector will work too slowly to finish a cycle forever. The default value is 200, which means that the collector operates at twice the speed of memory allocation.
垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。 增大这个值会减少收集器的积极性。 当这个值比 100 小的时候，收集器在开启新的循环前不会有等待。 设置这个值为 200 就会让收集器等到总内存使用量达到 之前的两倍时才开始新的循环。
The garbage collector intermittency rate controls how long the collector has to wait before starting a new cycle. Increasing this value will reduce the enthusiasm of the collector. When this value is less than 100, the collector will not wait before starting a new loop. Setting this value to 200 will cause the collector to wait until the total memory usage has doubled before starting a new cycle.
垃圾收集元方法
garbage collection meta-method
类似于 [`io.input`](#pdf-io.input)。 不过都针对默认输出文件操作。
Similar to [`io.input`](#pdf-io.input). However, both operate on the default output file.
类似于 [`lua_gettable`](#lua_gettable) ， 但是作一次直接访问（不触发元方法
Similar to [`lua_gettable`](#lua_gettable), but makes a direct access (does not trigger the meta method
类似于 [`lua_settable`](#lua_settable) ， 但是是做一次直接赋值（不触发元方法
Similar to [`lua_settable](#lua_settable), but does a direct assignment (does not trigger the meta method
类型表示了一个独立的执行序列，被用于实现协程 （参见 [§2.6](#2.6)）。 Lua 的线程与操作系统的线程毫无关系。 Lua 为所有的系统，包括那些不支持原生线程的系统，提供了协程支持。
A type represents an independent execution sequence that is used to implement a coroutine (see [§ 2.6](#2.6)). The threads of Lua have nothing to do with the threads of the operating system. Lua provides coroutet support for all systems, including those that do not support native threads.
类型有两种内部表现方式， _整数_ 和 _浮点数_。 对于何时使用哪种内部形式，Lua 有明确的规则， 但它也按需（参见 [§3.4.3](#3.4.3)）作自动转换。 因此，程序员多数情况下可以选择忽略整数与浮点数之间的差异或者假设完全控制每个数字的内部表现方式。 标准 Lua 使用 64 位整数和双精度（64 位）浮点数， 但你也可以把 Lua 编译成使用 32 位整数和单精度（32 位）浮点数。 以 32 位表示数字对小型机器以及嵌入式系统特别合适。 （参见 `luaconf.h` 文件中的宏
There are two internal representations of types,_integer_and_floating point_. Lua has clear rules for when to use which internal form, but it also makes automatic conversions as needed (see [§ 3.4.3](#3.4.3)). Therefore, in most cases, the programmer can choose to ignore the difference between integers and floating-point numbers or assume complete control over the internal representation of each number. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua to use 32-bit integers and single-precision (32-bit) floats. Representation of numbers in 32 bits is particularly suitable for small machines and embedded systems. (See macros in the `luaconf.h` file
类型允许将 C 中的数据保存在 Lua 变量中。 用户数据类型的值是一个内存块， 有两种用户数据： _完全用户数据_ ，指一块由 Lua 管理的内存对应的对象； _轻量用户数据_ ，则指一个简单的 C 指针。 用户数据在 Lua 中除了赋值与相等性判断之外没有其他预定义的操作。 通过使用 _元表_ ，程序员可以给完全用户数据定义一系列的操作 （参见 [§2.4](#2.4)）。 你只能通过 C API 而无法在 Lua 代码中创建或者修改用户数据的值， 这保证了数据仅被宿主程序所控制。
type allows data in C to be stored in Lua variables. The value of the user data type is a memory block, and there are two types of user data:_complete user data_, which refers to an object corresponding to a memory managed by Lua;_lightweight user data_, which refers to a simple C pointer. User data has no predefined operations in Lua other than assignment and equality determination. By using the_metatable_, the programmer can define a series of operations on full user data (see [§ 2.4](#2.4)). You can only create or modify the value of user data in Lua code through the C API, which ensures that the data is only controlled by the host program.
例如,表达式 `debug.getinfo(1,"n")` 返回带有当前函数名字信息的表（如果找的到名字的话）， 表达式 `debug.getinfo(print)` 返回关于 [`print`](#pdf-print) 函数的 包含有所有能提供信息的表。
For example, the expression `debug.getinfo(1,"n")`returns a table with information about the current function name (if the name can be found), and the expression `debug.getinfo(print)` returns a table with information about the [`print`](#pdf-print) function.
例如，如果路径是字符串
For example, if the path is a string
连接）操作。 行为和 "add" 操作类似， 不同的是 Lua 在任何操作数即不是一个字符串 也不是数字（数字总能转换为对应的字符串）的情况下尝试元方法。
connection) operation. The behavior is similar to the "add" operation, except that Lua tries the meta method if any operand is neither a string nor a number (a number can always be converted to the corresponding string).
连接栈顶的 `n` 个值， 然后将这些值出栈，并把结果放在栈顶。 如果 `n` 为 1 ，结果就是那个值放在栈上（即，函数什么都不做）； 如果 `n` 为 0 ，结果是一个空串。 连接依照 Lua 中通常语义完成（参见
Connect the `n` values at the top of the stack, then pull these values off the stack and put the result on the top of the stack. If `n` is 1, the result is that value on the stack (I. e., the function does nothing); if `n` is 0, the result is an empty string. The connection is done according to the usual semantics in Lua (see.
零结尾的字符串
Zero-terminated string
另外定义了一些语法糖简化函数定义的写法
In addition, some syntactic sugar is defined to simplify the writing of function definitions.
另一个语句块
Another statement block
路径是一个包含有一系列以分号分割的 _模板_ 构成的字符串。 对于每个模板，都会用 `name` 替换其中的每个问号（如果有的话）。 且将其中的 `sep` （默认是点）替换为 `rep` （默认是系统的目录分割符）。 然后尝试打开这个文件名。
A path is a string consisting of a series of_templates_separated by semicolon. For each template, each question mark in it (if any) is replaced with `name. And replace the `sep` (default is a dot) with `rep` (default is the directory separator of the system). Then try to open this file name.
逻辑操作符
logical operator
冒号_ 语法可以用来定义 _方法_， 就是说，函数可以有一个隐式的形参 `self`。 因此，如下语句
The colon_syntax can be used to define_method_, that is, a function can have an implicit parameter `self `. Therefore, the following statement
没有错误
No error
没有内置的调试机制。 但是它提供了一组特殊的函数接口以及 _钩子_。 这组接口可用于构建出不同的调试器、性能剖析器、 或是其它需要从解释器获取“内部信息”的工具。
There is no built-in debugging mechanism. But it provides a special set of function interfaces and_hooks_. This set of interfaces can be used to build different debuggers, performance profilers, or other tools that need to get "inside information" from the interpreter.
没有实际的参数，a 和 b 都会收到
Without actual parameters, both a and B receive
没有显式的函数可以用来关闭或销毁掉一个线程。 线程跟其它 Lua 对象一样是垃圾收集的条目之一。
There is no explicit function to close or destroy a thread. A thread is one of the garbage collected items like any other Lua object.
每次找到一个加载器，`require` 都用两个参数调用加载器： `modname` 和一个在获取加载器过程中得到的参数。 （如果通过查找文件得到的加载器，这个额外参数是文件名。） 如果加载器返回非空值， `require` 将这个值赋给 `package.loaded[modname]`。 如果加载器没能返回一个非空值用于赋给 `package.loaded[modname]`， `require` 会在那里设入 **true** 。 无论是什么情况，`require` 都会返回 `package.loaded[modname]` 的最终值。
Each time a loader is found, `require` calls the loader with two parameters: `modname` and a parameter obtained during the acquisition of the loader. (If the loader is obtained by looking for a file, this extra parameter is the file name.) If the loader returns a non-null value, `require` assigns this value to `package.loaded[modname]`. If the loader fails to return a non-null value to assign to `package.loaded[modname]`, `require` will be set to **true** there * *. Whatever the case, `require` returns the final value of `package.loaded[modname].
每当 Lua 从一个函数内返回时，调用钩子
Whenever Lua returns from within a function, the hook is called
每当 Lua 调用一个函数时，调用钩子
Whenever Lua calls a function, the hook is called
每当 Lua 进入新的一行时，调用钩子。
Whenever Lua enters a new line, the hook is called.
每个形如 `[exp1] = exp2` 的域向表中增加新的一项， 其键为 `exp1` 而值为 `exp2`。 形如 `name = exp` 的域等价于 `["name"] = exp`。 最后，形如 `exp` 的域等价于 `[i] = exp` ， 这里的 `i` 是一个从 1 开始不断增长的数字。 这这个格式中的其它域不会破坏其记数。 举个例子
Each field of the shape `[exp1] = exp2` adds a new item to the table with the key `exp1` and the value `exp2`. A field of the shape `name = exp` is equivalent to `["name"] = exp`. Finally, a field of the shape `exp` is equivalent to `[I] = exp`, where` I `is a growing number starting at 1. Other fields in this format do not break their notation. Take an example
每一个新线程都会携带一块内存， 初始化为主线程的这块内存的副本。
Each new thread carries a piece of memory, initialized as a copy of that memory for the main thread.
名字指 [§3.1](#3.1) 中定义的标识符。
The name refers to the identifier defined in [§ 3.1](#3.1).
命令被信号打断； 接下来的数字是打断该命令的信号。
The command is interrupted by a signal; the next number is the signal that interrupts the command.
命令正常结束； 接下来的数字是命令的退出状态码。
The command ends normally; the next number is the exit status code for the command.
模块
Module
模式
Mode
模式_ 指一个模式条目的序列。 在模式最前面加上符号 '`^`' 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 '`$`' 将使匹配过程锚定到字符串的结尾。 如果 '`^`' 和 '`$`' 出现在其它位置，它们均没有特殊含义，只表示自身。
Patters_refers to a sequence of pattern entries. Adding the symbol ``^`` to the front of the pattern will anchor the match from the beginning of the string. Adding the symbol ``$`` at the end of the pattern will anchor the matching process to the end of the string. If ``^`` and ``$`` appear elsewhere, they have no special meaning, only themselves.
模式可以在内部用小括号括起一个子模式； 这些子模式被称为 _捕获物_。 当匹配成功时，由 _捕获物_ 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 `"(a*(.)%w(%s*))"` ， 字符串中匹配到 `"a*(.)%w(%s*)"` 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 "`.`" 匹配到的字符是 2 号捕获物， 匹配到 "`%s*`" 的那部分是 3 号。
A pattern can be internally bracketed with a sub-pattern; these sub-patterns are called_catch_. When the match is successful, the substring in the string matched by the_catch_is saved for future use. The catches are numbered in the order of their opening brackets. For example, for the pattern `"(a *(.)%w(%s *))"`, the part of the string matching `"a *(.)%w(%s *)"` is stored in the first catch (hence the number 1 ); the character matched by "`.`" is the number 2 catch, the part that matches "`%s *`" is number 3.
模式条目
Mode Entry
模式条目_ 可以是
Mode Entries_can be
默认的 `x` 是 1 ， 因此调用 `math.atan(y)` 将返回 `y` 的反正切值。
The default `x` is 1, so calling `math.atan(y)`will return the arctangent of `y.
默认配置下，这块内存的大小为空指针的大小。 不过你可以重新编译 Lua 设定这块内存不同的大小。 （参见 `luaconf.h` 中的
By default, the size of this memory is the size of a null pointer. However you can recompile Lua to set this piece of memory to a different size. (See in `luaconf.h`
默认为 `#list`， 因此调用 `table.remove(l)` 将移除表 `l` 的最后一个元素。
The default is `#list`, so calling `table.remove(l)` will remove the last element of table `l.
默认为 1 ，`j` 默认为
Default is 1 ,`j` defaults
内部使用 C 的 `longjmp` 机制让出一个协程。 因此，如果一个 C 函数 `foo` 调用了一个 API 函数， 而这个 API 函数让出了（直接或间接调用了让出函数）。 由于 `longjmp` 会移除 C 栈的栈帧， Lua 就无法返回到 `foo` 里了。
Internally use C`s `longjmp` mechanism to give up a coroutation. Therefore, if a C function` foo` calls an API function, and the API function gives up (directly or indirectly calls the give-out function). Since `longjmp` removes the stack frame of the C stack, Lua cannot return to `foo.
内存分配错误
Memory allocation error
内存分配错误。对于这种错，Lua 不会调用错误处理函数。
Memory allocation error. For such errors, Lua does not call the error handling function.
能迭代表 `t` 中的所有键值对。
Can represent all key-value pairs in`t.
你不需要为结果分配空间： 其结果是一个 Lua 字符串，由 Lua 来关心其内存分配 （同时通过垃圾收集来释放内存
You don't need to allocate space for the result: the result is a Lua string, and Lua cares about its memory allocation (while freeing up memory through garbage collection.
你可以使用 [`setmetatable`](#pdf-setmetatable) 来替换一张表的元表。在 Lua 中，你不可以改变表以外其它类型的值的元表 （除非你使用调试库（参见[§6.10](#6.10)））； 若想改变这些非表类型的值的元表，请使用
You can use [`setmetatable`](#pdf-setmetatable) to replace the meta table of a table. In Lua, you cannot change the meta table for values of types other than table (unless you use a debugging library (see [§ 6.10](#6.10))); to change the meta table for values of these non-table types, use
你可以使用 **break** 来跳出 **for** 循环。
You can use **break** to get out of the **for** loop.
你可以通过把数字都强制转换为浮点数来消除差异 （在 Lua 5.2 中，所有的数字都是浮点数）。 比如你可以将所有的常量都以 `.0` 结尾， 或是使用 `x = x + 0.0` 来转换一个变量。 （这条建议仅用于偶尔快速解决一些不兼容问题； 这不是一条好的编程准则。 好好写程序的话，你应该在需要使用浮点数的地方用浮点数， 需要整数的地方用整数
You can eliminate the difference by forcing all numbers to float (in Lua 5.2, all numbers are floats). For example, you can make all constants end in `.0`, or use `x = x 0.0 `to convert a variable. (This advice is only used to quickly resolve incompatibilities occasionally; it`s not a good programming guideline. If you write the program well, you should use floating points where you need them and integers where you need them.
你可以通过使用 "eq" 元方法（参见 [§2.4](#2.4)） 来改变 Lua 比较表和用户数据时的方式。
You can change the way Lua compares table and user data by using the "eq" meta-method (see [§ 2.4](#2.4)).
你可以通过在 C 中调用 [`lua_gc`](#lua_gc) 或在 Lua 中调用 [`collectgarbage`](#pdf-collectgarbage) 来改变这俩数字。 这两个函数也可以用来直接控制收集器（例如停止它或重启它
You can change these numbers by calling [`lua_gc`](#lua_gc) in C or [`collectgarbage`](#pdf-collectgarbage) in Lua. These two functions can also be used to directly control the collector (e. g. stop it or restart it
你可以为表设定垃圾收集的元方法， 对于完全用户数据（参见 [§2.4](#2.4)）， 则需要使用 C API 。 该元方法被称为 _终结器_。 终结器允许你配合 Lua 的垃圾收集器做一些额外的资源管理工作 （例如关闭文件、网络或数据库连接，或是释放一些你自己的内存
You can set the meta method for garbage collection for tables, and for full user data (see [§ 2.4](#2.4)), you need to use the C API. The meta-method is called_terminator_. Finalizers allow you to work with Lua's garbage collector to do some additional resource management tasks (such as closing files, network or database connections, or freeing up some of your own memory.
你可以用 [`getmetatable`](#pdf-getmetatable) 函数 来获取任何值的元表。 Lua 使用直接访问的方式从元表中查询元方法（参见[`rawget`](#pdf-rawget)）。 所以，从对象 `o` 中获取事件 `ev` 的元方法等价于下面的代码
You can use the [`getmetatable`](#pdf-getmetatable) function to get the metatable of any value. Lua uses direct access to query meta methods from the meta table (see [`rawget`](#pdf-rawget)). So, the meta-method for getting event `ev` from object `o` is equivalent to the following code
你可以用 **break** 和 **goto** 来退出 **for** 循环。
You can use **break** and **goto** to exit the **for** loop.
你也可以通过 C API 来创建及操作协程： 参见函数 [`lua_newthread`](#lua_newthread)， [`lua_resume`](#lua_resume)， 以及
You can also use the C API to create and manipulate coroutine: see functions [lua_newthread](#lua_newthread), [lua_resume](#lua_resume), and
你只能在状态为 [`LUA_OK`](#pdf-LUA_OK) 的线程中调用函数。 你可以延续一个状态为 [`LUA_OK`](#pdf-LUA_OK) 的线程 （用于开始新协程）或是状态为 [`LUA_YIELD`](#pdf-LUA_YIELD) 的线程 （用于延续协程
You can only call a function on a thread whose status is [`LUA_OK `](#pdf-LUA_ OK). You can continue a thread with a status of [`LUA_OK `](#pdf-LUA_ OK) (for starting a new LUA_YIELD) or a thread with a status of [`LUA_OK`](#pdf-LUA_YIELD) (for continuing a coroutine
排序算法并不稳定； 即当两个元素次序相等时，它们在排序后的相对位置可能会改变。
The sorting algorithm is not stable; that is, when two elements are in equal order, their relative positions after sorting may change.
抛出一个错误。 错误消息的格式由 `fmt` 给出。 后面需提供若干参数， 这些参数遵循 [`lua_pushfstring`](#lua_pushfstring) 中的规则。 如果能获得相关信息，它还会在消息前面加上错误发生时的文件名及行号。
Throws an error. The format of the error message is given by `fmt. Several parameters are provided later, which follow the rules in [lua_pushfstring](#lua_pushfstring). If available, it also prefaces the message with the file name and line number at the time of the error.
抛出一个错误报告调用的 C 函数的第 `arg` 个参数的问题。 它使用下列标准信息并包含了一段 `extramsg` 作为注解
Throws an error reporting the problem with the `arg` parameter of the called C function. It uses the following standard information and includes an `extramsg` as an annotation
匹配模式
Match mode
其它域
Other Domains
强制转换
Forced Conversion
请求模块
Request Module
取到的是全局的那一个
Which one is the global one
取得全局变量
Get global variables
取反操作 **not** 总是返回 **false** 或 **true** 中的一个。 与操作符 **and** 在第一个参数为 **false** 或 **nil** 时 返回这第一个参数； 否则，**and** 返回第二个参数。 或操作符 **or** 在第一个参数不为 **nil** 也不为 **false** 时， 返回这第一个参数，否则返回第二个参数。 **and** 和 **or** 都遵循短路规则； 也就是说，第二个操作数只在需要的时候去求值。 这里有一些例子
The **not** operation always returns one of **false** or **true. with the **and** operator returns the first argument when the first argument is **false** or **nil**; otherwise, **and** returns the second argument. or **or** operator returns the first parameter when the first parameter is neither **nil** nor **false**, otherwise returns the second parameter. **and** and **or** both follow the short-circuit rule; that is, the second operand is evaluated only when needed. Here are some examples
取负
take negative
取负 (一元
take negative (one yuan
取负）操作。 行为和 "add" 操作类似。
negative) operation. The behavior is similar to the "add" operation.
取模
Modulus
取模被定义成除法的余数，其商被圆整到靠近负无穷的一侧（向下取整的除法
The modulus is defined as the remainder of the division, and its quotient is rounded to the side close to negative infinity (the division rounded down
取长度）操作。 如果对象不是字符串，Lua 会尝试它的元方法。 如果有元方法，则调用它并将对象以参数形式传入， 而返回值（被调整为单个）则作为结果。 如果对象是一张表且没有元方法， Lua 使用表的取长度操作（参见 [§3.4.7](#3.4.7)）。 其它情况，均抛出错误。
take the length) operation. If the object is not a string, Lua tries its meta methods. If there is a meta method, it is called and the object is passed in as a parameter, and the return value (adjusted to a single) is the result. If the object is a table and there is no meta-method, Lua uses the table length operation (see [§ 3.4.7](#3.4.7)). In other cases, errors are thrown.
取长度操作符
take length operator
取长度操作符写作一元前置符 `#`。 字符串的长度是它的字节数（就是以一个字符一个字节计算的字符串长度
Take the length operator to write the unary prefix `#`. The length of a string is its number of bytes (that is, the length of the string calculated in one character by one byte.
全局变量
global variable
缺省时，这个就是 `long long`， （通常是一个 64 位以二为补码的整数）， 也可以修改它为 `long` 或 `int` （通常是一个 32 位以二为补码的整数）。 （参见 `luaconf.h` 中的
When missing, this is` long long` (usually a 64-bit integer with two as its complement), or it can be modified to` long` or` int` (usually a 32-bit integer with two as its complement). (See in `luaconf.h`
确保 `t[fname]` 是一张表，并将这张表压栈。 这里的 `t` 指索引 `idx` 处的值。 如果它原来就是一张表，返回真； 否则为它创建一张新表，返回假。
Make sure`t[fname]`is a table and stack that table. Here `t` refers to the value at index `idx. If it was originally a table, return true; otherwise, create a new table for it and return false.
确保堆栈上至少有 `n` 个额外空位。 如果不能把堆栈扩展到相应的尺寸，函数返回假。 失败的原因包括将把栈扩展到比固定最大尺寸还大 （至少是几千个元素）或分配内存失败。 这个函数永远不会缩小堆栈； 如果堆栈已经比需要的大了，那么就保持原样。
Make sure there are at least `n` extra spaces on the stack. If the stack cannot be expanded to the appropriate size, the function returns false. Reasons for failure include expanding the stack to more than the fixed maximum size (at least a few thousand elements) or failing to allocate memory. This function never shrinks the stack; if the stack is already larger than needed, it stays the same.
然后调用 `luaL_add*` 这组函数向其添加字符串片断。
Then call the `luaL_add *` set of functions to add string fragments to it.
然后调用 `luaL_buffinitsize(L, &b, sz)` 预分配 `sz` 大小的空间。
Then call `luaL_buffinitsize(L, & B, sz)`to pre-allocate a space of size `sz.
让 Lua 闭包 `f1` 的第 `n1` 个上值 引用 Lua 闭包 `f2` 的第 `n2` 个上值。
Let the `n1` upper value of Lua closure `f1` refer to the `n2` upper value of Lua closure `f2.
让出协程（线程
give up the coroutine (thread
让宿主程序动态链接 C 库
Let the host program dynamically link the C library.
让索引 `funcindex1` 处的 Lua 闭包的第 `n1` 个上值 引用索引 `funcindex2` 处的 Lua 闭包的第 `n2` 个上值。
Let the `n1` upper value of the Lua closure at index `funcindex1` refer to the `n2` upper value of the Lua closure at index `funcindex2.
任何格式串都假设有一个 "`!1=`" 前缀， 即最大对齐为 1 （无对齐）且采用本地大小端设置。
Any format string assumes a "`! 1 = `"prefix, that is, the maximum alignment is 1 (no alignment) and the local size side setting is used.
任何情况下，模板中没有设定捕获都看成是捕获整个模板。
In any case, no capture set in the template is considered to capture the entire template.
如果 `__len` 元方法没有给出， 表 `t` 的长度只在表是一个 _序列_ 时有定义。 序列指表的正数键集等于 _{1..n}_ ， 其中 _n_ 是一个非负整数。 在这种情况下，_n_ 是表的长度。 注意这样的表
If the `__len` meta-method is not given, the length of table `t` is only defined when the table is a_sequence. A sequence refers to a table with a positive set of keys equal to_{1 .. n }_, where_n_is a non-negative integer. In this case,_n_is the length of the table. Note that such a table
如果 `chunk` 是一个字符串，代码块指这个字符串。 如果 `chunk` 是一个函数， `load` 不断地调用它获取代码块的片断。 每次对 `chunk` 的调用都必须返回一个字符串紧紧连接在上次调用的返回串之后。 当返回空串、**nil**、或是不返回值时，都表示代码块结束。
If `chunk` is a string, the code block refers to this string. If `chunk` is a function, `load` keeps calling it to get snippets of code blocks. Each call to `chunk` must return a string immediately after the return string of the previous call. When an empty string is returned, **nil**, or no value is returned, the code block is over.
如果 `def` 不为 `NULL`， 函数就把 `def` 当作默认值。 默认值在参数 `arg` 不存在，或该参数是 **nil** 时生效。
If `def` is not `NULL`, the function takes `def` as the default value. The default value takes effect when the parameter `arg` does not exist or the parameter is **nil.
如果 `format` 并非 "`*t`"， `date` 以字符串形式返回， 格式化方法遵循 ISO C 函数 `strftime` 的规则。
If `format` is not "`* t`", `date` is returned as a string, and the formatting method follows the rules of the ISO C function `strftime.
如果 `format` 以 '`!`' 打头， 日期以协调世界时格式化。 在这个可选字符项之后， 如果 `format` 为字符串 "`*t`"， `date` 返回有后续域的表： `year` （四位数字），`month` （1–12），`day` （1–31）， `hour` （0–23），`min` （0–59），`sec` （0–61）， `wday` （星期几，星期天为 1 ）， `yday` （当年的第几天）， 以及 `isdst` （夏令时标记，一个布尔量）。 对于最后一个域，如果该信息不提供的话就不存在。
If 'format' ''! ''At the beginning, the date is formatted in Coordinated Universal Time. After this optional character item, if' format' is the string "'* t'", 'date' returns a table with subsequent fields: 'year' (four digits), 'month' (1-12),' day' (1-31), 'hour' (0-23),' min' (0-59), 'sec' (0-61),' wday' (day of the week, Sunday of the year), and 'isdst' (daylight saving time marker, a boolean). For the last field, it does not exist if the information is not provided.
如果 `format` 以 ``!`` 打头， 日期以协调世界时格式化。 在这个可选字符项之后， 如果 `format` 为字符串 "`*t`"， `date` 返回有后续域的表： `year` （四位数字），`month` （1–12），`day` （1–31）， `hour` （0–23），`min` （0–59），`sec` （0–61）， `wday` （星期几，星期天为 1 ）， `yday` （当年的第几天）， 以及 `isdst` （夏令时标记，一个布尔量）。 对于最后一个域，如果该信息不提供的话就不存在。
If `format` ``! ``At the beginning, the date is formatted in Coordinated Universal Time. After this optional character item, if` format` is the string "`* t`", `date` returns a table with subsequent fields: `year` (four digits), `month` (1-12),` day` (1-31), `hour` (0-23),` min` (0-59), `sec` (0-61),` wday` (day of the week, Sunday of the year), and `isdst` (daylight saving time marker, a boolean). For the last field, it does not exist if the information is not provided.
如果 `glb` 为真， 同时也将模块设到全局变量 `modname` 里。
If `glb` is true, the module is also set to the global variable `modname.
如果 `index` 是个数字， 那么返回参数中第 `index` 个之后的部分； 负的数字会从后向前索引（-1 指最后一个参数）。 否则，`index` 必须是字符串 `"#"`， 此时 `select` 返回参数的个数。
If `index` is a number, the part of the argument after the `index` is returned; negative numbers are indexed backwards and forwards (-1 refers to the last argument). Otherwise, `index` must be the string `# "`, where `select` returns the number of arguments.
如果 `isnum` 不是 `NULL`， `*isnum` 会被设为操作是否成功。
If `isnum` is not `NULL`, `* isnum` will be set to whether the operation was successful.
如果 `message` 有，且不是字符串或 **nil**， 函数不做任何处理直接返回 `message`。 否则，它返回调用栈的栈回溯信息。 字符串可选项 `message` 被添加在栈回溯信息的开头。 数字可选项 `level` 指明从栈的哪一层开始回溯 （默认为 1 ，即调用 `traceback` 的那里
If `message` is present and is not a string or **nil**, the function returns `message` without any processing `. Otherwise, it returns stack backtrace information for the call stack. The string option `message` is added at the beginning of the stack backtrace information. The number option`level` indicates from which level of the stack to backtrack (the default is 1, where `traceback` is called
如果 `modname` 不在 [`package.loaded`](#pdf-package.loaded) 中， 则调用函数 `openf` ，并传入字符串 `modname`。 将其返回值置入 `package.loaded[modname]`。 这个行为好似该函数通过 [`require`](#pdf-require) 调用过一样。
If `modname` is not in [`package.loaded`](#pdf-package.loaded), the function `openf` is called and the string `modname` is passed in `. Put its return value into `package.loaded[modname]`. This behaves as if the function had been called through [`require`](#pdf-require).
如果 `msgh` 是 0 ， 返回在栈顶的错误消息就和原始错误消息完全一致。 否则， `msgh` 就被当成是 _错误处理函数_ 在栈上的索引位置。 （在当前的实现里，这个索引不能是伪索引。） 在发生运行时错误时， 这个函数会被调用而参数就是错误消息。 错误处理函数的返回值将被 [`lua_pcall`](#lua_pcall) 作为错误消息返回在堆栈上。
If `msgh` is 0, the error message returned at the top of the stack is exactly the same as the original error message. Otherwise, `msgh` is treated as the index position of the_error handler_on the stack. (In the current implementation, this index cannot be a pseudo-index.) When a runtime error occurs, this function is called and the parameter is the error message. The return value of the error handling function will be returned on the stack as an error message by [lua_pcall](#lua_pcall).
如果 `object` 不包含元表，返回 **nil** 。 否则，如果在该对象的元表中有 `"__metatable"` 域时返回其关联值， 没有时返回该对象的元表。
If `object` does not contain a meta table, **nil** is returned * *. Otherwise, return its associated value if there is a `"__metatable"` field in the object`s meta table, and return the object`s meta table if not.
如果 `ptr` 不是 `NULL`， `osize` 是 `ptr` 指向的内存块的尺寸， 即这个内存块当初被分配或重分配的尺寸。
If `ptr` is not `NULL`, `osize` is the size of the memory block pointed to by `ptr`, that is, the size of the memory block originally allocated or reallocated.
如果 `ptr` 是 `NULL`， `osize` 是 Lua 即将分配对象类型的编码。 当（且仅当）Lua 创建一个对应类型的新对象时， `osize` 是 [`LUA_TSTRING`](#pdf-LUA_TSTRING)，[`LUA_TTABLE`](#pdf-LUA_TTABLE)，[`LUA_TFUNCTION`](#pdf-LUA_TFUNCTION)， [`LUA_TUSERDATA`](#pdf-LUA_TUSERDATA)，或 [`LUA_TTHREAD`](#pdf-LUA_TTHREAD) 中的一个。 若 `osize` 是其它类型，Lua 将为其它东西分配内存。
If `ptr` is `NULL`, `osize` is the encoding of the type of object Lua is about to assign. When (and only if) Lua creates a new object of the corresponding type, `osize` is one of [LUA_TSTRING](#pdf-LUA_TSTRING), [LUA_TTABLE](#pdf-LUA_TTABLE), [LUA_TFUNCTION](#pdf-LUA_TFUNCTION), [LUA_TUSERDATA](#pdf-LUA_TUSERDATA), or [LUA_TTHREAD](#pdf-LUA_TTHREAD). If `osize` is something else, Lua will allocate memory for something else.
如果 `ref` 为 [`LUA_NOREF`](#pdf-LUA_NOREF) 或 [`LUA_REFNIL`](#pdf-LUA_REFNIL)， [`luaL_unref`](#luaL_unref) 什么也不做。
If `ref` is [LUA_NOREF](#pdf-LUA_NOREF) or [LUA_REFNIL](#pdf-LUA_REFNIL), [luaL_unref](#luaL_unref) does nothing.
如果 `repl` 是个函数，则在每次匹配发生时都会调用这个函数。 所有捕获到的子串依次作为参数传入。
If `repl` is a function, this function is called every time a match occurs. All captured substrings are passed in as parameters in turn.
如果 `repl` 是一个字符串，那么把这个字符串作为替换品。 字符 `%` 是一个转义符： `repl` 中的所有形式为 `%_d_` 的串表示 第 _d_ 个捕获到的子串，_d_ 可以是 1 到 9 。 串 `%0` 表示整个匹配。 串 `%%` 表示单个
If `repl` is a string, then use this string as the replacement. The character `%` is an escape character: all strings of the form `%_d_` in `repl` represent the_d_th captured substring, which can be 1 through 9. The string `%0` represents the entire match. The string `%%` represents a single
如果 `repl` 是张表，每次匹配时都会用第一个捕获物作为键去查这张表。
If `repl` is a table, each match will use the first catch as a key to look up the table.
如果 `s` 为 `NULL`，将 **nil** 压栈并返回
If `s` is `NULL`, **nil** is pushed and returned
如果 `strip` 为真， 二进制代码块将不包含该函数的调试信息。
If `strip` is true, the binary code block will not contain debugging information for the function.
如果 `t` 有元方法 `__pairs`， 以 `t` 为参数调用它，并返回其返回的前三个值。
If `t` has meta method `__pairs`, call it with `t` as an argument and return the first three values it returns.
如果 `v` 有 `"__tostring"` 域的元表， `tostring` 会以 `v` 为参数调用它。 并用它的结果作为返回值。
If `v` has a metable`__tostring "`field, `tostring` will call it with `v` as an argument. and use its result as the return value.
如果 `x` 可以转换为一个整数， 返回该整数。 否则返回
If `x` can be converted to an integer, return that integer. Otherwise return
如果 `x` 是整数，返回 "`integer`"， 如果它是浮点数，返回 "`float`"， 如果 `x` 不是数字，返回
Returns "`integer`" if `x` is an integer, "`float`" if it is a floating point, and "`float`" if `x` is not a number
如果表单中最后一个域的形式是 `exp` ， 而且其表达式是一个函数调用或者是一个可变参数， 那么这个表达式所有的返回值将依次进入列表 （参见
If the last field in the form is in the form of `exp` and its expression is a function call or a variable parameter, then all the return values of this expression will go into the list in turn (see
如果表的查询结果或函数的返回结果是一个字符串或是个数字， 都将其作为替换用串； 而在返回 **false** 或 **nil**　时不作替换 （即保留匹配前的原始串
If the query result of the table or the return result of the function is a string or a number, it is used as a replacement string. However, when returning **false** or **nil**, no replacement is made (that is, the original string before matching is retained
如果不传参数调用， `date` 返回一个合理的日期时间串， 格式取决于宿主程序以及当前的区域设置 （即，`os.date()` 等价于
If called without parameters, `date` returns a reasonable date-time string in a format that depends on the host program and the current locale (I. e., `OS. date()` is equivalent
如果不传入参数， [`debug.sethook`](#pdf-debug.sethook) 关闭钩子。
If no parameters are passed in, [`debug.sethook`](#pdf-debug.sethook) closes the hook.
如果不带参数调用， `os.execute` 在系统解释器存在的时候返回真。
If called without arguments, `OS .exe cute` returns true if the system interpreter exists.
如果成功，返回一个临时文件的句柄。 这个文件以更新模式打开，在程序结束时会自动删除。
If successful, returns a handle to the temporary file. This file is opened in update mode and is automatically deleted at the end of the program.
如果错误发生在保护环境之外， Lua 会先调用 _panic 函数_ （参见 [`lua_atpanic`](#lua_atpanic)） 然后调用 `abort` 来退出宿主程序。 你的 panic 函数只要不返回 （例如：长跳转到你在 Lua 外你自己设置的恢复点） 就可以不退出程序。
If the error occurs outside the protected environment, Lua will first call the_panic function_(see [lua_atpanic](#lua_atpanic)) and then call `abort` to exit the host program. Your panic function can not exit the program as long as it does not return (for example, long jump to the recovery point you set yourself outside Lua).
如果第二个可选参数 `close` 为真， 在退出前关闭 Lua 状态机。
If the second optional argument `close` is true, close the Lua state machine before exiting.
如果第三个表达式（步长）没有给出，会把步长设为
If the third expression (step) is not given, the step is set
如果调用的时候没有 `base`， `tonumber` 尝试把参数转换为一个数字。 如果参数已经是一个数字，或是一个可以转换为数字的字符串， `tonumber` 就返回这个数字； 否则返回
If there is no `base` at the time of the call, `number` tries to convert the argument to a number. If the argument is already a number, or a string that can be converted to a number, `number` returns that number; otherwise
如果调用时不带选项 `-E`， 解释器会在运行任何参数前，检查环境变量 `LUA_INIT_5_3` （或在版本名未定义时，检查 `LUA_INIT` ）。 如果该变量内存格式为 `@_filename_`， `lua` 执行该文件。 否则，`lua` 执行该字符串。
If the call is made without the `-E` option, the interpreter checks the environment variable` LUA_INIT_5_3 `(or` LUA_INIT `if the version name is undefined) before running any parameters. If the variable memory format is `@_filename_`, `lua` executes the file. Otherwise, `lua` executes the string.
如果调用时有选项 `-E`， 除了忽略 `LUA_INIT` 外， Lua 还忽略 `LUA_PATH` 与 `LUA_CPATH` 的值。 将 [`package.path`](#pdf-package.path) 和 [`package.cpath`](#pdf-package.cpath) 的值设为定义在 `luaconf.h` 中的默认路径。
If there is an option `-E` in the call, Lua ignores the values of` LUA_PATH `and` LUA_CPATH `in addition to ignoring` LUA_INIT. Set the values of [`package.path`](#pdf-package.path) and [`package.cpath`](#pdf-package.cpath) to the default path defined in `luaconf.h.
如果调用中没提供脚本名， 解释器的名字就放在索引 0 处，后面接着其它参数。 例如，调用
If the script name is not provided in the call, the interpreter name is placed at index 0, followed by other parameters. For example, calling
如果返回的函数有上值， 第一个上值会被设置为 保存在注册表（参见 [§4.5](#4.5)） `LUA_RIDX_GLOBALS` 索引处的全局环境。 在加载主代码块时，这个上值是 `_ENV` 变量（参见 [§2.2](#2.2)）。 其它上值均被初始化为
If the returned function has an upper value, the first upper value is set to the global context stored at the LUA_RIDX_GLOBALS index in the registry (see [§ 4.5](#4.5)). When the main code block is loaded, this upper value is the `_ENV` variable (see [§ 2.2](#2.2)). All other upper values are initialized
如果该索引处的值有元表，则将其元表压栈，返回 1 。 否则不会将任何东西入栈，返回
If the value at the index has a meta table, the meta table is stacked and 1 is returned. Otherwise nothing will be put on the stack, return
如果该值有一个带 `"__tostring"` 域的元表， `luaL_tolstring` 会以该值为参数去调用对应的元方法， 并将其返回值作为结果。
If the value has a meta table with `__tostring` field, the luaL_tolstring calls the corresponding meta method with the value as the parameter and returns the value as the result.
如果给定的协程可以让出，返回 1 ，否则返回
If the given coroutine can be conceded, return 1, otherwise return
如果给定索引处的值是一个完全用户数据， 函数返回其内存块的地址。 如果值是一个轻量用户数据， 那么就返回它表示的指针。 否则，返回
If the value at the given index is a full user data, the function returns the address of its memory block. If the value is a lightweight user data, the pointer it represents is returned. Otherwise, return
如果函数的第 `arg` 个参数是一个 数字，返回该数字。 若该参数不存在或是 **nil**， 返回 `d`。 除此之外的情况，抛出错误。
If the `arg` argument to the function is a number, return that number. If the parameter does not exist or is **nil**, return `d `. Other than that, an error is thrown.
如果函数的第 `arg` 个参数是一个 整数（或可以转换为一个整数）， 返回该整数。 若该参数不存在或是 **nil**， 返回 `d`。 除此之外的情况，抛出错误。
If the `arg` argument to the function is an integer (or can be converted to an integer), return that integer. If the parameter does not exist or is **nil**, return `d `. Other than that, an error is thrown.
如果函数的第 `arg` 个参数是一个 字符串，返回该字符串。 若该参数不存在或是 **nil**， 返回 `d`。 除此之外的情况，抛出错误。
If the `arg` argument to the function is a string, return that string. If the parameter does not exist or is **nil**, return `d `. Other than that, an error is thrown.
如果函数是一个 Lua 函数，则为一个字符串 `"Lua"` ； 如果是一个 C 函数，则为 `"C"`； 如果它是一个代码块的主体部分，则为
A string `"Lua"` if the function is a Lua function, `"C"` if it is a C function, or if it is the body part of a code block
如果函数是一个可变参数函数则为真 （对于 C 函数永远为真
True if the function is a variable parameter function (always true for C functions
如果函数以尾调用形式调用，这个值就为真。 在这种情况下，当层的调用者不在栈中。
This value is true if the function is called as a tail call. In this case, when the layer's caller is not in the stack.
如果检查无法通过， `luaL_check*` 这些函数一定会抛出错误。
If the check fails, the `luaL_check * `functions will definitely throw an error.
如果结果函数有上值， `env` 被设为第一个上值。 若不提供此参数，将全局环境替代它。 所有其它上值初始化为 **nil**。 （当你加载主代码块时候，结果函数一定有且仅有一个上值 `_ENV` （参见 [§2.2](#2.2)））。 然而，如果你加载一个用函数（参见 [`string.dump`](#pdf-string.dump)， 结果函数可以有任意数量的上值） 创建出来的二进制代码块时，所有的上值都是新创建出来的。 也就是说它们不会和别的任何函数共享。
If the result function has an upper value, `env` is set to the first upper value. If this parameter is not supplied, the global environment overrides it. All other upper values are initialized to **nil * *. (When you load the main code block, the result function must have only one upper value `_ENV` (see [§ 2.2](#2.2))). However, if you load a block of binary code created with a function (see [`string.dump`](#pdf-string.dump), the resulting function can have any number of upper values), all the upper values are newly created. This means that they are not shared with any other functions.
如果没有错误，函数返回假； 有错则返回真。
If there is no error, the function returns false; if there is an error, it returns true.
如果没有语法错误， 则以函数形式返回编译好的代码块； 否则，返回 **nil** 加上错误消息。
Returns a compiled block of code as a function if there are no syntax errors; otherwise, returns **nil** plus an error message.
如果你把步进倍率设为一个非常大的数字 （比你的程序可能用到的字节数还大 10% ）， 收集器的行为就像一个 stop-the-world 收集器。 接着你若把间歇率设为 200 ， 收集器的行为就和过去的 Lua 版本一样了： 每次 Lua 使用的内存翻倍时，就做一次完整的收集。
If you set the step factor to a very large number (10% larger than the number of bytes your program may use), the collector behaves like a stop-the-world collector. Then if you set the intermittent rate to 200, the collector behaves like the previous version of Lua: every time Lua doubles the memory used, it does a complete collection.
如果你预先知道结果串的长度， 你可以这样使用缓存
If you know the length of the result string in advance, you can use the cache like this.
如果你在寻找原版手册页面，请[点击这里查看
If you are looking for the original manual page, please [click here to view
如果其参数 `v` 的值为假（**nil** 或 **false**）， 它就调用 [`error`](#pdf-error)； 否则，返回所有的参数。 在错误情况时， `message` 指那个错误对象； 如果不提供这个参数，参数默认为
If the value of its parameter `v` is false (**nil** or **false**), it calls [`error`](#pdf-error); otherwise, it returns all the parameters. In the case of an error, `message` refers to that error object; if this parameter is not supplied, the parameter defaults
如果索引 `index1` 与索引 `index2` 处的值 本身相等（即不调用元方法），返回 1 。 否则返回 0 。 当任何一个索引无效时，也返回
Returns 1 if index `index1` is equal to the value at index `index2` itself (I. e. no meta method is called). Otherwise it returns 0. Also returns when either index is invalid
如果提供了 `time` 参数， 格式化这个时间 （这个值的含义参见 [`os.time`](#pdf-os.time) 函数）。 否则，`date` 格式化当前时间。
If the `time` parameter is provided, the time is formatted (see the [`OS. time`](#pdf-os.time) function for the meaning of this value). Otherwise, `date` formats the current time.
如果协程运行起来没有错误， `resume` 返回 **true** 加上传给 `yield` 的所有值 （当协程让出）， 或是主体函数的所有返回值（当协程中止）。 如果有任何错误发生， `resume` 返回 **false** 加错误消息。
If the coroutine runs without errors, `resume` returns **true** plus all the values passed to` yield` (when the coroutine gives up), or all the return values of the subject function (when the coroutine aborts). If any error occurs, `resume` returns **false** plus the error message.
如果要让一个对象（表或用户数据）在收集过程中进入终结流程， 你必须 _标记_ 它需要触发终结器。 当你为一个对象设置元表时，若此刻这张元表中用一个以字符串 "`__gc`" 为索引的域，那么就标记了这个对象需要触发终结器。 注意：如果你给对象设置了一个没有 `__gc` 域的元表，之后才给元表加上这个域， 那么这个对象是没有被标记成需要触发终结器的。 然而，一旦对象被标记， 你还是可以自由的改变其元表中的 `__gc` 域的。
If you want an object (table or user data) to enter the finalization process during collection, you must_mark_it needs to trigger the finalizer. When you set up a meta table for an object, if at this moment the meta table uses a field indexed by the string "`__gc`", then it is marked that the object needs to trigger the finalizer. Note: If you set up a meta table without `__gc` field for an object and then add this field to the meta table, then the object is not marked as needing to trigger the finalizer. However, once the object is marked, you are still free to change the `__gc` field in its meta table.
如果一张弱表在当次收集循环内的复活对象中， 那么在下个循环前这张表有可能未被正确地清理。
If a weak table is in the resurrection object in the current collection cycle, then the table may not be properly cleaned up before the next cycle.
如果有初始化值的话，初始化赋值操作的语法和赋值操作一致 （参见 [§3.3.3](#3.3.3) ）。 若没有初始化值，所有的变量都被初始化为
The syntax of the initial assignment operation is the same as that of the assignment operation, if any (see [§ 3.3.3](#3.3.3) ). If there is no initialization value, all variables are initialized
如果在对负数索引转义后 `i` 小于 1 的话，就修正回 1 。 如果 `j` 比字符串的长度还大，就修正为字符串长度。 如果在修正之后，`i` 大于 `j`， 函数返回空串。
If `I` is less than 1 after escaping the negative index, it is corrected back to 1. If `j` is greater than the length of the string, it is corrected to the length of the string. If, after the correction, `I` is greater than `j`, the function returns an empty string.
如果在加载或运行模块时有错误， 或是无法为模块找到加载器， `require` 都会抛出错误。
If there is an error loading or running the module, or if the loader cannot be found for the module, `require` will throw an error.
如果在模式中定义了捕获，捕获到的若干值也会在两个索引之后返回。
If capture is defined in the schema, several values captured are also returned after two indexes.
如果在索引 `obj` 处的对象有元表， 且元表有域 `e` 。 这个函数会以该对象为参数调用这个域。 这种情况下，函数返回真并将调用返回值压栈。 如果那个位置没有元表，或没有对应的元方法， 此函数返回假（并不会将任何东西压栈
If the object at index `obj` has a meta table and the meta table has field `e `. This function calls the field with the object as an argument. In this case, the function returns true and the call return value is pushed on the stack. If there is no meta table at that location, or no corresponding meta method, this function returns false (and does not stack anything
如果栈顶的对象是 **nil**， [`luaL_ref`](#luaL_ref) 将返回常量 `LUA_REFNIL`。 常量 `LUA_NOREF` 可以保证和 [`luaL_ref`](#luaL_ref) 能返回的其它引用值不同。
If the object at the top of the stack is **nil**, [luaL_ref](#luaL_ref) will return the constant LUA_REFNIL `. The constant LUA_NOREF can be guaranteed to be different from other reference values returned by [luaL_ref](#luaL_ref).
如果这个选项和选项 '`f`' 同时使用， 这张表在函数之后压栈。
If this option is used at the same time as option ''f'', the table is stacked after the function.
如果这个选项和选项 ``f`` 同时使用， 这张表在函数之后压栈。
If this option is used at the same time as option ``f``, the table is stacked after the function.
如果整数 `m` 和 `n` 以无符号整数形式比较， `m` 在 `n` 之下，返回布尔真否则返回假。
If the integers `m` and `n` are compared as unsigned integers, and `m` is below `n`, return Boolean true; otherwise return false.
如果正常结束运行， 解释器会关闭主 Lua 状态机 （参见 [`lua_close`](#lua_close)）。 脚本可以通过调用 [`os.exit`](#pdf-os.exit) 来结束，以回避这个步骤。
If the run ends normally, the interpreter shuts down the main Lua state machine (see [lua_close](#lua_close)). The script can be ended by calling [`OS. exit`](#pdf-os.exit) to circumvent this step.
如果正在运行的协程可以让出，则返回真。
Returns true if the running coroutes can yield.
如果注册表中已存在键 `tname`，返回 0 。 否则， 为用户数据的元表创建一张新表。 向这张表加入 `__name = tname` 键值对， 并将 `[tname] = new table` 添加到注册表中， 返回 1 。 （`__name`项可用于一些错误输出函数
Returns 0 if the key `tname` already exists in the registry. Otherwise, create a new table for the meta table of user data. Add `__name = tname` key-value pair to this table and add`[tname] = new table` to the registry, returning 1. (`__name` item can be used for some error output functions
如何定义字母、空格、或是其他字符组取决于当前的区域设置。 特别注意：`[a-z]`　未必等价于
How you define letters, spaces, or other groups of characters depends on your current locale. Special note: `[a-z]` is not necessarily equivalent
若 `l` 不为 `NULL`， 将结果的长度填入
If `l` is not `NULL`, fill in the length of the result.
若 `nup` 不为零， 所有的函数都共享 `nup` 个上值。 这些值必须在调用之前，压在表之上。 这些值在注册完毕后都会从栈弹出。
If `nup` is not zero, all functions share `nup` values. These values must be pressed on the table before the call. These values are popped from the stack after registration.
弱表
Weak table
弱表_ 指内部元素为 _弱引用_ 的表。 垃圾收集器会忽略掉弱引用。 换句话说，如果一个对象只被弱引用引用到， 垃圾收集器就会回收这个对象。
Weak table_refers to a table whose internal element is_weak reference. The garbage collector ignores weak references. In other words, if an object is referenced only by weak references, the garbage collector reclaims the object.
弱表针对复活的对象 （指那些正在走终结流程，仅能被终结器访问的对象） 有着特殊的行为。 弱值引用的对象，在运行它们的终结器前就被移除了， 而弱键引用的对象则要等到终结器运行完毕后，到下次收集当对象真的被释放时才被移除。 这个行为使得终结器运行时得以访问到由该对象在弱表中所关联的属性。
Weak tables have special behavior for resurrected objects (those that are going through the finalizer process and can only be accessed by the finalizer). Objects referenced by weak values are removed before their finalizers are run, while objects referenced by weak keys are not removed until the finalizers are run and the next collection when the objects are actually released. This behavior allows the finalizer runtime to access the properties associated by the object in the weak table.
删除指定名字的文件（在 POSIX 系统上可以是一个空目录） 如果函数失败，返回 **nil** 加一个错误描述串及出错码。
Delete the file with the specified name (it can be an empty directory on POSIX systems). If the function fails, return **nil** plus an error description string and error code.
上面的代码中，新函数 `k` 就是一个 _延续函数_ （函数类型为 [`lua_KFunction`](#lua_KFunction)）。 它的工作就是原函数中调用 [`lua_pcall`](#lua_pcall) 之后做的那些事情。 现在我们必须通知 Lua 说，你必须在被 [`lua_pcall`](#lua_pcall) 执行的 Lua 代码发生过中断（错误或让出）后， 还得继续调用 `k` 。 所以我们还得继续改写这段代码，把 [`lua_pcall`](#lua_pcall) 替换成
In the above code, the new function `k` is a_continuation function_(the function type is [lua_KFunction](#lua_KFunction)). Its job is what it does after the call to [lua_pcall](#lua_pcall) in the original function. Now we must inform Lua that you must continue to call `k` after the Lua code executed by [`lua_pcall`](#lua_pcall) has been interrupted (error or yield) `. So we have to continue to rewrite this code and replace [`lua_pcall`](#lua_pcall)
上值的数量
Number of upper values
设为大端编码
Set to Big Endian
设为小端编码
Set to Little Ended
设置闭包上值的值。 它把栈顶的值弹出并赋于上值并返回上值的名字。 参数 `funcindex` 与 `n` 和 [`lua_getupvalue`](#lua_getupvalue) 中的一样 （参见
Sets the value of the value on the closure. It pops the value at the top of the stack and assigns it to the upper value and returns the name of the upper value. The argument `funcindex` is the same as in `n` and [lua_getupvalue](#lua_getupvalue) (cf.
设置程序的当前区域。 `locale` 是一个区域设置的系统相关字符串； `category` 是一个描述有改变哪个分类的可选字符串： `"all"`，`"collate"`， `"ctype"`， `"monetary"`， `"numeric"`， 或 `"time"`； 默认的分类为 `"all"`。 此函数返回新区域的名字。 如果请求未被获准，返回
Sets the current region of the program. `locale` is a locale-dependent system string; `category` is an optional string that describes which classification has changed: `"all"`, `"collate"`, `"ctype"`, `"monetary"`, `"numeric"`, or `"time"`; the default classification is `"all"`. This function returns the name of the new region. If the request is not granted, return
设置给定活动记录中的局部变量的值。 参数 `ar` 与 `n` 和 [`lua_getlocal`](#lua_getlocal) 中的一样 （参见 [`lua_getlocal`](#lua_getlocal) ）。 [`lua_setlocal`](#lua_setlocal) 把栈顶的值赋给变量然后返回变量的名字。 它会将值从栈顶弹出。
Sets the value of a local variable in a given active record. The parameter `ar` is the same as in `n` and [lua_getlocal](#lua_getlocal) (see [lua_getlocal](#lua_getlocal) ). [`lua_setlocal`](#lua_setlocal) Assign the value of the top of the stack to the variable and return the name of the variable. It will pop the value from the top of the stack.
设置及获取基于文件开头处计算出的位置。 设置的位置由 `offset` 和 `whence` 字符串 `whence` 指定的基点决定。基点可以是
Sets and gets the position calculated based on the beginning of the file. The location of the setting is determined by the base point specified by the `offset` and `whence` strings `whence. The base point can be
设置输出文件的缓冲模式。 有三种模式
Sets the buffer mode for the output file. There are three modes
设置一个调试用钩子函数。
Set up a hook function for debugging.
设置一个新的 panic 函数，并返回之前设置的那个。 （参见
Set a new panic function and return the one you set previously. (See
实现了一个增量标记-扫描收集器。 它使用这两个数字来控制垃圾收集循环： _垃圾收集器间歇率_ 和 _垃圾收集器步进倍率_。 这两个数字都使用百分数为单位 （例如：值 100 在内部表示
An incremental marker-scan collector is implemented. It uses these two numbers to control the garbage collection cycle:_garbage collector intermittent rate_and_garbage collector step rate_. Both of these numbers use percentages as units (e. g. the value 100 is represented internally
使用 '键' （在索引 -2 处） 和 '值' （在索引 -1 处
Use 'key' (at index -2) and 'value' (at index -1
使用 [`xpcall`](#pdf-xpcall) 或 [`lua_pcall`](#lua_pcall) 时， 你应该提供一个 _消息处理函数_ 用于错误抛出时调用。 该函数需接收原始的错误消息，并返回一个新的错误消息。 它在错误发生后栈尚未展开时调用， 因此可以利用栈来收集更多的信息， 比如通过探知栈来创建一组栈回溯信息。 同时，该处理函数也处于保护模式下，所以该函数内发生的错误会再次触发它（递归）。 如果递归太深，Lua 会终止调用并返回一个合适的消息。
When using [`xpcall`](#pdf-xpcall) or [`lua_pcall](#lua_pcall), you should provide a_message handler_to be called when the error is thrown. This function receives the original error message and returns a new error message. It is called when the stack has not been expanded since the error occurred, so you can use the stack to collect more information, such as by exploring the stack to create a set of stack backtracking information. At the same time, the handler is also in protected mode, so an error within the function triggers it again (recursively). If the recursion is too deep, Lua terminates the call and returns an appropriate message.
使用一个 _虚拟栈_ 来和 C 互传值。 栈上的的每个元素都是一个 Lua 值 （**nil**，数字，字符串，等等
Use a_virtual stack_to pass values to and from C. Each element on the stack is a Lua value (**nil**, number, string, etc.
是一个关联数组， 也就是说，这个数组不仅仅以数字做索引，除了 **nil** 和 NaN 之外的所有 Lua 值 都可以做索引。 （_Not a Number_ 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 `0/0`。） 表可以是 _异构_ 的； 也就是说，表内可以包含任何类型的值（ **nil** 除外）。 任何键的值若为 **nil** 就不会被记入表结构内部。 换言之，对于表内不存在的键，都对应着值
is an associative array, that is, this array is not only indexed by numbers, but all Lua values except **nil** and NaN can be indexed. (The_Not a Number_ is a special number that is used to represent the result of an undefined or unrepresentative operation, such as` 0/0 `.) Tables can be heterogeneous; that is, they can contain values of any type (except **nil**). Any key with a value of **nil** will not be recorded inside the table structure. In other words, for keys that do not exist in the table, they all correspond to values.
是一个自由软件，其使用许可证决定了它的使用过程无需任何担保。 本手册所描述的实现可以在 Lua 的官方网站 `www.lua.org` 找到。
It is a free software, and its use license determines its use without any guarantee. The implementation described in this manual can be found on Lua`s official website at `www.lua.org.
是一门_动态类型语言_。 这意味着变量没有类型；只有值才有类型。 语言中不设类型定义。 所有的值携带自己的类型。
is a_dynamically typed language_. This means that variables have no type; only values have a type. There is no type definition in the language. All values carry their own type.
是一门扩展式程序设计语言，被设计成支持通用过程式编程，并有相关数据描述设施。 同时对面向对象编程、函数式编程和数据驱动式编程也提供了良好的支持。 它作为一个强大、轻量的嵌入式脚本语言，可供任何需要的程序使用。 Lua 由 _clean C（标准 C 和 C++ 间共通的子集）_ 实现成一个库。
It is an extended programming language designed to support general procedural programming and has related data description facilities. It also provides good support for object-oriented programming, functional programming and data-driven programming. As a powerful, lightweight embedded scripting language, it can be used by any program that needs it. Lua is implemented as a library by_clean C (a subset common between standard C and C).
是这样一种写法的语法糖
is the grammatical sugar of such a way of writing
是作为一个宏定义出现的
is present as a macro definition
释放索引 `t` 处表的 `ref` 引用对象 （参见 [`luaL_ref`](#luaL_ref) ）。 此条目会从表中移除以让其引用的对象可被垃圾收集。 而引用 `ref` 也被回收再次使用。
Releases the `ref` reference object for the table at index `t` (see [luaL_ref](#luaL_ref) ). This entry is removed from the table to make the object it references available for garbage collection. The reference `ref` is also recycled for reuse.
收到 x 以及 f() 返回的所有结果
Receive all results returned by x and f()
收到第二个参数（如果可变参数列表中
Receive the second parameter (if the variable parameter list.
收到可变参数列表的第一个参数
Received the first argument of the list of variadic arguments
首先 `require` 查找 `package.preload[modname]` 。 如果这里有一个值，这个值（必须是一个函数）就是那个加载器。 否则 `require` 使用 Lua 加载器去查找 [`package.path`](#pdf-package.path) 的路径。 如果查找失败，接着使用 C 加载器去查找 [`package.cpath`](#pdf-package.cpath) 的路径。 如果都失败了，再尝试 _一体化_ 加载器 （参见
First `require` looks for `package.preload[modname]`. If there is a value here, this value (which must be a function) is the loader. Otherwise `require` uses the Lua loader to find the path of [`package.path`](#pdf-package.path). If the lookup fails, then use the C loader to find the path of [`package.cpath`](#pdf-package.cpath). If all fail, try the_integration_loader again (see
首先定义一个类型为 [`luaL_Buffer`](#luaL_Buffer) 的变量
First define a variable of type [`luaL_Buffer`](#luaL_Buffer)
输入输出
Input Output
输入输出库
input and output library
属性为弱键强值的表也被称为 _暂时表_。 对于一张暂时表， 它的值是否可达仅取决于其对应键是否可达。 特别注意，如果表内的一个键仅仅被其值所关联引用， 这个键值对将被表内移除。
A table whose attribute is a weak key and strong value is also called a_temporary table_. For a temporary table, whether its value is reachable depends only on whether its corresponding key is reachable. Note that if a key in a table is referenced only by its value, the key-value pair will be removed from the table.
数学函数
mathematical function
数学函数 ([§6.7](#6.7)) (sin ，log 等
Mathematical functions ([§ 6.7](#6.7)) (sin ,log, etc.
数学库中的这些函数废弃了： `atan2`， `cosh`， `sinh`， `tanh`， `pow`， `frexp`， 以及 `ldexp` 。 你可以用 `x^y` 替换 `math.pow(x,y)`； 你可以用 `math.atan` 替换 `math.atan2`，前者现在可以接收一或两个参数； 你可以用 `x * 2.0^exp` 替换 `math.ldexp(x,exp)`。 若用到其它操作，你可以写一个扩展库，或在 Lua 中实现它们。
These functions in the math library are obsolete: `atan2`, `cosh`, `sinh`, `tanh`, `pow`, `frexp`, and `ldexp `. You can replace `math.pow(x,y)`with `x ^ y`; you can replace `math.atan2` with `math.atan`, which can now take one or two arguments; you can replace `math.ldexp(x,exp)` with `x * 2.0 ^ exp `. If you use other operations, you can write an extension library or implement them in Lua.
数学运算操作符
Mathematical Operation Operator
数字编码没有必要跨平台。
There is no need for digital encoding to be cross-platform.
数字常量_ （或称为 _数字量_） 可以由可选的小数部分和可选的十为底的指数部分构成， 指数部分用字符 '`e`' 或 '`E`' 来标记。 Lua 也接受以 `0x` 或 `0X` 开头的 16 进制常量。 16 进制常量也接受小数加指数部分的形式，指数部分是以二为底， 用字符 '`p`' 或 '`P`' 来标记。 数字常量中包含小数点或指数部分时，被认为是一个浮点数； 否则被认为是一个整数。 下面有一些合法的整数常量的例子
The numeric constant_(or_numeric quantity_) may consist of an optional decimal part and an optional base-ten exponential part, which is marked with the character ``e` or ``E. Lua also accepts hexadecimal constants starting with `0x` or `0X. Hexadecimal constants also accept the form of decimal plus exponential parts. The exponential part is based on two and is marked with the character ``p`` or ``P. A numeric constant is considered a floating-point number when it contains a decimal or exponential part; otherwise it is considered an integer. Here are some examples of legal integer constants
数字和字面串在 [§3.1](#3.1) 中解释； 变量在 [§3.2](#3.2) 中解释； 函数定义在 [§3.4.11](#3.4.11) 中解释； 函数调用在 [§3.4.10](#3.4.10) 中解释； 表的构造在 [§3.4.9](#3.4.9) 中解释。 可变参数的表达式写作三个点（'`...`'）， 它只能在有可变参数的函数中直接使用；这些在 [§3.4.11](#3.4.11) 中解释。
Numbers and literal strings are explained in [§ 3.1](#3.1); variables are explained in [§ 3.2](#3.2); function definitions are explained in [§ 3.4.11](#3.4.11); function calls are explained in [§ 3.4.10](#3.4.10); and table construction is explained in [§ 3.4.9](#3.4.9). The expression for variable parameters is written in three points (''...''), which can only be used directly in functions with variable parameters; these are explained in [§ 3.4.11](#3.4.11).
数字和字面串在 [§3.1](#3.1) 中解释； 变量在 [§3.2](#3.2) 中解释； 函数定义在 [§3.4.11](#3.4.11) 中解释； 函数调用在 [§3.4.10](#3.4.10) 中解释； 表的构造在 [§3.4.9](#3.4.9) 中解释。 可变参数的表达式写作三个点（``...``）， 它只能在有可变参数的函数中直接使用；这些在 [§3.4.11](#3.4.11) 中解释。
Numbers and literal strings are explained in [§ 3.1](#3.1); variables are explained in [§ 3.2](#3.2); function definitions are explained in [§ 3.4.11](#3.4.11); function calls are explained in [§ 3.4.10](#3.4.10); and table construction is explained in [§ 3.4.9](#3.4.9). The expression for variable parameters is written in three points (``...``), which can only be used directly in functions with variable parameters; these are explained in [§ 3.4.11](#3.4.11).
数字形式的 **for** 循环，通过一个数学运算不断地运行内部的代码块。 下面是它的语法
The numerical form of the **for** loop, which continuously runs the internal code block through a mathematical operation. Here is its syntax
数组 `l` 必须是一个数组，而不能是一个指针。
Array `l` must be an array, not a pointer.
私有部分
Private part
搜索 `foo.a`　这个名字将 依次尝试打开文件 `./foo/a.lua`　， `./foo/a.lc`　，以及
Searching for the name `foo.a` will attempt to open the files `./foo/a.lua`, `./foo/a.lc`, and
虽然 Lua 被设计成一门扩展式语言，用于嵌入一个宿主程序。 但经常也会被当成独立语言使用。 独立版的 Lua 语言解释器随标准包发布，就叫 `lua`。 独立版解释器保留了所有的标准库及调试库。 其命令行用法为
Although Lua is designed to be an extension language for embedding a host program. It is often used as a separate language. The stand-alone version of the Lua language interpreter is released with the standard package and is called `lua `. The standalone version of the interpreter retains all of the standard and debug libraries. Its command line usage is
虽然我们说的是“函数”， 但一部分简单的 API 是以宏的形式提供的。 除非另有说明， 所有的这些宏都只使用它们的参数一次 （除了第一个参数，那一定是 Lua 状态）， 因此你不需担心这些宏的展开会引起一些副作用。
Although we are talking about "functions", part of the simple API is provided in the form of macros. Unless otherwise noted, all of these macros use their arguments only once (except for the first argument, which must be the Lua state), so you don't have to worry about the side effects of expanding these macros.
所有参数的表达式求值都在函数调用之前。 这样的调用形式 `f{fields}` 是一种语法糖用于表示 `f({fields})`； 这里指参数列表是一个新创建出来的列表。 而这样的形式 `f'_string_'` （或是 `f"_string_"` 亦或是 `f[[_string_]]`） 也是一种语法糖，用于表示 `f('_string_')`； 此时的参数列表是一个单独的字符串。
All argument expressions are evaluated before the function call. The call form `f{fields}`is a syntactic sugar for `f({fields})`; here the argument list is a newly created list. The form `f`_string_``(or `f"_string_"`or `f[[_string_]]`) is also syntactic sugar for `f(`_string_`)`; the argument list is a single string.
所有单个字母表示的类别（`%a`，`%c`，等）， 若将其字母改为大写，均表示对应的补集。 例如，`%S` 表示所有非空格的字符。
All categories represented by a single letter (`%a`,`%c`, etc.), if their letters are changed to uppercase, represent the corresponding complement. For example, `%S` represents all non-space characters.
所有的库都是直接用 C API 实现的，并以分离的 C 模块形式提供。 目前，Lua 有下列标准库
All libraries are implemented directly in the C API and are provided as separate C modules. Currently, Lua has the following standard libraries
所有的位操作都将操作数先转换为整数 （参见 [§3.4.3](#3.4.3)）， 然后按位操作，其结果是一个整数。
All bit operations convert the operand to an integer (see [§ 3.4.3](#3.4.3)) and then operate bitwise, the result of which is an integer.
所有辅助库中的函数和类型都定义在头文件 `lauxlib.h` 中， 它们均带有前缀
All functions and types in the auxiliary library are defined in the header file `lauxlib.h` with the prefix
所有没有显式声明为局部变量（参见 [§3.3.7](#3.3.7)） 的变量名都被当做全局变量。 局部变量有其 _作用范围_ ： 局部变量可以被定义在它作用范围中的函数自由使用（参见
All variable names that are not explicitly declared as local (see [§ 3.3.7](#3.3.7)) are treated as global variables. Local variables have their scope: local variables can be used freely by functions defined in their scope (see.
所有三个控制表达式都只被运算一次， 表达式的计算在循环开始之前。 这些表达式的结果必须是数字。
All three control expressions are evaluated only once, before the loop begins. The result of these expressions must be a number.
索引 `table[key]`。 当 `table` 不是表或是表 `table` 中不存在 `key` 这个键时，这个事件被触发。 此时，会读出 `table` 相应的元方法。
Index `table[key]`. This event is triggered when `table` is not a table or the key `key` does not exist in the table `table. At this point, the corresponding meta-method of `table` is read out.
索引赋值 `table[key] = value` 。 和索引事件类似，它发生在 `table` 不是表或是表 `table` 中不存在 `key` 这个键的时候。 此时，会读出 `table` 相应的元方法。
Index assignment `table[key] = value `. Similar to the index event, it occurs when `table` is not a table or the key `key` does not exist in the table `table. At this point, the corresponding meta-method of `table` is read out.
索引一张表的原则遵循语言中的直接比较规则。 当且仅当 `i` 与 `j`直接比较相等时 （即不通过元方法的比较）， 表达式 `a[i]` 与 `a[j]` 表示了表中相同的元素。 特别指出：一个可以完全表示为整数的浮点数和对应的整数相等 （例如：`1.0 == 1`）。 为了消除歧义，当一个可以完全表示为整数的浮点数做为键值时， 都会被转换为对应的整数储存。 例如，当你写 `a[2.0] = true` 时， 实际被插入表中的键是整数 `2` 。 （另一方面，2 与 "`2`" 是两个不同的 Lua 值， 故而它们可以是同一张表中的不同项
The principle of indexing a table follows the rules of direct comparison in the language. The expressions `a [I] `and `a[j]` represent the same elements in the table if and only if `I` and `j` are directly compared equal (I. e., not by meta-method comparison). In particular, a floating-point number that can be fully represented as an integer is equal to the corresponding integer (for example: `1.0 = = 1 `). In order to eliminate ambiguity, when a floating-point number that can be fully represented as an integer is used as a key value, it will be converted to the corresponding integer storage. For example, when you write `a[2.0] = true`, the key that is actually inserted into the table is the integer `2 `. (On the other hand, 2 and "`2`" are two different Lua values, so they can be different items in the same table.
索引在遍历过程中的次序无定义， _即使是数字索引也是这样_。 （如果想按数字次序遍历表，可以使用数字形式的
The order of indexes during traversal is undefined,_even for numeric indexes_. (If you want to traverse the table in numerical order, you can use
它等价于这样一段代码
It is equivalent to such a piece of code
它是用下列宏实现的
It is implemented with the following macros
它以宏形式实现， 数组 `l` 必须是一个数组，而不能是一个指针。
It is implemented as a macro, and the array `l` must be an array, not a pointer.
提供的格式有
The formats provided are
提供了一个 _注册表_， 这是一个预定义出来的表， 可以用来保存任何 C 代码想保存的 Lua 值。 这个表可以用有效伪索引 `LUA_REGISTRYINDEX` 来定位。 任何 C 库都可以在这张表里保存数据， 为了防止冲突，你需要特别小心的选择键名。 一般的用法是，你可以用一个包含你的库名的字符串做为键名， 或者取你自己 C 对象的地址，以轻量用户数据的形式做键， 还可以用你的代码创建出来的任意 Lua 对象做键。 关于变量名，字符串键名中以下划线加大写字母的名字被 Lua 保留。
A_registry_is provided, which is a predefined table that can be used to hold any Lua value that C code wants to hold. This table can be located with a valid pseudo-index LUA_REGISTRYINDEX. Any C library can store data in this table. To prevent conflicts, you need to choose the key names carefully. The general usage is that you can use a string containing your library name as the key name, or take the address of your own C object as the key in the form of lightweight user data, or use any Lua object created by your code as the key. Regarding the variable name, the name of the string key name with the underlined letter is reserved by Lua.
提供一个列表，其所有元素都是字符串或数字，返回字符串 `list[i]..sep..list[i+1] ··· sep..list[j]`。 `sep` 的默认值是空串， `i` 的默认值是 1 ， `j` 的默认值是 `#list` 。 如果 `i` 比 `j` 大，返回空串。
Provide a list whose elements are all strings or numbers, and return the string `list [I] .. sep .. list [I 1] · · · sep .. list[j]`. The default value of `sep` is an empty string, the default value of `I` is 1, and the default value of `j` is `#list`. If `I` is greater than `j`, an empty string is returned.
填充 `currentline` 域
Populating the `currentline` field
填充 `istailcall` 域
Populating the `istailcall` domain
填充 `name` 及 `namewhat` 域
Populating the `name` and `namework` fields
填充 `nups`， `nparams`，及 `isvararg` 域
Populate the `nups`, `nparams`, and `isvararg` fields
填充 `source` ， `short_src` ， `linedefined` ， `lastlinedefined` ，以及 `what` 域
Fill the fields `source`, `linedefined`, `lastlinedefined`, and `what` with short_src
跳出最内层的循环。
Jump out of the innermost loop.
停止垃圾收集器。
Stop the garbage collector.
停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。
Stops the garbage collector from running. The collector will only run as a result of an explicit call before a restart is called.
通常， 你可以用括号来改变运算次序。 连接操作符 ('`..`') 和乘方操作 ('`^`') 是从右至左的。 其它所有的操作都是从左至右。
Usually, you can use parentheses to change the order of operations. The join operator (``..``) and the power operation (``^``) are right-to-left. All other operations are from left to right.
通常，这个函数不会返回； 当协程一次次延续，将从延续函数继续运行。 然而，有一个例外： 当这个函数从一个逐行运行的钩子函数（参见 [§4.9](#4.9)） 中调用时，`lua_yieldk` 不可以提供延续函数。 （也就是类似 [`lua_yield`](#lua_yield) 的形式）， 而此时，钩子函数在调用完让出后将立刻返回。 Lua 会使协程让出，一旦协程再次被延续， 触发钩子的函数会继续正常运行。
Normally, this function does not return; as the coroutine continues over and over again, it continues from the continuation function. However, there is one exception: when the function is called from a hook function that runs line by line (see [§ 4.9](#4.9)), the lua_yieldk cannot provide a continuation function. (that is, a form similar to [`lua_yield`](#lua_yield)), and in this case, the hook function will return immediately after calling out. Lua will make the coroutine give up. Once the coroutine is continued again, the function that triggered the hook will continue to run normally.
通过调用 [`coroutine.yield`](#pdf-coroutine.yield) 使协程暂停执行，让出执行权。 协程让出时，对应的最近 [`coroutine.resume`](#pdf-coroutine.resume) 函数会立刻返回，即使该让出操作发生在内嵌函数调用中 （即不在主函数，但在主函数直接或间接调用的函数内部）。 在协程让出的情况下， [`coroutine.resume`](#pdf-coroutine.resume) 也会返回 **true**， 并加上传给 [`coroutine.yield`](#pdf-coroutine.yield) 的参数。 当下次重启同一个协程时， 协程会接着从让出点继续执行。 此时，此前让出点处对 [`coroutine.yield`](#pdf-coroutine.yield) 的调用 会返回，返回值为传给 [`coroutine.resume`](#pdf-coroutine.resume) 的第一个参数之外的其他参数。
By calling [`coroutine.yield`](#pdf-coroutine.yield), the execution of the coroutine is suspended to give up the execution right. When a coroutine cedes, the corresponding nearest [`coroutine.resume`](#pdf-coroutine.resume) function returns immediately, even if the cede occurs in an inline function call (I. e., not in the main function, but inside a function called directly or indirectly by the main function). [`coroutine.resume`](#pdf-coroutine.resume) also returns **true** with the parameters passed to [`coroutine.yield`](#pdf-coroutine.yield). The next time the same co-process is restarted, the co-process will then continue to execute from the point of yield. At this point, the previous call to [`coroutine.yield`](#pdf-coroutine.yield) at the exit point will be returned, and the return value is other than the first parameter passed to [`coroutine.resume`](#pdf-coroutine.resume).
通用形式的 **for** 通过一个叫作 _迭代器_ 的函数工作。 每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 **nil** 时，循环停止。 通用形式的 **for** 循环的语法如下
The generic form of **for** works through a function called_iterator. With each iteration, the iterator function is called to produce a new value, and when this value is **nil**, the loop stops. The syntax of the generic form of a **for** loop is as follows
同索引过程那样， 这个事件的元方法即可以是函数，也可以是一张表。 如果是一个函数， 则以 `table`、 `key`、以及 `value` 为参数传入。 如果是一张表， Lua 对这张表做索引赋值操作。 （这个索引过程是走常规的流程，而不是直接索引赋值， 所以这次索引赋值有可能引发另一次元方法
As with the indexing process, the meta-method for this event can be either a function or a table. If it is a function, the parameters `table`, `key`, and `value` are passed in. If it is a table, Lua assigns an index to the table. (This indexing process is a regular process, not a direct index assignment, so this index assignment may trigger another meta-method
同样，Lua 版本更替还会改变预编译代码块的内部呈现方式； 在不同的 Lua 版本间，预编译代码块不兼容。
Similarly, Lua versioning changes the internal rendering of precompiled code blocks; precompiled code blocks are not compatible between different Lua versions.
完全缓冲；只有在缓存满或当你显式的对文件调用 `flush`（参见 [`io.flush`](#pdf-io.flush)） 时才真正做输出操作。
Full buffering; output is only really done when the cache is full or when you explicitly call `flush` on the file (see [`io.flush`](#pdf-io.flush)).
为了方便起见， 当一个开长括号后紧接一个换行符时， 这个换行符不会放在字符串内。 举个例子，假设一个系统使用 ASCII 码 （此时 '`a`' 编码为 97 ， 换行编码为 10 ，'`1`' 编码为 49 ）， 下面五种方式描述了完全相同的字符串
For convenience, when a long parenthesis is followed by a line break, the line break is not placed in the string. For example, suppose a system uses ASCII code (where ''a'' is encoded as 97, line feed is encoded as 10, and ''1'' is encoded as 49 ), and the following five ways describe exactly the same string.
为了方便起见， 当一个开长括号后紧接一个换行符时， 这个换行符不会放在字符串内。 举个例子，假设一个系统使用 ASCII 码 （此时 ``a`` 编码为 97 ， 换行编码为 10 ，``1`` 编码为 49 ）， 下面五种方式描述了完全相同的字符串
For convenience, when a long parenthesis is followed by a line break, the line break is not placed in the string. For example, suppose a system uses ASCII code (where ``a`` is encoded as 97, line feed is encoded as 10, and ``1`` is encoded as 49 ), and the following five ways describe exactly the same string.
为了回避这类问题， 碰到 API 调用中调用让出时，除了那些抛出错误的 API 外，还提供了三个函数： [`lua_yieldk`](#lua_yieldk)， [`lua_callk`](#lua_callk)，和 [`lua_pcallk`](#lua_pcallk) 。 它们在让出发生时，可以从传入的 _延续函数_ （名为 `k` 的参数）继续运行。
In order to avoid this kind of problem, when calling out in API calls, in addition to those API that throw errors, three functions are provided: [lua_yieldk](#lua_yieldk), [lua_callk](#lua_callk), and [lua_pcallk](#lua_pcallk). They can continue to run from the_continuation function_(parameter named `k`) passed in when the yield occurs.
为了让 Lua 可以用于 Unix 系统的脚本解释器。 独立版解释器会忽略代码块的以 `#` 打头的第一行。 因此，Lua 脚本可以通过 `chmod +x` 以及 `#!` 形式变成一个可执行文件。 类似这样
To make Lua a script interpreter for Unix systems. The standalone interpreter ignores the first line of the code block that is headed. Therefore, Lua scripts can be passed through `chmod x` as well `#! `Form becomes an executable file. something like this
为了允许使用函数的副作用， 函数调用可以被作为一个语句执行
To allow the use of function side effects, a function call can be executed as a statement
为了正确的和 Lua 通讯， C 函数必须使用下列协议。 这个协议定义了参数以及返回值传递方法： C 函数通过 Lua 中的栈来接受参数， 参数以正序入栈（第一个参数首先入栈）。 因此，当函数开始的时候， `lua_gettop(L)` 可以返回函数收到的参数个数。 第一个参数（如果有的话）在索引 1 的地方， 而最后一个参数在索引 `lua_gettop(L)` 处。 当需要向 Lua 返回值的时候， C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入）， 然后返回这些返回值的个数。 在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。 和 Lua 函数一样，从 Lua 中调用 C 函数也可以有很多返回值。
In order to communicate properly with Lua, C functions must use the following protocols. This protocol defines the method of passing parameters and return values: C functions accept parameters through the stack in Lua, and the parameters are stacked in positive order (the first parameter is stacked first). Therefore, when the function starts, lua_gettop(L) returns the number of arguments received by the function. The first parameter (if any) is at index 1, and the last parameter is at index lua_gettop(L). When returning values to Lua, the C function only needs to push them onto the stack in positive order (the first return value is pushed first), and then return the number of these return values. Below these return values, everything on the stack is dropped by Lua. Like Lua functions, calling C functions from Lua can have many return values.
位操作符
bit operator
文件句柄实现为一个完全用户数据， 其元表被称为 `LUA_FILEHANDLE` （`LUA_FILEHANDLE` 是一个代表真正元表的名字的宏）。 这张元表由标准输入输出库（参见 [`luaL_newmetatable`](#luaL_newmetatable)）创建。
The file handle is implemented as a full user data whose meta-table is called a LUA_FILEHANDLE (LUA_FILEHANDLE is a macro that represents the name of the real meta-table). This meta table is created by the standard input/output library (see [luaL_newmetatable](#luaL_newmetatable)).
我们使用 _序列_ 这个术语来表示一个用 {1.._n_} 的正整数集做索引的表。 这里的非负整数 _n_ 被称为该序列的长度（参见
We use the term_sequence_to denote a table indexed by the set of positive integers {1 .._n_}. Here the non-negative integer_n_is called the length of the sequence (cf.
我们先做如下定义，然后再来看一个例子
Let's make the following definition first, and then look at an example.
我们需要预设一些术语来解释延续点。 对于从 Lua 中调用的 C 函数，我们称之为 _原函数_。 从这个原函数中调用的上面所述的三个 C API 函数我们称之为 _被调函数_。 被调函数可以使当前线程让出。 （让出发生在被调函数是 [`lua_yieldk`](#lua_yieldk)， 或传入 [`lua_callk`](#lua_callk) 或 [`lua_pcallk`](#lua_pcallk) 的函数调用了让出时
We need to presuppose some terms to explain the continuation point. For C functions called from Lua, we call them_primitive_. The three C API functions described above that are called from this primitive function are called_called functions_. The called function can make the current thread give way. (yield occurs when the called function is [`lua_yieldk`](#lua_yieldk), or the function passed into [`lua_callk`](#lua_callk) or [`lua_pcallk`](#lua_pcallk) calls yield
无论何时 Lua 调用 C ， 它都只保证至少有 `LUA_MINSTACK` 这么多的堆栈空间可以使用。 `LUA_MINSTACK` 一般被定义为 20 ， 因此，只要你不是不断的把数据压栈， 通常你不用关心堆栈大小。
Whenever Lua calls C, it only guarantees that there is at least LUA_MINSTACK so much stack space available. LUA_MINSTACK is generally defined as 20, so as long as you`re not constantly stacking data, you don`t usually care about stack size.
无论何时 Lua 调用 C，被调用的函数都得到一个新的栈， 这个栈独立于 C 函数本身的栈，也独立于之前的 Lua 栈。 它里面包含了 Lua 传递给 C 函数的所有参数， 而 C 函数则把要返回的结果放入这个栈以返回给调用者 （参见
Whenever Lua calls C, the called function gets a new stack, which is independent of the stack of the C function itself and of the previous Lua stack. It contains all the parameters Lua passes to the C function, and the C function puts the result to be returned into this stack to return to the caller (see
无论何时出现错误，都会抛出一个携带错误信息的 _错误对象_ （_错误消息_）。 Lua 本身只会为错误生成字符串类型的错误对象， 但你的程序可以为错误生成任何类型的错误对象， 这就看你的 Lua 程序或宿主程序如何处理这些错误对象。
Whenever an error occurs, an_error object_ (_error message_) carrying the error message is thrown. Lua itself will only generate string type error objects for errors, but your program can generate any type of error object for errors, depending on how your Lua program or host program handles these error objects.
无论何时钩子被调用，它的参数 `ar` 中的 `event` 域都被设为触发钩子的事件。 Lua 把这些事件定义为以下常量： `LUA_HOOKCALL`，`LUA_HOOKRET`， `LUA_HOOKTAILCALL`，`LUA_HOOKLINE`， `LUA_HOOKCOUNT`。 除此之外，对于 line 事件， `currentline` 域也被设置。 要想获得 `ar` 中的其他域， 钩子必须调用
Whenever the hook is called, the `event` field in its parameter `ar` is set to the event that fires the hook. Lua defines these events as the following constants: LUA_HOOKCALL, LUA_HOOKRET, LUA_HOOKTAILCALL, LUA_HOOKLINE, LUA_HOOKCOUNT `. In addition, for the line event, the `currentline` field is also set. To get other fields in `ar`, the hook must call
无论何时去调用 C 函数， 函数的上值都可以用伪索引定位。 我们可以用 [`lua_upvalueindex`](#lua_upvalueindex) 这个宏来生成这些伪索引。 第一个关联到函数的值放在 `lua_upvalueindex(1)` 位置处，依此类推。 使用 `lua_upvalueindex(_n_)` 时， 若 _n_ 大于当前函数的总上值个数 （但不可以大于 256）会产生一个可接受的但无效的索引。
Whenever a C function is called, the upper value of the function can be located with a pseudo index. We can use the [lua_upvalueindex](#lua_upvalueindex) macro to generate these pseudo-indexes. The first value associated with the function is placed in the lua_upvalueindex(1) position, and so on. When using `lua_upvalueindex(_n_)`, if_n_is greater than the total number of upper values of the current function (but cannot be greater than 256), it will produce an acceptable but invalid index.
下列 _关键字_ 是保留的，不可用于名字
The following_keywords_are reserved and cannot be used for names
下列字符串是另外一些符记
The following strings are some other symbols
下面的代码展示了一个协程工作的范例
The following code shows an example of a coroutet working
下面的函数会做一个说明
The following function will do a description
下面的例子中，这行 Lua 代码等价于在宿主程序中用 C 代码做一些工作
In the following example, this line of Lua code is equivalent to doing some work in C code in the host program.
下面对 [`lua_Debug`](#lua_Debug) 的各个域做一个说明
The following is a description of each field of [lua_Debug](#lua_Debug)
下面看看实参到形参数以及可变长参数的映射关系
Let's look at the mapping of real parameters to shape parameters and variable length parameters.
下面这个例子会循环迭代字符串 `s` 中所有的单词， 并逐行打印
The following example iterates over all the words in the string `s` and prints them line by line.
下面这个例子中的函数将接收若干数字参数，并返回它们的平均数与和
The function in the following example takes several numeric arguments and returns their average and sum.
下一个例子从指定的字符串中收集所有的键值对 `key=value` 置入一张表
The next example collects all key-value pairs `key = value` from the specified string and puts them into a table.
显式的对一个块定界通常用来控制内部变量声明的作用域。 有时，显式定界也用于在一个语句块中间插入 **return** （参见
Explicit delimitation of a block is often used to control the scope of an internal variable declaration. Sometimes, explicit delimitation is also used to insert return in the middle of a statement block (see.
现在我们想允许被 [`lua_pcall`](#lua_pcall) 运行的 Lua 代码让出。 首先，我们把函数改写成这个样子
Now we want to allow Lua code that is run by [lua_pcall](#lua_pcall) to give up. First, we rewrite the function like this.
相等比较
Comparison of equality
向缓存 `B` （参见 [`luaL_Buffer`](#luaL_Buffer) ） 添加一个零结尾的字符串
Add a zero-terminated string to cache `B` (see [luaL_Buffer](#luaL_Buffer))
向缓存 `B` （参见 [`luaL_Buffer`](#luaL_Buffer) ） 添加一个已在之前复制到缓冲区（参见 [`luaL_prepbuffer`](#luaL_prepbuffer)） 的长度为 `n` 的字符串。
Add to cache `B` (see [luaL_Buffer](#luaL_Buffer)) a string of length `n` that was previously copied to buffer (see [luaL_prepbuffer](#luaL_prepbuffer)).
向缓存 `B` （参见 [`luaL_Buffer`](#luaL_Buffer) ） 添加一个长度为 `l` 的字符串 `s`。 这个字符串可以包含零。
Add a string `s` of length `l` to cache `B` (see [luaL_Buffer](#luaL_Buffer)) `. This string can contain zeros.
向缓存 `B` （参见 [`luaL_Buffer`](#luaL_Buffer) ） 添加一个字节
Add a byte to cache `B` (see [luaL_Buffer](#luaL_Buffer))
向缓存 `B` （参见 [`luaL_Buffer`](#luaL_Buffer) ） 添加栈顶的一个值，随后将其弹出。
Add a value at the top of the stack to cache `B` (see [luaL_Buffer](#luaL_Buffer)) and then pop it.
向下取整除法
division down
向下取整除法）操作。 行为和 "add" 操作类似。
down to take the whole division) operation. The behavior is similar to the "add" operation.
向下取整的除法
Division with round down
向下取整的除法 （`//`） 指做一次除法，并将商圆整到靠近负无穷的一侧， 即对操作数做除法后取
Division (`//`) refers to division once and rounding the quotient to the side close to negative infinity, I .e. division of the operand
销毁指定 Lua 状态机中的所有对象 （如果有垃圾收集相关的元方法的话，会调用它们）， 并且释放状态机中使用的所有动态内存。 在一些平台上，你可以不必调用这个函数， 因为当宿主程序结束的时候，所有的资源就自然被释放掉了。 另一方面，长期运行的程序，比如一个后台程序或是一个网站服务器， 会创建出多个 Lua 状态机。那么就应该在不需要时赶紧关闭它们。
Destroys all objects in the specified Lua state machine (garbage collection-related meta methods, if any, are called) and frees all dynamic memory used in the state machine. On some platforms, you don't need to call this function, because when the host program ends, all resources are naturally released. On the other hand, a long-running program, such as a background program or a web server, creates multiple Lua state machines. Then you should quickly close them when you don't need them.
小于
Less
小于）操作。 和 "add" 操作行为类似， 不同的是 Lua 仅在两个值不全为整数也不全为字符串时才尝试元方法。 调用的结果总会被转换为布尔量。
less than) operation. The behavior is similar to the "add" operation, except that Lua only tries meta methods when the two values are not all integers or all strings. The result of the call is always converted to a boolean.
小于比较
Less Than Compare
小于等于
Less than or equal
小于等于）操作。 和其它操作不同， 小于等于操作可能用到两个不同的事件。 首先，像 "lt" 操作的行为那样，Lua 在两个操作数中查找 "`__le`" 元方法。 如果一个元方法都找不到，就会再次查找 "`__lt`" 事件， 它会假设 `a <= b` 等价于 `not (b < a)`。 而其它比较操作符类似，其结果会被转换为布尔量。
Less than or equal to) operation. Unlike other operations, the less than or equal to operation may use two different events. First, like the behavior of the "lt" operation, Lua looks for the "`__le`" meta-method in both operands. If a meta-method cannot find it, it will look for the "`__lt`" event again, assuming that `a <= B` is equivalent to `not (B <a)`. Similar to other comparison operators, the results are converted to Boolean quantities.
小于等于比较
Less than or equal to comparison
协程
Synergy
协程的运行可能被两种方式终止： 正常途径是主函数返回 （显式返回或运行完最后一条指令）； 非正常途径是发生了一个未被捕获的错误。 对于正常结束， [`coroutine.resume`](#pdf-coroutine.resume) 将返回 **true**， 并接上协程主函数的返回值。 当错误发生时， [`coroutine.resume`](#pdf-coroutine.resume) 将返回 **false** 与错误消息。
The running of the coroutine may be terminated in two ways: the normal way is that the main function returns (explicitly returns or runs the last instruction); The abnormal way is that an error has not been caught. For normal termination, [`coroutine.resume`](#pdf-coroutine.resume) will return **true**, followed by the return value of the coroutine main function. When an error occurs, [`coroutine.resume`](#pdf-coroutine.resume) will return **false** with the error message.
协程管理
Synergy Management
协程库
Synergy Library
写模式
Write Mode
写入器会返回一个错误码： 0 表示没有错误； 别的值均表示一个错误， 并且会让 [`lua_dump`](#lua_dump) 停止再次调用写入器。
The writer returns an error code: 0 indicates no error; any other value indicates an error and causes [lua_dump](#lua_dump) to stop calling the writer again.
新的一个 'x', 它的值现在是
A new 'x' whose value is now
新的语句块
New statement block
行缓冲； 输出将缓冲到每次换行前， 对于某些特殊文件（例如终端设备）缓冲到任何输入前。
Line buffering; output will be buffered before each newline, and for some special files (such as terminal devices) before any input.
形参被看作是一些局部变量， 它们将由实参的值来初始化
A formal parameter is treated as some local variable that will be initialized by the value of the argument
选项 `A` and `a` （如果有的话）， `E`, `e`, `f`, `G`, and `g` 都期待一个对应的数字参数。 选项 `c`, `d`, `i`, `o`, `u`, `X`, and `x` 则期待一个整数。 选项 `q` 期待一个字符串； 选项 `s` 期待一个没有内嵌零的字符串。 如果选项 `s` 对应的参数不是字符串，它会用和 [`tostring`](#pdf-tostring) 一致的规则转换成字符串。
Options `A` and `a` (if any), `E`, `e`, `f`, `G`, and `g` all expect a corresponding numeric argument. The options `c`, `d`, `I`, `o`, `u`, `x`, and `x` expect an integer. Option `q` expects a string; option `s` expects a string without embedded zeros. If the parameter corresponding to the option `s` is not a string, it will be converted to a string according to the rules of [`tostring`](#pdf-tostring).
选项有
The options are
循环变量 `v` 是一个循环内部的局部变量； 如果你需要在循环结束后使用这个值， 在退出循环前把它赋给另一个变量。
The loop variable `v` is a local variable inside a loop; if you need to use this value at the end of the loop, assign it to another variable before exiting the loop.
延续函数的类型（参见
types of continuation functions (cf.
延续函数上下文参数的类型。 这一定是一个数字类型。 当有 `intptr_t` 时，被定义为 `intptr_t` ， 因此它也可以保存指针。 否则，它被定义为
The type of the continuation function context parameter. This must be a numeric type. When there is a intptr_t, it is defined as a intptr_t, so it can also hold a pointer. Otherwise, it is defined
延续函数现在接收原来用 `lua_getctx` 获取的参数， 所以 `lua_getctx` 就去掉了。 按需要改写你的代码。
The continuation function now receives the parameters originally obtained with the lua_getctx, so the lua_getctx is removed. Rewrite your code as needed.
要调用一个函数请遵循以下协议： 首先，要调用的函数应该被压入栈； 接着，把需要传递给这个函数的参数按正序压栈； 这是指第一个参数首先压栈。 最后调用一下 [`lua_call`](#lua_call)； `nargs` 是你压入栈的参数个数。 当函数调用完毕后，所有的参数以及函数本身都会出栈。 而函数的返回值这时则被压栈。 返回值的个数将被调整为 `nresults` 个， 除非 `nresults` 被设置成 `LUA_MULTRET`。 在这种情况下，所有的返回值都被压入堆栈中。 Lua 会保证返回值都放入栈空间中。 函数返回值将按正序压栈（第一个返回值首先压栈）， 因此在调用结束后，最后一个返回值将被放在栈顶。
To call a function, please follow the following protocol: first, the function to be called should be pushed onto the stack. Finally, call [`lua_call`](#lua_call); `nargs` is the number of parameters you pushed onto the stack. When the function call is completed, all the parameters and the function itself will be out of the stack. The return value of the function is then pushed on the stack. The number of returned values will be adjusted to `nresults` unless `nresults` is set to LUA_MULTRET `. In this case, all return values are pushed onto the stack. Lua will ensure that the return value is placed in the stack space. Function return values will be pushed in positive order (the first return value is pushed first), so after the call, the last return value will be placed on the top of the stack.
要启动一个协程的话， 你需要把主函数以及它需要的参数压入线程栈； 然后调用 [`lua_resume`](#lua_resume) ， 把 `nargs` 设为参数的个数。 这次调用会在协程挂起时或是结束运行后返回。 当函数返回时，堆栈中会有传给 [`lua_yield`](#lua_yield) 的所有值， 或是主函数的所有返回值。 当协程让出， [`lua_resume`](#lua_resume) 返回 [`LUA_YIELD`](#pdf-LUA_YIELD) ， 若协程结束运行且没有任何错误时，返回 0 。 如果有错则返回错误代码（参见
To start a coroutine, you need to push the main function and its required parameters into the thread stack. Then call [`lua_resume`](#lua_resume) and set `nargs` to the number of parameters. This call will return when the coroutine is suspended or when it finishes running. When the function returns, there will be all the values passed to [lua_yield](#lua_yield) on the stack, or all the return values of the main function. When the coroutine gives up, [`lua_resume`](#lua_resume) returns [`LUA_YIELD`](#pdf-LUA_YIELD), and if the coroutine ends running without any errors, it returns 0. Returns an error code if there is an error (see
要使用这些库， C 的宿主程序需要先调用一下 [`luaL_openlibs`](#luaL_openlibs) 这个函数， 这样就能打开所有的标准库。 或者宿主程序也可以用 [`luaL_requiref`](#luaL_requiref) 分别打开这些库： `luaopen_base` （基础库）， `luaopen_package` （包管理库）， `luaopen_coroutine` （协程库）， `luaopen_string` （字符串库）， `luaopen_utf8` （UTF8 库）， `luaopen_table` （表处理库）， `luaopen_math` （数学库）， `luaopen_io` （I/O 库）， `luaopen_os` （操作系统库）， `luaopen_debug` （调试库）。 这些函数都定义在 `lualib.h` 中。
To use these libraries, the C host program needs to call the [luaL_openlibs](#luaL_openlibs) function, which opens all the standard libraries. Or the host program can use [`luaL_requiref`](#luaL_requiref) to open these libraries respectively: `luaopen_base` (basic library), `luaopen_package` (package management library), `luaopen_coroutine` (coroutine library), `luaopen_string` (string library), `luaopen_utf8` (UTF8 library), `luaopen_table` (table processing library), `luaopen_math` (math library), luaopen_io (I/O library), luaopen_ OS (operating system library), luaopen_debug (debug library). These functions are defined in `lualib.h.
要延续一个协程， 你需要清除上次 [`lua_yield`](#lua_yield) 遗留下的所有结果， 你把需要传给 `yield` 作结果的值压栈， 然后调用
To continue a coroutine, you need to clear all the results left over from the last [`lua_yield`](#lua_yield), you stack the value that needs to be passed to` yield` as the result, and then call
也和 [`lua_load`](#lua_load) 一样，这个函数仅加载代码块不运行。
Also like [lua_load](#lua_load), this function only loads blocks of code and does not run.
也有一个 **for** 语句，它有两种形式 （参见
There is also a **for** statement, which has two forms (see
一般的操作过程中，字符串缓存会使用不定量的栈槽。 因此，在使用缓存中，你不能假定目前栈顶在哪。 在对缓存操作的函数调用间，你都可以使用栈，只需要保证栈平衡即可； 即，在你做一次缓存操作调用时，当时的栈位置和上次调用缓存操作后的位置相同。 （对于 [`luaL_addvalue`](#luaL_addvalue) 是个唯一的例外。） 在调用完 [`luaL_pushresult`](#luaL_pushresult) 后， 栈会恢复到缓存初始化时的位置上，并在顶部压入最终的字符串。
In general operation, the string cache will use an inconstant number of stack slots. Therefore, in using caching, you cannot assume where the top of the stack is currently. You can use the stack between function calls to the cache operation, just keep the stack balanced; that is, when you make a cache operation call, the stack position at that time is the same as the position after the last cache operation was called. (The only exception is for [luaL_addvalue](#luaL_addvalue).) After calling [`luaL_pushresult`](#luaL_pushresult), the stack is restored to the position where the cache was initialized and the final string is pushed at the top.
一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 [`rawset`](#pdf-rawset) 来做赋值
Once you have the "newindex" meta-method, Lua no longer does the initial assignment. (If necessary, [`rawset`](#pdf-rawset) can be called inside the meta method to do the assignment
一个
One
一个 `double` （本地大小
a `double` (local size
一个 `float` （本地大小
a `float` (local size
一个 `n` 字节长（默认为本地大小）的无符号
One `n` byte long (default to local size) unsigned
一个 `n` 字节长（默认为本地大小）的有符号
One `n` byte long (default to local size) signed
一个 `size_t` （本地大小
a `size_t` (local size
一个“可打印版本”的 `source` ，用于出错信息。
A "printable version" of `source` for error messages.
一个包含有当前解释器版本号的全局变量（并非函数）。 当前这个变量的值为
A global variable (not a function) that contains the version number of the current interpreter. The current value of this variable is
一个不透明的结构， 它指向一条线程并间接（通过该线程）引用了整个 Lua 解释器的状态。 Lua 库是完全可重入的： 它没有任何全局变量。 状态机所有的信息都可以通过这个结构访问到。
An opaque structure that points to a thread and indirectly (through that thread) references the state of the entire Lua interpreter. The Lua library is fully reentrant: it doesn't have any global variables. All information about the state machine can be accessed through this structure.
一个代码块同时也是一个语句块（参见 [§3.3.2](#3.3.2)）， 所以局部变量可以放在代码块中那些显式注明的语句块之外。
A code block is also a block of statements (see [§ 3.3.2](#3.3.2)), so local variables can be placed outside of those explicitly noted in the code block.
一个点）可表示任何字符。
A dot) can represent any character.
一个函数定义是一个可执行的表达式， 执行结果是一个类型为 _function_ 的值。 当 Lua 预编译一个代码块时， 代码块作为一个函数，整个函数体也就被预编译了。 那么，无论何时 Lua 执行了函数定义， 这个函数本身就进行了 _实例化_（或者说是 _关闭_了）。 这个函数的实例（或者说是 _闭包_）是表达式的最终值。
A function definition is an executable expression whose result is a value of type_function. When Lua precompiles a code block, the code block acts as a function, and the entire function body is precompiled. So, whenever Lua executes a function definition, the function itself is_instantiated_(or_closed_). The instance (or_closure_) of this function is the final value of the expression.
一个描述有一些为包管理准备的编译期配置信息的串。 这个字符串由一系列行构成
A string that describes some compile-time configuration information prepared for package management. This string consists of a series of lines
一个全局变量（非函数）， 内部储存有全局环境（参见 [§2.2](#2.2)）。 Lua 自己不使用这个变量； 改变这个变量的值不会对任何环境造成影响，反之亦然。
A global variable (not a function) that internally stores the global environment (see [§ 2.2](#2.2)). Lua does not use this variable itself; changing the value of this variable does not affect any environment, and vice versa.
一个无符号 `long` （本地大小
An unsigned `long` (local size
一个无符号 `short` （本地大小
An unsigned `short` (local size
一个无符号字节
An unsigned byte
一个有符号 `long` （本地大小
A signed `long` (local size
一个有符号 `short` （本地大小
A signed `short` (local size
一个有符号字节
A signed byte
一个语句块可以被显式的定界为单条语句
A statement block can be explicitly delimited as a single statement
一个字节的填充
A byte of padding
一些辅助库函数会在内部使用一些额外的栈空间。 当辅助库使用的栈空间少于五个时， 它们不去检查栈大小；而是简单的假设栈够用。
Some helper library functions use some extra stack space internally. When auxiliary libraries use less than five stacks, they don't check the stack size; they simply assume that the stack is sufficient.
一些辅助库中的函数用于检查 C 函数的参数。 因为错误信息格式化为指代参数 （例如，"`bad argument #1`"）， 你就不要把这些函数用于参数之外的值了。
Functions in some auxiliary libraries are used to check the parameters of C functions. Because the error message is formatted to refer to the parameter (for example, "`bad argument #1 `"), you should not use these functions for values other than parameters.
一张弱表可以有弱键或是弱值，也可以键值都是弱引用。 含有弱值的表允许收集器回收它的值，但会阻止收集器回收它的键。 若一张表的键值均为弱引用， 那么收集器可以回收其中的任意键和值。 任何情况下，只要键或值的任意一项被回收， 相关联的键值对都会从表中移除。 一张表的元表中的 `__mode` 域控制着这张表的弱属性。 当 `__mode` 域是一个包含字符 '`k`' 的字符串时，这张表的所有键皆为弱引用。 当 `__mode` 域是一个包含字符 '`v`' 的字符串时，这张表的所有值皆为弱引用。
A weak table can have weak keys or weak values, or both keys and values can be weak references. A table with a weak value allows the collector to reclaim its value, but prevents the collector from reclaiming its key. If the key values of a table are weak references, the collector can recycle any key and value. In any case, whenever either the key or the value is recycled, the associated key-value pair is removed from the table. The '__mode' field in the meta table of a table controls the weak properties of the table. When the '__mode' field is a string containing the character ''k'', all keys in this table are weak references. When the '__mode' field is a string containing the character' v', all values in this table are weak references.
一张弱表可以有弱键或是弱值，也可以键值都是弱引用。 含有弱值的表允许收集器回收它的值，但会阻止收集器回收它的键。 若一张表的键值均为弱引用， 那么收集器可以回收其中的任意键和值。 任何情况下，只要键或值的任意一项被回收， 相关联的键值对都会从表中移除。 一张表的元表中的 `__mode` 域控制着这张表的弱属性。 当 `__mode` 域是一个包含字符 ``k`` 的字符串时，这张表的所有键皆为弱引用。 当 `__mode` 域是一个包含字符 ``v`` 的字符串时，这张表的所有值皆为弱引用。
A weak table can have weak keys or weak values, or both keys and values can be weak references. A table with a weak value allows the collector to reclaim its value, but prevents the collector from reclaiming its key. If the key values of a table are weak references, the collector can recycle any key and value. In any case, whenever either the key or the value is recycled, the associated key-value pair is removed from the table. The `__mode` field in the meta table of a table controls the weak properties of the table. When the `__mode` field is a string containing the character ``k``, all keys in this table are weak references. When the `__mode` field is a string containing the character` v`, all values in this table are weak references.
移除 '值' ；保留 '键' 做下一次迭代
Remove 'value'; keep 'key' for next iteration
移除 `值` ；保留 `键` 做下一次迭代
Remove `value`; keep `key` for next iteration
移除 `list` 中 `pos` 位置上的元素，并返回这个被移除的值。 当 `pos` 是在 1 到 `#list` 之间的整数时， 它向前移动元素　`list[pos+1], list[pos+2], ···, list[#list]` 并删除元素 `list[#list]`； 索引 `pos` 可以是 `#list + 1` ，或在 `#list` 为 0 时可以是 0 ； 在这些情况下，函数删除元素
Removes the element at the `pos` position in `list` and returns the removed value. When `pos` is an integer between 1 and `#list`, it moves the elements `list[pos 1], list[pos 2],..., list[#list]` forward and deletes the element `list[#list]`; the index `pos` can be`#list 1 `, or 0 when`#list `is 0; in these cases, the function deletes the element
以 '`(`' （开括号）打头的变量名表示没有名字的变量 （比如是循环控制用到的控制变量， 或是去除了调试信息的代码块
Variable names beginning with '''' ((open brackets) represent variables without names (e. g. control variables used in loop control, or code blocks with debugging information removed)
以 '`(`' （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块
Variable names beginning with '''' ((open brackets) represent variables without names (code blocks with debug information removed)
以 ``(`` （开括号）打头的变量名表示没有名字的变量 （比如是循环控制用到的控制变量， 或是去除了调试信息的代码块
Variable names beginning with ```` ((open brackets) represent variables without names (e. g. control variables used in loop control, or code blocks with debugging information removed)
以 ``(`` （开括号）打头的变量名表示没有名字的变量 （去除了调试信息的代码块
Variable names beginning with ```` ((open brackets) represent variables without names (code blocks with debug information removed)
以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出
Returns the total memory used by Lua in K bytes. This value has a decimal part, so you only need to multiply 1024 to get the exact number of bytes used by Lua (unless overflow
以保护模式调用一个函数。
Call a function in protected mode.
以读模式打开指定的文件名并返回一个迭代函数。 此迭代函数的工作方式和用一个已打开的文件去调用 `file:lines(···)` 得到的迭代器相同。 当迭代函数检测到文件结束， 它不返回值（让循环结束）并自动关闭文件。
Opens the specified file name in read mode and returns an iterated function. This iterator function works in the same way as the iterator obtained by calling `file:lines (...) `with an open file. When the iterator function detects the end of the file, it returns no value (let the loop end) and automatically closes the file.
以及 `_step_` 都是一些不可见的变量。 这里给它们起的名字都仅仅用于解释方便。
and `_step_` are invisible variables. The names given here are only for convenience of explanation.
以数字形式返回给定索引处值的“长度”； 它等价于在 Lua 中调用 '`#`' 的操作 （参见 [§3.4.7](#3.4.7)）。 如果操作结果不是一个整数，则抛出一个错误。 （这种情况只发生在触发元方法时
Returns the "length" of the value at the given index as a number; it is equivalent to the operation of calling ''#'' in Lua (see [§ 3.4.7](#3.4.7)). If the result of the operation is not an integer, an error is thrown. (This only happens when the meta method is triggered.
以数字形式返回给定索引处值的“长度”； 它等价于在 Lua 中调用 ``#`` 的操作 （参见 [§3.4.7](#3.4.7)）。 如果操作结果不是一个整数，则抛出一个错误。 （这种情况只发生在触发元方法时
Returns the "length" of the value at the given index as a number; it is equivalent to the operation of calling ``#`` in Lua (see [§ 3.4.7](#3.4.7)). If the result of the operation is not an integer, an error is thrown. (This only happens when the meta method is triggered.
以下为合法的浮点常量
The following are legal floating-point constants
以栈顶的值作为错误对象，抛出一个 Lua 错误。 这个函数将做一次长跳转，所以一定不会返回 （参见
Throws a Lua error with the value at the top of the stack as the error object. This function will do a long jump, so it must not return (cf.
以整数形式返回 `s` 中 从位置 `i` 到 `j` 间（包括两端） 所有字符的编号。 默认的 `i` 为 1 ，默认的 `j` 为 `i`。 如果碰上不合法的字节序列，抛出一个错误。
Returns the number of all characters in `s` from position `I` to `j` (both ends inclusive) as an integer. The default `I` is 1 and the default `j` is `I`. If an illegal byte sequence is encountered, an error is thrown.
以字符串形式返回协程 `co` 的状态： 当协程正在运行（它就是调用 `status` 的那个） ，返回 `"running"`； 如果协程调用 `yield` 挂起或是还没有开始运行，返回 `"suspended"`； 如果协程是活动的，但并不在运行（即它正在延续其它协程），返回 `"normal"`； 如果协程运行完主体函数或因错误停止，返回
Return the status of the coroutine `co` in the form of a string: when the coroutine is running (it is the one that call` status`), return` "running" `; If the coroutine call` yield` pending or has not yet started running, return` "suspended" `; If the coroutine is active but not running (I .e. it is continuing other coroutines), return` "`normal"`; if the coroutine finishes running the body function or stops due to an error, returns
译者 [云风
Translator [Yun Feng
因为 Lua 中可能发生垃圾收集， 所以不保证 `lua_tolstring` 返回的指针， 在对应的值从堆栈中移除后依然有效。
Because of the possibility of garbage collection in Lua, there is no guarantee that the pointer returned by the lua_tolstring will still be valid after the corresponding value is removed from the stack.
因为有这样一个词法作用范围的规则， 局部变量可以被在它的作用范围内定义的函数自由使用。 当一个局部变量被内层的函数中使用的时候， 它被内层函数称作 _上值_，或是 _外部局部变量
Because there is such a lexical scoping rule, a local variable can be used freely by functions defined within its scope. When a local variable is used by the inner function, it is called the_upper value_, or_outer local variable by the inner function.
用 f() 的所有返回值创建一个列表
Create a list with all the return values of f()
用到的读取器函数， 每次它需要一块新的代码块的时候， [`lua_load`](#lua_load) 就调用读取器， 每次都会传入一个参数 `data` 。 读取器需要返回含有新的代码块的一块内存的指针， 并把 `size` 设为这块内存的大小。 内存块必须在下一次函数被调用之前一直存在。 读取器可以通过返回 `NULL` 或设 `size` 为 0 来指示代码块结束。 读取器可能返回多个块，每个块可以有任意的大于零的尺寸。
The reader function used, every time it needs a new block of code, [lua_load](#lua_load) calls the reader, passing in a parameter `data` each time `. The reader needs to return a pointer to a piece of memory containing the new code block and set `size` to the size of that piece of memory. The memory block must exist until the next function is called. The reader may indicate the end of the code block by returning `NULL` or setting `size` to 0. The reader may return multiple blocks, each of which may have an arbitrary size greater than zero.
用和初始化 Lua 路径 [`package.path`](#pdf-package.path) 相同的方式初始化 C 路径 [`package.cpath`](#pdf-package.cpath) 。 它会使用环境变量 `LUA_CPATH_5_3` 或 环境变量 `LUA_CPATH` 初始化。 要么就采用 `luaconf.h` 中定义的默认路径。
The C path [`package.cpath`](#pdf-package.path) is initialized in the same way as the Lua path [`package. pdf-package.cpath](#) is initialized. It is initialized with the environment variable LUA_CPATH_5_3 or the environment variable LUA_CPATH. Either take the default path defined in `luaconf.h.
用户数据必须以结构 `luaL_Stream` 开头； 此结构其后可以包含任何其它数据。 `f` 域指向一个 C 数据流 （如果它为 `NULL` 表示一个没有创建好的句柄）。 `closef` 域指向一个在关闭或回收该流时需要调用的 Lua 函数。 该函数将收到一个参数，即文件句柄。 它需要返回 **true**（操作成功）或 **nil** 加错误消息（出错的时候）。 一旦 Lua 调用过这个域，该域的值就会修改为 `NULL` 以提示这个句柄已经被关闭了。
User data must begin with the structure luaL_Stream; this structure can be followed by any other data. The `f` field points to a C data stream (if it is `NULL` it means an uncreated handle). The `closef` field points to a Lua function that needs to be called when the stream is closed or recycled. The function will receive one argument, the file handle. It needs to return **true** (the operation succeeded) or **nil** plus an error message (when an error occurs). Once Lua calls this field, the value of the field is changed to `NULL` to indicate that the handle has been closed.
用户数据是保留在 Lua 中的 C 值。 _轻量用户数据_ 表示一个指针 `void*`。 它是一个像数字一样的值： 你不需要专门创建它，它也没有独立的元表，而且也不会被收集（因为从来不需要创建）。 只要表示的 C 地址相同，两个轻量用户数据就相等。
The user data is the C value that is kept in Lua. _lightweight user data_represents a pointer `void * `. It is a value like a number: you don`t need to create it specifically, it doesn`t have a separate meta table, and it won`t be collected (because it never needs to be created). As long as the C addresses represented are the same, the two lightweight user data are equal.
用可变参数中的所有值创建一个列表
Create a list with all the values in the variable parameter
用零去填充 （[`string.unpack`](#pdf-string.unpack) 则忽略它
Padding with zeros ([`string.unpack`](#pdf-string.unpack) is ignored
用四个查找器函数初始化这张表。
Initialize this table with four finder functions.
用文件名调用它时，（以文本模式）来打开该名字的文件， 并将文件句柄设为默认输入文件。 如果用文件句柄去调用它， 就简单的将该句柄设为默认输入文件。 如果调用时不传参数，它返回当前的默认输入文件。
When it is called with a file name, it opens the file of that name (in text mode) and sets the file handle as the default input file. If you call it with a file handle, simply set the handle to the default input file. If called without passing parameters, it returns the current default input file.
用一个分离进程开启程序 `prog`， 返回的文件句柄可用于从这个程序中读取数据 （如果 `mode` 为 `"r"`，这是默认值） 或是向这个程序写入输入（当 `mode` 为 `"w"` 时
Start the program `prog` with a separate process, and the returned file handle can be used to read data from the program (if `mode` is `"r"`, which is the default) or write input to the program (when `mode` is `"w"`
用于 [`luaL_setfuncs`](#luaL_setfuncs) 注册函数的数组类型。 `name` 指函数名，`func` 是函数指针。 任何 [`luaL_Reg`](#luaL_Reg) 数组必须以一对 `name` 与 `func` 皆为 `NULL` 结束。
The array type used for the [luaL_setfuncs](#luaL_setfuncs) registration function. `name` is the function name, and `func` is the function pointer. Any [`luaL_Reg](#luaL_Reg) array must end with the pair `name` and `func` both being `NULL.
用于 [`require`](#pdf-require) 控制哪些模块已经被加载的表。 当你请求一个 `modname` 模块，且 `package.loaded[modname]` 不为假时， [`require`](#pdf-require) 简单返回储存在内的值。
A table used for [`require`](#pdf-require) to control which modules have been loaded. When you request a `modname` module and `package.loaded[modname]`is not false, [`require`](#pdf-require) simply returns the stored value.
用于 [`require`](#pdf-require) 控制如何加载模块的表。
Table for [`require`](#pdf-require) to control how modules are loaded.
用于 [`string.pack`](#pdf-string.pack)， [`string.packsize`](#pdf-string.packsize)， [`string.unpack`](#pdf-string.unpack) 的第一个参数。 它是一个描述了需要创建或读取的结构之布局。
The first argument for [`string.pack`](#pdf-string.pack), [`string.packsize`](#pdf-string.packsize), [`string.unpack`](#pdf-string.unpack). It is a layout that describes the structure that needs to be created or read.
用于传入传出无符号整数的函数 （`lua_pushunsigned`， `lua_tounsigned`， `lua_tounsignedx`， `luaL_checkunsigned`， `luaL_optunsigned`） 都废弃了。 直接从有符号版做类型转换。
Functions for passing in and out of unsigned integers (lua_pushunsigned, lua_tounsigned, lua_tounsignedx, luaL_checkunsigned, luaL_optunsigned) are deprecated. Do type conversions directly from the signed version.
用于调试的钩子函数类型。
The type of hook function used for debugging.
用于获取一个函数的信息时， 可以把这个函数压入堆栈， 然后把 `what` 字符串以字符 '`>`' 起头。 （这会让 `lua_getinfo` 从栈顶上弹出函数。） 例如，想知道函数 `f` 是在哪一行定义的， 你可以使用下列代码
When used to obtain information about a function, you can push the function onto the stack and then start the `what` string with the character ``>. (This will cause the lua_getinfo to pop the function from the top of the stack.) For example, to know on which line the function `f` is defined, you can use the following code
用于解释 `name` 域。 `namewhat` 的值可以是 `"global"`, `"local"`, `"method"`, `"field"`, `"upvalue"`, 或是 `""` （空串）。 这取决于函数怎样被调用。 （Lua 用空串表示其它选项都不符合
Used to interpret the `name` domain. The value of `namewhat` can be `"global"`, `"local"`, `"method"`, `"field"`, `"upvalue"`, or `""` (empty string). It depends on how the function is called. (Lua uses an empty string to indicate that other options do not match
用于精确匹配到一个 UTF-8 字节序列的模式（是一个字符串，并非函数）"`[\0-\x7F\xC2-\xF4][\x80-\xBF]*`" （参见 [§6.4.1](#6.4.1)）。 它假定处理的对象是一个合法的 UTF-8 字符串。
A pattern (is a string, not a function) for exact matching to a UTF-8 byte sequence "`[\0-\x7F\xC2-\xF4][\x80-\xBF]*`" (see [§ 6.4.1](#6.4.1)). It assumes that the object being processed is a legal UTF-8 string.
优先级
Priority
由于 Lua 是一门嵌入式扩展语言，其所有行为均源于宿主程序中 C 代码对某个 Lua 库函数的调用。 （单独使用 Lua 时，`lua` 程序就是宿主程序。） 所以，在编译或运行 Lua 代码块的过程中，无论何时发生错误， 控制权都返回给宿主，由宿主负责采取恰当的措施（比如打印错误消息
Since Lua is an embedded extension language, all its behaviors are derived from the call of a Lua library function by the C code in the host program. (When Lua is used alone, the `lua` program is the host program.) Therefore, in the process of compiling or running Lua code block, whenever an error occurs, control is returned to the host, which is responsible for taking appropriate measures (such as printing error messages
由于被回收的对象还需要被终结器使用， 该对象（以及仅能通过它访问到的其它对象）一定会被 Lua _复活_。 通常，复活是短暂的，对象所属内存会在下一个垃圾收集循环释放。 然后，若终结器又将对象保存去一些全局的地方 （例如：放在一个全局变量里），这次复活就持续生效了。 此外，如果在终结器中对一个正进入终结流程的对象再次做一次标记让它触发终结器， 只要这个对象在下个循环中依旧不可达，它的终结函数还会再调用一次。 无论是哪种情况， 对象所属内存仅在垃圾收集循环中该对象不可达且 没有被标记成需要触发终结器才会被释放。
Since the recycled object still needs to be used by the finalizer, the object (and other objects that can only be accessed through it) must be revived by Lua_. Usually, the resurrection is short-lived and the memory to which the object belongs is freed in the next garbage collection cycle. Then, if the finalizer saves the object in some global place (for example, in a global variable), the resurrection will continue to take effect. In addition, if an object that is entering the finalizer process is marked again in the finalizer to trigger the finalizer, its finalizer function will be called again as long as the object is still unreachable in the next loop. In either case, the memory to which the object belongs is released only if the object is unreachable during the garbage collection cycle and is not marked as needing to trigger the finalizer.
由于这个函数依赖 C 函数 `setlocale`， 它可能并非线程安全的。
Since this function relies on the C function `setlocale`, it may not be thread-safe.
有两种形式：一种是数字形式，另一种是通用形式。
There are two forms: one is digital form and the other is universal form.
有效索引_ 指引用栈内真实位置的索引； 即在 1 到栈顶之间的位置 （`1 ≤ abs(index) ≤ top`）。 通常，一个可能修改该位置的值的函数需要传入有效索引。
Valid index_refers to the index of the real position in the stack; that is, the position between 1 and the top of the stack (`1 ≤ abs(index) ≤ top`). Typically, a function that might modify the value at that location needs to pass in a valid index.
有效索引与可接受索引
Valid and Acceptable Indexes
又一个
yet another one
右移
Move Right
右移）操作。 行为和 "band" 操作类似。
right) operation. The behavior is similar to the "band" operation.
与 [`coroutine.create`](#pdf-coroutine.create) 类似， [`coroutine.wrap`](#pdf-coroutine.wrap) 函数也会创建一个协程。 不同之处在于，它不返回协程本身，而是返回一个函数。 调用这个函数将启动该协程。 传递给该函数的任何参数均当作 [`coroutine.resume`](#pdf-coroutine.resume) 的额外参数。 [`coroutine.wrap`](#pdf-coroutine.wrap) 返回 [`coroutine.resume`](#pdf-coroutine.resume) 的所有返回值，除了第一个返回值（布尔型的错误码）。 和 [`coroutine.resume`](#pdf-coroutine.resume) 不同， [`coroutine.wrap`](#pdf-coroutine.wrap) 不会捕获错误； 而是将任何错误都传播给调用者。
Similar to [`coroutine.create`](#pdf-coroutine.create), the [`coroutine.wrap`](#pdf-coroutine.wrap) function also creates a coroutine. The difference is that instead of returning the coroutine itself, it returns a function. Calling this function will start the coroutage. Any arguments passed to this function are treated as extra arguments to [`coroutine.resume`](#pdf-coroutine.resume). [`coroutine.wrap`](#pdf-coroutine.wrap) returns all the return values of [`coroutine.resume`](#pdf-coroutine.resume) except the first return value (boolean error code). Unlike [`coroutine.resume`](#pdf-coroutine.resume), [`coroutine. pdf-coroutine.wrap](# resume`) does not catch errors; instead, any errors are propagated to the caller.
与 `_var_` 都是不可见的变量。 这里给它们起的名字都只是为了解说方便。
Variables with `_var_` are invisible. The names given here are just for the convenience of explanation.
与其它的许多参考手册一样，这份文档有些地方比较枯燥。 关于 Lua 背后的设计思想， 可以看看 Lua 网站上提供的技术论文。 至于用 Lua 编程的细节介绍， 请参阅 Roberto 的书
Like many other reference manuals, this document is somewhat boring. For the design ideas behind Lua, take a look at the technical papers available on the Lua website. As for the details of programming with Lua, please refer to Roberto book
与之前版本不兼容的地方
Incompatibility with previous versions
语句
Statement
语句将程序的控制点转移到一个标签处。 由于句法上的原因， Lua 里的标签也被认为是语句
statement transfers the control point of the program to a label. For syntactic reasons, labels in Lua are also considered statements
语句块
statement block
语句块是一个语句序列，它们会按次序执行
A statement block is a sequence of statements that are executed in order
语言的变更
Change of language
语言的格式自由。 它会忽略语法元素（符记）间的空格（包括换行）和注释， 仅把它们看作为名字和关键字间的分割符。
The language format is free. It ignores spaces (including line breaks) and comments between syntax elements (symbols) and only sees them as a separator between names and keywords.
语言定义
Language Definition
语言对大小写敏感： `and` 是一个保留字，但 `And` 与 `AND` 则是两个不同的有效名字。 作为一个约定，程序应避免创建以下划线加一个或多个大写字母构成的名字 （例如
The language is case sensitive: `and` is a reserved word, but `And` and `AND` are two different valid names. As a convention, programs should avoid creating names that are underlined with one or more uppercase letters (e. g.
语言有词法作用范围。 变量的作用范围开始于声明它们之后的第一个语句段， 结束于包含这个声明的最内层语句块的最后一个非空语句。 看下面这些例子
Language has lexical scope. The scope of variables begins with the first statement segment after they are declared and ends with the last non-empty statement of the innermost statement block containing the declaration. Look at these examples below
元表及元方法
Meta Table and Meta Method
元表决定了一个对象在数学运算、位运算、比较、连接、 取长度、调用、索引时的行为。 元表还可以定义一个函数，当表对象或用户数据对象在垃圾回收 （参见[§2.5](#2.5)）时调用它。
Metatables determine the behavior of an object during mathematical operations, bit operations, comparisons, joins, lengths, calls, and indexes. A metatable can also define a function that is called when a table object or user data object is garbage collected (see [§ 2.5](#2.5)).
允许多重赋值。 因此，赋值的语法定义是等号左边放一个变量列表， 而等号右边放一个表达式列表。 两边的列表中的元素都用逗号间开
Multiple assignments are allowed. Thus, the syntactic definition of assignment is to put a list of variables to the left of the equal sign and a list of expressions to the right of the equal sign. The elements in both sides of the list are separated by commas.
允许可接受索引是为了避免对栈顶以外的查询时做额外的检查。 例如，C 函数可以直接查询传给它的第三个参数， 而不用先检查是不是有第三个参数， 即不需要检查 3 是不是一个有效索引。
Acceptable indexes are allowed to avoid additional checks for queries outside the top of the stack. For example, a C function can directly query the third parameter passed to it without first checking whether there is a third parameter, that is, there is no need to check whether 3 is a valid index.
运行程序来遍历表中的所有域。 第一个参数是要遍历的表，第二个参数是表中的某个键。 `next` 返回该键的下一个键及其关联的值。 如果用 **nil** 作为第二个参数调用 `next` 将返回初始键及其关联值。 当以最后一个键去调用，或是以 **nil** 调用一张空表时， `next` 返回 **nil**。 如果不提供第二个参数，将认为它就是 **nil**。 特别指出，你可以用 `next(t)` 来判断一张表是否是空的。
Run the program to traverse all the fields in the table. The first parameter is the table to be traversed, and the second parameter is a key in the table. `next` returns the next key of the key and its associated value. Calling `next` with **nil** as the second argument returns the initial key and its associated value. When called with the last key, or an empty table is called with **nil**, `next` returns **nil * *. If you do not provide the second argument, it will be considered to be **nil * *. In particular, you can use `next(t)`to determine whether a table is empty.
运行时错误。
Runtime error.
在 **repeat**–**until** 循环中， 内部语句块的结束点不是在 **until** 这个关键字处， 它还包括了其后的条件表达式。 因此，条件表达式中可以使用循环内部语句块中的定义的局部变量。
In the **repeat**-**until** loop, the end point of the inner statement block is not at the **until** keyword, which also includes the conditional expression that follows it. Therefore, local variables defined in the internal statement block of the loop can be used in conditional expressions.
在 `list` 的位置 `pos` 处插入元素 `value` ， 并后移元素 `list[pos], list[pos+1], ···, list[#list]` 。 `pos` 的默认值为 `#list+1` ， 因此调用 `table.insert(t,x)` 会将 `x` 插在列表 `t` 的末尾。
Insert the element`value` at the position `pos` of`list`, and move the element`list [pos], list[pos 1],..., list[#list]`backward`. The default value of `pos` is `#list 1`, so calling `table.insert(t,x)`will insert `x` at the end of the list`t.
在 C 函数内部，你可以通过调用 [`lua_error`](#lua_error) 来抛出错误。
Inside a C function, you can throw an error by calling [`lua_error`](#lua_error).
在 POSIX 系统上， 这个函数会以此文件名创建一个文件以回避安全风险。 （别人可能未经允许在获取到这个文件名到创建该文件之间的时刻创建此文件。） 你依旧需要在使用它的时候先打开，并最后删除（即使你没使用到
On POSIX systems, this function creates a file with this file name to avoid security risks. (Someone else may have created this file without permission at the time between getting the file name and creating the file.) You still need to open it first and delete it at last (even if you don't use it
在变量的首次赋值之前，变量的值均为
Before the first assignment of a variable, the value of the variable is
在遍历一张表的时候， 不要直接对键调用 [`lua_tolstring`](#lua_tolstring) ， 除非你知道这个键一定是一个字符串。 调用 [`lua_tolstring`](#lua_tolstring) 有可能改变给定索引位置的值； 这会对下一次调用 [`lua_next`](#lua_next) 造成影响。
When traversing a table, do not call [lua_tolstring](#lua_tolstring) directly on the key, unless you know that the key must be a string. The call to [lua_tolstring](#lua_tolstring) has the potential to change the value of a given index position; this will affect the next call to [lua_next](#lua_next).
在表内从 `list[1]` 到 `list[#list]` _原地_ 对其间元素按指定次序排序。 如果提供了 `comp` ， 它必须是一个可以接收两个列表内元素为参数的函数。 当第一个元素需要排在第二个元素之前时，返回真 （因此 `not comp(list[i+1],list[i])` 在排序结束后将为真）。 如果没有提供 `comp`， 将使用标准 Lua 操作 `<` 作为替代品。
Sorts elements from `list[1]`to `list[#list]` within a table in a specified order. If `comp` is provided, it must be a function that can receive two list elements as parameters. When the first element needs to be ranked before the second element, it returns true (so `not comp(list [I 1],list [I])`will be true after sorting). If `comp` is not provided, the standard Lua operation `<` will be used as an alternative.
在不触发任何元方法的情况下 返回对象 `v` 的长度。 `v` 可以是表或字符串。 它返回一个整数。
Returns the length of object `v` without triggering any meta-methods. `v` can be a table or a string. It returns an integer.
在不触发任何元方法的情况下 获取 `table[index]` 的值。 `table` 必须是一张表； `index` 可以是任何值。
Get the value of `table[index]`without triggering any meta-methods. `table` must be a table; `index` can be any value.
在不触发任何元方法的情况下 检查 `v1` 是否和 `v2` 相等。 返回一个布尔量。
Check if `v1` is equal to `v2` without triggering any meta-methods. Returns a Boolean quantity.
在不触发任何元方法的情况下 将 `table[index]` 设为 `value`。 `table` 必须是一张表， `index` 可以是 **nil** 与 NaN 之外的任何值。 `value` 可以是任何 Lua 值。
Set `table[index]`to `value` without triggering any meta-methods`. `table` must be a table, and `index` can be any value other than **nil** or NaN. `value` can be any Lua value.
在出错的情况下，函数抛出错误而不是返回错误码。
In the case of an error, the function throws an error instead of returning an error code.
在处理完选项后，`lua` 运行指定的 _脚本_。 如果不带参数调用， 在标准输入（`stdin`）是终端时，`lua` 的行为和 `lua -v -i` 相同。 否则相当于
After processing the options, `lua` runs the specified_script_. If called without parameters, `lua` behaves the same as `lua -v-I `when the standard input (`stdin`) is a terminal. otherwise equivalent
在错误消息和调试消息中（参见 [§4.9](#4.9)），用于代码块的名字。 如果不提供此参数，它默认为字符串`chunk` 。 `chunk` 不是字符串时，则为
In error messages and debug messages (see [§ 4.9](#4.9)), the name used for the code block. If this parameter is not supplied, it defaults to the string `chunk `. If `chunk` is not a string, otherwise
在发生错误的情况下， 堆栈没有展开， 因此你可以使用调试 API 来处理它。 错误消息放在栈顶。
In the event of an error, the stack is not unrolled, so you can use the debug API to handle it. The error message is placed at the top of the stack.
在非 POSIX 系统上， 由于这个函数依赖 C 函数 `gmtime` 和 `localtime`， 它可能并非线程安全的。
On non-POSIX systems, this function may not be thread-safe because it relies on the C functions `gmtime` and `localtime.
在给定线程中启动或延续一条协程
Start or continue a coroutation in a given thread
在交互模式下， Lua 不断的显示提示符，并等待下一行输入。 一旦读到一行， 首先试着把这行解释为一个表达式。 如果成功解释，就打印表达式的值。 否则，将这行解释为语句。 如果你写了一行未完成的语句， 解释器会用一个不同的提示符来等待你写完。
In interactive mode, Lua continuously displays the prompt and waits for the next line of input. Once you read a line, first try to interpret the line as an expression. If successfully interpreted, the value of the expression is printed. Otherwise, the line is interpreted as a statement. If you write an unfinished line, the interpreter will use a different prompt to wait for you to finish.
在解释器从一个函数中返回时调用。 钩子将于 Lua 离开函数之前的那一刻被调用。 没有标准方法来访问被函数返回的那些值。
Called when the interpreter returns from a function. The hook will be called at the moment before Lua leaves the function. There is no standard way to access the values returned by the function.
在解释器调用一个函数时被调用。 钩子将于 Lua 进入一个新函数后， 函数获取参数前被调用。
Called when the interpreter calls a function. The hook will be called after Lua enters a new function and before the function takes parameters.
在解释器每执行 `count` 条指令后被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生
Called after the interpreter executes every `count` instruction. (This event only occurs when Lua executes a Lua function
在解释器准备开始执行新的一行代码时， 或是跳转到这行代码中时（即使在同一行内跳转）被调用。 （这个事件仅仅在 Lua 执行一个 Lua 函数时发生
Called when the interpreter is ready to start executing a new line of code, or when jumping into this line of code (even if jumping within the same line). (This event only occurs when Lua executes a Lua function
在每次垃圾收集循环的最后阶段， 本次循环中检测到的需要被回收之对象， 其终结器的触发次序按当初给对象作需要触发终结器的标记之次序的逆序进行； 这就是说，第一个被调用的终结器是程序中最后一个被标记的对象所携的那个。 每个终结器的运行可能发生在执行常规代码过程中的任意一刻。
In the final stage of each garbage collection cycle, the triggering order of the finalizers of the objects detected in this cycle that need to be recycled is carried out in the reverse order of the order in which the objects were marked as needing to trigger the finalizers. That is to say, the first called finalizer is the one carried by the last marked object in the program. The operation of each finalizer may occur at any point during the execution of the regular code.
在内部实现中，Lua 使用了 C 的 `longjmp` 机制来处理错误。 （如果你使用 C++ 编译，Lua 将换成异常； 细节请在源代码中搜索 `LUAI_THROW`。） 当 Lua 碰到任何错误 （比如内存分配错误、类型错误、语法错误、还有运行时错误） 它都会 _抛出_一个错误出去； 也就是调用一次长跳转。 在 _保护环境_ 下， Lua 使用 `setjmp` 来设置一个恢复点； 任何发生的错误都会跳转到最近的一个恢复点。
In its internal implementation, Lua uses C`s `longjmp` mechanism to handle errors. (If you compile in C, Lua will replace it with an exception; search for `LUAI_THROW in the source code for details.) When Lua encounters any errors (such as memory allocation errors, type errors, syntax errors, and runtime errors) it will throw out an error; that is, call a long jump. In the_protected environment, Lua uses `setjmp` to set a recovery point; any errors that occur will jump to the nearest recovery point.
在启动时，Lua 用环境变量 `LUA_PATH_5_3` 或环境变量 `LUA_PATH` 来初始化这个变量。 或采用 `luaconf.h` 中的默认路径。 环境变量中出现的所有 "`;;`" 都会被替换成默认路径。
At startup, Lua initializes this variable with the environment variable LUA_PATH_5_3 or the environment variable LUA_PATH. Or take the default path in `luaconf.h. All occurrences of "`;;`" in the environment variable are replaced with the default path.
在搜索 C 加载器时处理版本号的方式有所变化。 现在，版本号应该跟在模块名后（其它大多数工具都是这样干的）。 出于兼容性考虑，如果使用新格式找不到加载器的话，搜索器依然会尝试旧格式。 （Lua 5.2 已经是这样处理了，但是并没有写在文档里
The way version numbers are handled when searching for the C loader has changed. Now, the version number should follow the module name (as most other tools do). For compatibility reasons, if the loader cannot be found using the new format, the searcher will still try the old format. (Lua 5.2 has already handled it this way, but it is not written in the document
在预编译时碰到语法错误
Syntax errors encountered during precompilation
在元表中事件的键值是一个双下划线（`__`）加事件名的字符串； 键关联的那些值被称为 _元方法_。 在上一个例子中，`__add` 就是键值， 对应的元方法是执行加操作的函数。
The key value of an event in the meta table is a string with a double underscore (`__`) plus the event name; those values associated with the key are called the_meta method_. In the previous example, `__add` is the key value, and the corresponding meta method is the function that performs the add operation.
在运行 `__gc` 元方法时出错了。 （这个错误和代码块加载过程无关，它是由垃圾收集器引发的
An error occurred while running the `__gc` meta-method. (This error has nothing to do with the code block loading process, it is caused by the garbage collector.
在运行 `__gc` 元方法时发生的错误。 （这个错误和被调用的函数无关
Error occurred while running the `__gc` meta-method. (This error has nothing to do with the function being called.
在运行错误处理函数时发生的错误。
The error that occurred when the error handling function was run.
在运行任何代码前， `lua` 会将所有命令行传入的参数放到一张全局表 `arg` 中。 脚本的名字放在索引 0 的地方， 脚本名后紧跟的第一个参数在索引 1 处，依次类推。 在脚本名前面的任何参数 （即解释器的名字以及各选项） 放在负索引处。 例如，调用
Before running any code, `lua` will put all the parameters passed in from the command line into a global table, `arg. The name of the script is placed at index 0, the first parameter immediately after the script name is at index 1, and so on. Any parameters that precede the script name (I. e., the name of the interpreter and options) are placed at the negative index. For example, calling
在运行完 _脚本_ 后进入交互模式
Enter interactive mode after running_script_
在栈上留下该模块的副本。
Leave a copy of the module on the stack.
在这本手册中， `-->` 指前面表达式的结果
In this manual, `-->` refers to the result of the previous expression
在这种情况下，所有的返回值都被舍弃。 函数调用在 [§3.4.10](#3.4.10) 中解释。
In this case, all return values are discarded. Function calls are explained in [§ 3.4.10](#3.4.10).
在指定 `path` 中搜索指定的
Searches the specified `path` for the specified
在转译那些自由名字时，`_ENV` 是否是那个外部的局部变量无所谓。 `_ENV` 和其它你可以使用的变量名没有区别。 这里特别指出，你可以定义一个新变量或指定一个参数叫这个名字。 当编译器在转译自由名字时所用到的 `_ENV` ， 指的是你的程序在那个点上可见的那个名为 \_ENV 的变量。 （Lua 的可见性规则参见
When translating those free names, it doesn`t matter whether `_ENV` is the external local variable. There is no difference between `_ENV` and other variable names you can use. In particular, you can define a new variable or specify a parameter by this name. The `_ENV` used by the compiler when translating free names refers to the variable named \_ENV that is visible to your program at that point. (Lua`s visibility rules see
在字符串 `s` 中找到第一个能用 `pattern` （参见 [§6.4.1](#6.4.1)）匹配到的部分。 如果能找到，`match` 返回其中的捕获物； 否则返回 **nil** 。 如果 `pattern` 中未指定捕获， 返回整个 `pattern` 捕获到的串。 第三个可选数字参数 `init` 指明从哪里开始搜索； 它默认为 1 且可以是负数。
Find the first part of the string `s` that can be matched with `pattern` (see [§ 6.4.1](#6.4.1)). If found, `match` returns the catch; otherwise, it returns **nil * *. If no capture is specified in `pattern`, the entire string captured by `pattern` is returned. The third optional numeric parameter `init` indicates where to start the search; it defaults to 1 and can be negative.
在字符串外的任何地方出现以双横线 (`--`) 开头的部分是 _注释_ 。 如果 `--` 后没有紧跟着一个开大括号， 该注释为 _短注释_， 注释到当前行末截至。 否则，这是一段 _长注释_ ， 注释区一直维持到对应的闭长括号。 长注释通常用于临时屏蔽掉一大段代码。
A portion beginning with a double-bar (`--`) that appears anywhere outside the string is_comment_. If `--` is not followed by an open brace, the comment is_short comment_, and the comment ends at the end of the current line. Otherwise, this is a_long comment_, and the comment area is maintained until the corresponding closed bracket. Long comments are often used to temporarily mask out large sections of code.
在遵循 [Lua license](http://www.lua.org/license.html) 条款下，可自由使用。
It can be used freely under the terms of [Lua license](http://www.lua.org/license.html).
在作赋值操作之前， 那值列表会被 _调整_ 为左边变量列表的个数。 如果值比需要的更多的话，多余的值就被扔掉。 如果值的数量不够需求， 将会按所需扩展若干个 **nil**。 如果表达式列表以一个函数调用结束， 这个函数所返回的所有值都会在调整操作之前被置入值列表中 （除非这个函数调用被用括号括了起来；参见
Before the assignment operation, the value list will be adjusted to the number of variables on the left. If there are more values than needed, the extra values are thrown away. If the number of values is not enough, it will be expanded as many **nil** as needed * *. If the expression list ends with a function call, all values returned by the function will be placed in the value list before the adjustment operation (unless the function call is enclosed in parentheses; see
栈
Stack
栈大小
Stack Size
长度加内容的字符串，其长度编码为一个 `n` 字节（默认是个 `size_t`） 长的无符号整数。
The length plus content string is encoded as an unsigned integer of `n` bytes (by default, `size_t `).
这等价于代码
This is equivalent to code
这个变量仅仅是对真正那张表的引用； 改变这个值并不会改变 [`require`](#pdf-require) 使用的表。
This variable is only a reference to the actual table; changing this value does not change the table used by [`require`](#pdf-require).
这个部分描述了 Lua 的 C API ， 也就是宿主程序跟 Lua 通讯用的一组 C 函数。 所有的 API 函数按相关的类型以及常量都声明在头文件 `lua.h` 中。
This section describes Lua`s C API, a set of C functions that the host program uses to communicate with Lua. All API functions are declared in the header file `lua.h` with their associated types and constants.
这个参数可以赋予代码块一个名字， 这个名字被用于出错信息和调试信息（参见
This parameter can be given a name to the code block, which is used for error information and debugging information (see.
这个差别只在函数体内需要引用 `f` 时才有
This difference only exists when the function body needs to reference `f`
这个迭代器也会考虑元方法，而 `__ipairs` 元方法被废弃了。
This iterator will also consider the meta-method, and the `__ipairs` meta-method is discarded.
这个函数出错会返回 0 （例如，`what` 中有一个无效选项
This function error will return 0 (for example, there is an invalid option in `what`
这个函数的行为和 [`lua_call`](#lua_call) 完全一致，只不过它还允许被调用的函数让出 （参见
The behavior of this function is exactly the same as [lua_call](#lua_call), except that it also allows the called function to give up (cf.
这个函数的行为和 [`lua_pcall`](#lua_pcall) 完全一致，只不过它还允许被调用的函数让出 （参见
The behavior of this function is exactly the same as [lua_pcall](#lua_pcall), except that it also allows the called function to give up (cf.
这个函数等价于 ISO C 函数 `system`。 它调用系统解释器执行 `command`。 如果命令成功运行完毕，第一个返回值就是 **true**， 否则是 **nil**。 在第一个返回值之后，函数返回一个字符串加一个数字。如下
This function is equivalent to the ISO C function `system `. It calls the system interpreter to execute `command `. If the command runs successfully, the first return value is **true**, otherwise it is **nil * *. After the first return value, the function returns a string plus a number. as follows
这个函数等价于调用 [`lua_yieldk`](#lua_yieldk)， 不同的是不提供延续函数（参见 [§4.7](#4.7)）。 因此，当线程被延续，线程会继续运行调用 `lua_yield` 函数的函数。
This function is equivalent to calling [lua_yieldk](#lua_yieldk), except that the continuation function is not provided (see [§ 4.7](#4.7)). Therefore, when the thread is extended, the thread will continue to run the function that called the lua_yield function.
这个函数返回
This function returns
这个函数分配一块指定大小的内存块， 把内存块地址作为一个完全用户数据压栈， 并返回这个地址。 宿主程序可以随意使用这块内存。
This function allocates a memory block of the specified size, uses the memory block address as a full user data stack, and returns this address. The host program is free to use this memory.
这个函数根据其参数 `what` 发起几种不同的任务
This function initiates several different tasks depending on its parameter `what`
这个函数和 [`lua_load`](#lua_load) 返回值相同。 `name` 作为代码块的名字，用于调试信息和错误消息。 `mode` 字符串的作用同函数
This function returns the same value as [lua_load](#lua_load). `name` is the name of the code block used for debugging information and error messages. The role of the `mode` string is the same as that of the function
这个函数和 [`pcall`](#pdf-pcall) 类似。 不过它可以额外设置一个消息处理器
This function is similar to [`pcall`](#pdf-pcall). However, it can set up an additional message processor.
这个函数和系统有关，不是所有的平台都提供。
This function is related to the system and is not available on all platforms.
这个函数会从 `from` 的栈上弹出 `n` 个值， 然后把它们压入 `to` 的栈上。
This function pops `n` values from the `from` stack and pushes them onto the `to` stack.
这个函数会弹出堆栈上的键，把结果放在栈上相同位置。 和在 Lua 中一样， 这个函数可能触发对应 "index" 事件的元方法 （参见
This function pops the key on the stack and puts the result in the same position on the stack. As in Lua, this function may trigger a meta-method corresponding to the "index" event (see
这个函数会将键和值都弹出栈。 跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法 （参见
This function pops both the key and the value on the stack. As in Lua, this function may trigger a meta-method for a "newindex" event (see
这个函数会将值弹出栈。 赋值是直接的；即不会触发元方法。
This function will pop the value off the stack. The assignment is straightforward; that is, the meta-method is not triggered.
这个函数假定 `s` 是一个合法的 UTF-8 字符串。
This function assumes that `s` is a legal UTF-8 string.
这个函数将 `value` 赋给 栈上第 `level` 层函数的第 `local` 个局部变量。 如果没有那个变量，函数返回 **nil** 。 如果 `level` 越界，抛出一个错误。 （你可以调用 [`debug.getinfo`](#pdf-debug.getinfo) 来检查层次是否合法。） 否则，它返回局部变量的名字。
This function assigns `value` to the `local` local variable of the `level` level function on the stack. If there is no such variable, the function returns **nil * *. If `level` is out of bounds, an error is thrown. (You can call [`debug.getinfo`](#pdf-debug.getinfo) to check if the hierarchy is legal.) Otherwise, it returns the name of the local variable.
这个函数将 `value` 设为函数 `f` 的第 `up` 个上值。 如果函数没有那个上值，返回 **nil** 否则，返回该上值的名字。
This function sets `value` to the `up` top value of function `f. If the function does not have that upper value, return **nil** otherwise, return the name of the upper value.
这个函数将把这个值弹出栈。 跟在 Lua 中一样，这个函数可能触发一个 "newindex" 事件的元方法 （参见
This function will pop this value off the stack. As in Lua, this function may trigger a meta-method for a "newindex" event (see
这个函数使用 [`lua_tolstring`](#lua_tolstring) 来获取结果。 所以该函数有可能引发的转换都同样有效。
This function uses [lua_tolstring](#lua_tolstring) to get the result. So the function has the potential to cause conversions that are equally valid.
这个函数是操作字符串缓存的函数中，唯一一个会（且必须）在栈上放置额外元素的。 这个元素将被加入缓存。
This function is the only one that manipulates the string cache that will (and must) put extra elements on the stack. This element will be added to the cache.
这个函数是对 C 提供的位随机数函数的封装。 对其统计属性不作担保。
This function is an encapsulation of the bit random number function provided by C. There is no guarantee of its statistical properties.
这个函数是垃圾收集器的通用接口。 通过参数 `opt` 它提供了一组不同的功能
This function is a common interface to the garbage collector. With the parameter `opt` it provides a different set of functions
这个函数通常用于将字符串映射为 C 枚举量。 （在 Lua 库中做这个转换可以让其使用字符串，而不是数字来做一些选项
This function is typically used to map strings to C enumerations. (Doing this conversion in the Lua library allows it to use strings instead of numbers to do some options.
这个函数通常只用于调试信息。
This function is usually only used for debugging information.
这个函数永远不会返回。
This function never returns.
这个函数永远不会返回。 但是在 C 函数中通常遵循惯用法
This function never returns. But in C functions the idiom is usually followed
这个函数用于构建错误消息的前缀。
This function is used to construct the prefix of the error message.
这个函数用于生成标准库中和进程相关函数的返回值。 （指 [`os.execute`](#pdf-os.execute) 和
This function is used to generate the return values of standard library and process-related functions. (referring to [`OS. execute`](#pdf-os.execute) and
这个函数用于生成标准库中和文件相关的函数的返回值。 （指 ([`io.open`](#pdf-io.open)， [`os.rename`](#pdf-os.rename)， [`file:seek`](#pdf-file:seek)，等
This function is used to generate the return values of file-related functions in the standard library. (refers to ([`io.open`](#pdf-io.open), [`OS. rename`](#pdf-os.rename), [`file:seek`](#pdf-file:seek), etc.
这个函数用正在运行中的指定层次处函数的 _活动记录_ 来填写 [`lua_Debug`](#lua_Debug) 结构的一部分。 0 层表示当前运行的函数， _n+1_ 层的函数就是调用第 _n_ 层 （尾调用例外，它不算在栈层次中） 函数的那一个。 如果没有错误， [`lua_getstack`](#lua_getstack) 返回 1 ； 当调用传入的层次大于堆栈深度的时候，返回
This function fills in part of the [lua_Debug](#lua_Debug) structure with the_activity record_of the function at the specified level that is running. Layer 0 represents the currently running function, and the function on the_n 1_layer is the one that calls the function on the_n_layer (except for the tail call, which is not included in the stack level). If there are no errors, [lua_getstack](#lua_getstack) returns 1; when the level passed in by the call is greater than the stack depth, it returns
这个函数用字符串 `mode` 指定的模式打开一个文件。 返回新的文件句柄。 当出错时，返回 **nil** 加错误消息。
This function opens a file in the mode specified by the string `mode. Returns the new file handle. When an error occurs, returns **nil** plus an error message.
这个函数在标准 C 中不支持。 因此，它只在部分平台有效 （ Windows ，Linux ，Mac OS X, Solaris, BSD, 加上支持 `dlfcn` 标准的 Unix 系统
This function is not supported in standard C. Therefore, it is only valid on some platforms (Windows ,Linux ,Mac OS X, Solaris, BSD, plus Unix systems that support the` dlfcn` standard
这个宏等价于 [`lua_pushstring`](#lua_pushstring)， 区别仅在于只能在 `s` 是一个字面量时才能用它。 它会自动给出字符串的长度。
This macro is equivalent to [lua_pushstring](#lua_pushstring), except that it can only be used if `s` is a literal. It will automatically give the length of the string.
这个结构的指针必须作为第一个参数传递给每一个库函数。 [`lua_newstate`](#lua_newstate) 是一个例外， 这个函数会从头创建一个 Lua 状态机。
A pointer to this structure must be passed as the first argument to every library function. The exception is [lua_newstate](#lua_newstate), which creates a Lua state machine from scratch.
这个库都通过表 `os` 实现。
This library is implemented through the table `OS.
这个库里的所有函数都提供在表 `debug` 内。 所有操作线程的函数，可选的第一个参数都是针对的线程。 默认值永远是当前线程。
All functions in this library are provided in the table `debug. For all functions that operate on threads, the optional first parameter is for the thread. The default value is always the current thread.
这个库提供了 Lua 程序调试接口（[§4.9](#4.9)）的功能。 其中一些函数违反了 Lua 代码的基本假定 （例如，不会从函数之外访问函数的局部变量； 用户数据的元表不会被 Lua 代码修改； Lua 程序不会崩溃）， 因此它们有可能危害到其它代码的安全性。 此外，库里的一些函数可能运行的很慢。
This library provides the functionality of the Lua program debugging interface ([§ 4.9](#4.9)). Some of these functions violate the basic assumptions of Lua code (for example, local variables of functions are not accessed from outside the function; meta tables of user data are not modified by Lua code; Lua programs do not crash), so they may compromise the security of other code. In addition, some functions in the library may run very slowly.
这个库提供了表处理的通用函数。 所有函数都放在表 `table` 中。
This library provides generic functions for table processing. All functions are placed in the table `table.
这个库提供了对 UTF-8 编码的基础支持。 所有的函数都放在表 `utf8` 中。 此库不提供除编码处理之外的任何 Unicode 支持。 所有需要了解字符含义的操作，比如字符分类，都不在此范畴。
This library provides basic support for UTF-8 coding. All functions are placed in the table `utf8. This library does not provide any Unicode support other than encoding processing. All operations that require understanding the meaning of characters, such as character classification, are not in this category.
这个库提供了基本的数学函数。 所以函数都放在表 `math` 中。 注解有 "`integer/float`" 的函数会对整数参数返回整数结果， 对浮点（或混合）参数返回浮点结果。 圆整函数（[`math.ceil`](#pdf-math.ceil), [`math.floor`](#pdf-math.floor), [`math.modf`](#pdf-math.modf)） 在结果在整数范围内时返回整数，否则返回浮点数。
This library provides basic math functions. So the functions are all placed in the table `math. Functions annotated with "`integer/float`" return integer results for integer arguments and floating-point results for floating-point (or mixed) arguments. The Circle Entire functions ([`math.ceil`](#pdf-math.ceil), [`math.floor`](#pdf-math.floor), [`math.modf`](#pdf-math.modf)) return an integer if the result is within an integer range, otherwise it returns a floating point number.
这个库提供了字符串处理的通用函数。 例如字符串查找、子串、模式匹配等。 当在 Lua 中对字符串做索引时，第一个字符从 1 开始计算（而不是 C 里的 0 ）。 索引可以是负数，它指从字符串末尾反向解析。 即，最后一个字符在 -1 位置处，等等。
This library provides generic functions for string processing. For example, string lookup, substring, pattern matching, etc. When indexing strings in Lua, the first character is counted from 1 (not 0 in C). The index can be a negative number, which refers to the reverse parsing from the end of the string. That is, the last character is at the -1 position, and so on.
这个路径被 [`require`](#pdf-require) 在 C 加载器中做搜索时用到。
This path is used by [`require`](#pdf-require) when doing a search in the C loader.
这个路径被 [`require`](#pdf-require) 在 Lua 加载器中做搜索时用到。
This path is used by [`require`](#pdf-require) when searching in the Lua loader.
这个唯一标识符可以让程序检查两个不同的闭包是否共享了上值。 若 Lua 闭包之间共享的是同一个上值 （即指向一个外部局部变量），会返回相同的标识符。
This unique identifier allows the program to check whether two different closures share the upper value. If Lua closures share the same up value (that is, point to an external local variable), the same identifier is returned.
这个循环创建了十个闭包（这指十个匿名函数的实例）。 这些闭包中的每一个都使用了不同的 `y` 变量， 而它们又共享了同一份
This loop creates ten closures (this means ten instances of anonymous functions). Each of these closures uses a different `y` variable, and they share the same
这个转换非常的受限。 不支持符号、宽度、精度。 转换符只支持 '`%%`' （插入一个字符 '`%`'）， '`%s`' （插入一个带零终止符的字符串，没有长度限制）, '`%f`' （插入一个 [`lua_Number`](#lua_Number)）， '`%I`' （插入一个 [`lua_Integer`](#lua_Integer)）， '`%p`' （插入一个指针或是一个十六进制数）， '`%d`' （插入一个 `int`）， '`%c`' （插入一个用 `int` 表示的单字节字符），以及 '`%U`' （插入一个用 `long int` 表示的 UTF-8 字
This conversion is very limited. Symbol, width, precision are not supported. The converter only supports ''%%'(insert a character'%'), '%s' (insert a string with zero terminator, no length limit), '%f' (insert a [' lua_Number](#lua_Number)), '%I' (insert a ['lua_Integer](#lua_Integer)), '%p' (insert a pointer or a hexadecimal number), ''%d'' (inserts an 'int'), ''%c'' (inserts a single-byte character denoted by 'int'), and ''%U'' (inserts a UTF-8 word denoted by 'long int'
这个转换非常的受限。 不支持符号、宽度、精度。 转换符只支持 ``%%`` （插入一个字符 ``%``）， ``%s`` （插入一个带零终止符的字符串，没有长度限制）, ``%f`` （插入一个 [`lua_Number`](#lua_Number)）， ``%I`` （插入一个 [`lua_Integer`](#lua_Integer)）， ``%p`` （插入一个指针或是一个十六进制数）， ``%d`` （插入一个 `int`）， ``%c`` （插入一个用 `int` 表示的单字节字符），以及 ``%U`` （插入一个用 `long int` 表示的 UTF-8 字
This conversion is very limited. Symbol, width, precision are not supported. The converter only supports ``%%`(insert a character`%`), `%s` (insert a string with zero terminator, no length limit), `%f` (insert a [` lua_Number](#lua_Number)), `%I` (insert a [`lua_Integer](#lua_Integer)), `%p` (insert a pointer or a hexadecimal number), ``%d`` (inserts an `int`), ``%c`` (inserts a single-byte character denoted by `int`), and ``%U`` (inserts a UTF-8 word denoted by `long int`
这里 _x_ 不能是 _魔法字符_ `^$()%.[]*+-?` 中的一员） 表示字符 _x_ 自身。
Here_x_cannot be a member of the_magic character_`^$()%.[]* +-?`) represents the character_x_itself.
这里按字母次序列出了所有 C API 中的函数和类型。 每个函数都有一个这样的提示
Here is an alphabetical list of all the functions and types in the C API. Each function has a hint like this
这里的 _n_ 可以从 1 到 9； 这个条目匹配一个等于 _n_ 号捕获物（后面有描述）的子串。
The_n_here can be from 1 to 9; this entry matches a substring equal to the_n_catch (described later).
这里的 _x_ 和 _y_ 是两个明确的字符； 这个条目匹配以 _x_ 开始 _y_ 结束， 且其中 _x_ 和 _y_ 保持 _平衡_ 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 _x_ 就 _+1_ ，读到一个 _y_ 就 _\-1_， 最终结束处的那个 _y_ 是第一个记数到 0 的 _y_。 举个例子，条目 `%b()` 可以匹配到括号平衡的表达式。
Here_x_and_y_are two explicit characters; this entry matches a string that starts with_x_and ends with_y_, and where_x_and_y_remain_balanced. This means that if you read this string from left to right, every time you read a_x_, you_+1_, and when you read a_y_, you_\-1_, and the_y_at the end is the first_y_that counts to 0_. For example, the entry `% B ()` can be matched to a parenthetically balanced expression.
这里的 _x_ 是任意非字母或数字的字符） 表示字符 _x_。 这是对魔法字符转义的标准方法。 所有非字母或数字的字符 （包括所有标点，也包括非魔法字符） 都可以用前置一个 '`%`' 放在模式串中表示自身。
Here_x_is any non-alphabetic or numeric character) represents the character_x_. This is the standard method for escaping magic characters. All non-alphabetic or numeric characters (including all punctuation marks and also non-magic characters) can represent themselves by being preceded by a '%' in the pattern string.
这里的 _x_ 是任意非字母或数字的字符） 表示字符 _x_。 这是对魔法字符转义的标准方法。 所有非字母或数字的字符 （包括所有标点，也包括非魔法字符） 都可以用前置一个 ``%`` 放在模式串中表示自身。
Here_x_is any non-alphabetic or numeric character) represents the character_x_. This is the standard method for escaping magic characters. All non-alphabetic or numeric characters (including all punctuation marks and also non-magic characters) can represent themselves by being preceded by a `%` in the pattern string.
这里是 C 里的代码
Here is the code in C.
这里我们按字母表次序列出了辅助库中的所有函数和类型。
Here we have listed all the functions and types in the auxiliary library in alphabetized order.
这里我们列出了把程序从 Lua 5.2 迁移到 Lua 5.3 会碰到的不兼容的地方。 你可以在编译 Lua 时定义一些恰当的选项（参见文件 `luaconf.h`）， 来回避一些不兼容性。 然而，这些兼容选项以后会移除。
Here we list the incompatibilities that you will encounter when migrating a program from Lua 5.2 to Lua 5.3. You can circumvent some incompatibilities by defining appropriate options when compiling Lua (see the file `luaconf.h`). However, these compatibility options will be removed later.
这里有一个简单的分配器函数的实现。 这个实现被放在补充库中，供 [`luaL_newstate`](#luaL_newstate) 使用。
Here is a simple implementation of the allocator function. This implementation is placed in the supplemental library for use by [luaL_newstate](#luaL_newstate).
这里有一些例子
Here are some examples
这里有一些用例
Here are some use cases
这两种情况都会把最终的注册表中关联 `tname` 的值压栈。
Both cases will stack the value associated with `tname` in the final registry.
这是一份采用扩展 BNF 描述的 Lua 完整语法。 在扩展 BNF 中， {A} 表示 0 或多个 A ， \[A\] 表示一个可选的 A 。 （操作符优先级，参见 [§3.4.8](#3.4.8)； 对于最终符号，名字，数字，字符串字面量的解释，参见
This is the complete syntax of Lua using the extended BNF description. In an extended BNF, {A} represents zero or more A's, and \[A\] represents an optional A. (Operator precedence, see [§ 3.4.8](#3.4.8); for an explanation of final symbols, names, numbers, string literals, see
这是一个低阶函数。 它完全绕过了包模块系统。 和 [`require`](#pdf-require) 不同， 它不会做任何路径查询，也不会自动加扩展名。 `libname` 必须是一个 C 库需要的完整的文件名，如果有必要，需要提供路径和扩展名。 `funcname` 必须是 C 库需要的准确名字 （这取决于使用的 C 编译器和链接器
This is a low-order function. It completely bypasses the package module system. Unlike [`require`](#pdf-require), it does not do any path lookup and does not automatically add an extension. `libname` must be the full filename required by a C library, providing the path and extension if necessary. `funcname` must be the exact name required by the C library (depending on the C compiler and linker used
这是一个携带有有关函数或活动记录的各种信息的结构。 [`lua_getstack`](#lua_getstack) 只会填充结构的私有部分供后面使用。 调用 [`lua_getinfo`](#lua_getinfo) 可以在 [`lua_Debug`](#lua_Debug) 中填充那些可被使用的信息域。
This is a structure that carries various information about a function or activity record. [`lua_getstack](#lua_getstack) will only populate the private part of the structure for later use. Calling [lua_getinfo](#lua_getinfo) fills in [lua_Debug](#lua_Debug) those information fields that can be used.
这些操作的结果不是 **false** 就是
The result of these operations is either **false** or
这些控制结构符合通常的意义，而且也有类似的语法
These control structures conform to the usual meaning, and there is a similar syntax
这些唯一标识符可用于检测不同的闭包是否共享了相同的上值。 共享同一个上值的 Lua 闭包（即它们指的同一个外部局部变量） 会针对这个上值返回相同的标识。
These unique identifiers can be used to detect whether different closures share the same upper value. Lua closures that share the same upper value (that is, they refer to the same external local variable) will return the same identity for this upper value.
这样的 **for** 语句
Such a **for** statement
这样的调用形式将触发一次 _尾调用_。 Lua 实现了 _完全尾调用_（或称为 _完全尾递归_）： 在尾调用中， 被调用的函数重用调用它的函数的堆栈项。 因此，对于程序执行的嵌套尾调用的层数是没有限制的。 然而，尾调用将删除调用它的函数的任何调试信息。 注意，尾调用只发生在特定的语法下， 仅当 **return** 只有单一函数调用作为参数时才发生尾调用； 这种语法使得调用函数的所有结果可以完整地返回。 因此，下面这些例子都不是尾调用
Such a call form will trigger a_tail call_. Lua implements_full tail call_(or_full tail recursion_): In a tail call, the called function reuses the stack items of the calling function. Thus, there is no limit to the number of layers of nested tail calls that a program executes. However, the tail call will remove any debug information for the function that called it. Note that tail calls only occur under a specific syntax, only if **return** has only a single function call as an argument; this syntax allows all results of the calling function to be returned in its entirety. Therefore, the following examples are not tail calls.
这样的形式
such a form
这一章描述了 Lua 的词法、语法和句法。 换句话说，本章描述哪些符记是有效的， 它们如何被组合起来，这些组合方式有什么含义。
This chapter describes the lexical, grammatical and syntactic aspects of Lua. In other words, this chapter describes which symbols are valid, how they are combined, and what these combinations mean.
这张表内的每一项都是一个 _查找器函数_。 当查找一个模块时， [`require`](#pdf-require) 按次序调用这些查找器， 并传入模块名（[`require`](#pdf-require) 的参数）作为唯一的一个参数。 此函数可以返回另一个函数（模块的 _加载器_）加上另一个将传递给这个加载器的参数。 或是返回一个描述为何没有找到这个模块的字符串 （或是返回 **nil** 什么也不想说
Each item in this table is a_finder function_. When looking up a module, [`require`](#pdf-require) calls these finder in order, passing in the module name (an argument to the [`require`](#pdf-require)) as the only argument. This function can return another function (the module`s_loader_) plus another argument that will be passed to this loader. Or return a string describing why the module was not found (or return **nil** and don`t want to say anything
这张表是这样的
This table is like this
这种语法只是一个语法糖，用来表示
This syntax is just a syntactic sugar used to represent
针对栈顶的对象，创建并返回一个在索引 `t` 指向的表中的 _引用_ （最后会弹出栈顶对象
For the object at the top of the stack, create and return a_reference_in the table pointed to by the index` t` (the top of the stack object will be popped up at the end
正常的线程状态是 0 （[`LUA_OK`](#pdf-LUA_OK)）。 当线程用 [`lua_resume`](#lua_resume) 执行完毕并抛出了一个错误时， 状态值是错误码。 如果线程被挂起，状态为
The normal thread state is 0 ([`LUA_OK `](#pdf-LUA_ OK)). The status value is the error code when the thread finishes execution with [lua_resume](#lua_resume) and throws an error. If the thread is suspended, the status is
支持
Support
支持 _空语句_， 你可以用分号分割语句，也可以以分号开始一个语句块， 或是连着写两个分号
Support_empty statement_, you can use semicolon to divide the statement, you can also start a statement block with semicolon, or write two semicolon in succession
支持所有与 Pascal 或是 C 类似的常见形式的语句， 这个集合包括赋值，控制结构，函数调用，还有变量声明。
All common forms of statements similar to Pascal or C are supported. This collection includes assignments, control structures, function calls, and variable declarations.
支持下列比较操作符
The following comparison operators are supported
支持下列数学运算操作符
The following mathematical operators are supported
支持下列位操作符
The following bit operators are supported
支持协程，也叫 _协同式多线程_。 一个协程在 Lua 中代表了一段独立的执行线程。 然而，与多线程系统中的线程的区别在于， 协程仅在显式调用一个让出（yield）函数时才挂起当前的执行。
Support coroutation, also called_collaborative multithreading_. A coroutine in Lua represents a separate thread of execution. However, unlike threads in multi-threaded systems, a coroutine suspends current execution only when a yield function is explicitly called.
执行一段字符串
Execute a string
值必须是下列常量中的一个
value must be one of the following constants
值与类型
Value and Type
只会被计算一次。 它返回三个值， 一个 _迭代器_ 函数， 一个 _状态_， 一个 _迭代器的初始值
It will only be counted once. It returns three values, an_iterator_function, an_state_, and the initial value of the_iterator.
只能被写在一个语句块的最后一句。 如果你真的需要从语句块的中间 **return**， 你可以使用显式的定义一个内部语句块， 一般写作 `do return end`。 可以这样写是因为现在 **return** 成了（内部）语句块的最后一句了。
Can only be written in the last sentence of a statement block. If you really need to return from the middle of the statement block, you can use an explicit definition of an inner statement block, generally written `do return end `. It can be written like this because now **return** is the last sentence of the (internal) statement block.
只有那些有显式构造过程的对象才会从弱表中移除。 值，例如数字和轻量 C 函数，不受垃圾收集器管辖， 因此不会从弱表中移除 （除非它们的关联项被回收）。 虽然字符串受垃圾回收器管辖， 但它们没有显式的构造过程，所以也不会从弱表中移除。
Only those objects that have an explicit construction process are removed from the weak table. Values, such as numbers and lightweight C functions, are not governed by the garbage collector and therefore are not removed from the weak table (unless their associated items are recycled). Although strings are governed by the garbage collector, they do not have an explicit construction process, so they are not removed from the weak table.
只有有可能，你更应该使用 [`io.tmpfile`](#pdf-io.tmpfile)， 因为该文件可以在程序结束时自动删除。
Only possibly, you should use [`io.tmpfile`](#pdf-io.tmpfile) because the file can be automatically deleted at the end of the program.
只有字符串 `what` 中有描述要填充哪些项， 返回的表可以包含 [`lua_getinfo`](#lua_getinfo) 能返回的所有项。 `what` 默认是返回提供的除合法行号表外的所有信息。 对于选项 '`f`' ，会在可能的情况下，增加 `func` 域保存函数自身。 对于选项 '`L`' ，会在可能的情况下，增加 `activelines` 域保存合法行号表。
Only if the string 'what' has a description of which items to populate, the returned table can contain all the items that [lua_getinfo](#lua_getinfo) can return. By default, 'what' returns all the information provided except the table of legal row numbers. For option ''f'', the 'func' field is added to save the function itself, if possible. For option ''L'', the 'activelines' field is added to hold the table of legal line numbers, if possible.
只有字符串 `what` 中有描述要填充哪些项， 返回的表可以包含 [`lua_getinfo`](#lua_getinfo) 能返回的所有项。 `what` 默认是返回提供的除合法行号表外的所有信息。 对于选项 ``f`` ，会在可能的情况下，增加 `func` 域保存函数自身。 对于选项 ``L`` ，会在可能的情况下，增加 `activelines` 域保存合法行号表。
Only if the string `what` has a description of which items to populate, the returned table can contain all the items that [lua_getinfo](#lua_getinfo) can return. By default, `what` returns all the information provided except the table of legal row numbers. For option ``f``, the `func` field is added to save the function itself, if possible. For option ``L``, the `activelines` field is added to hold the table of legal line numbers, if possible.
指 _边境模式_； 这个条目会匹配到一个位于 _set_ 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 _set_ 。 集合 _set_ 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 '`\0`' 一样。
Refers to the_border pattern_; This entry will match an empty string before a character in_set_, and the previous character in this position does not belong to_set_. The meaning of set_set_is as described earlier. The start and end points of the matched empty string are calculated as if there is a character '\0' there.
指 _边境模式_； 这个条目会匹配到一个位于 _set_ 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 _set_ 。 集合 _set_ 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ``\0`` 一样。
Refers to the_border pattern_; This entry will match an empty string before a character in_set_, and the previous character in this position does not belong to_set_. The meaning of set_set_is as described earlier. The start and end points of the matched empty string are calculated as if there is a character `\0` there.
中操作符的优先级写在下表中，从低到高优先级排序
The priorities of the operators in are written in the following table, sorted from low to high priority.
中的 _名字_ （也被称为 _标识符_） 可以是由非数字打头的任意字母下划线和数字构成的字符串。 标识符可用于对变量、表的域、以及标签命名。
The_name_(also known as_identifier_) in can be a string consisting of any letter underscore and number that is not a number. Identifiers can be used to name variables, fields of tables, and labels.
中的错误处理
Error handling in
中的函数调用的语法如下
The syntax for the function call in is as follows
中的函数若需要传入栈索引，这个索引必须是 _有效索引_ 或是 _可接受索引
If the function in needs to pass in the stack index, this index must be a valid index or an acceptable index.
中的逻辑操作符有 **and**， **or**，以及 **not**。 和控制结构（参见 [§3.3.4](#3.3.4)）一样， 所有的逻辑操作符把 **false** 和 **nil** 都作为假， 而其它的一切都当作真。
The logical operators in are **and**, **or**, and **not * *. As with control structures (see [§ 3.3.4](#3.3.4)), all logical operators treat **false** and **nil** as false, and everything else as true.
中的每个值都可以有一个 _元表_。 这个 _元表_ 就是一个普通的 Lua 表， 它用于定义原始值在特定操作下的行为。 如果你想改变一个值在特定操作下的行为，你可以在它的元表中设置对应域。 例如，当你对非数字值做加操作时， Lua 会检查该值的元表中的 "`__add`" 域下的函数。 如果能找到，Lua 则调用这个函数来完成加这个操作。
Each value in can have a_meta table_. This_meta table_is a normal Lua table that defines the behavior of the original value under a specific operation. If you want to change the behavior of a value under a specific operation, you can set the corresponding field in its meta table. For example, when you add a non-numeric value, Lua checks the function under the `__add` field in the meta table for that value. If it can be found, Lua calls this function to complete the add operation.
中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 [`string.find`](#pdf-string.find), [`string.gmatch`](#pdf-string.gmatch), [`string.gsub`](#pdf-string.gsub), [`string.match`](#pdf-string.match)。 这一节表述了这些字符串的语法及含义（即它能匹配到什么
The matching pattern in is described directly with a regular string. It is used for pattern matching functions [`string.find`](#pdf-string.find), [`string.gmatch`](#pdf-string.gmatch), [`string.gsub`](#pdf-string.gsub), [`string.match`](#pdf-string.match). This section describes the syntax and meaning of these strings (I. e., what it can match
中的让出处理
Give-up processing in
中的整数类型。
The integer type in.
中的字符串可以保存任意 8 位值，其中包括用 '`\0`' 表示的 0 。 一般而言，你可以用字符的数字值来表示这个字符。 方式是用转义串 `\x_XX_`， 此处的 _XX_ 必须是恰好两个字符的 16 进制数。 或者你也可以使用转义串 `\_ddd_` ， 这里的 _ddd_ 是一到三个十进制数字。 （注意，如果在转义符后接着恰巧是一个数字符号的话， 你就必须在这个转义形式中写满三个数字
The string in can hold any 8-bit value, including 0 represented by `\0. In general, you can use the numeric value of the character to represent the character. The method is to use the escape string `\x_XX_`, where_XX_must be a hexadecimal number of exactly two characters. Or you can use the escape string `\_ddd_`, where_ddd_is one to three decimal digits. (Note that if the escape character happens to be followed by a number symbol, you must write three digits in the escape form
中浮点数的类型。
The type of the floating-point number in.
中数字的类型。缺省是 double ，但是你可以改成 float 。 （参见 `luaconf.h` 中的
The type of the number in. The default is double, but you can change it to float. (See in `luaconf.h`
中所有的值都是 _一等公民_。 这意味着所有的值均可保存在变量中、 当作参数传递给其它函数、以及作为返回值。
All the values in are_first-class citizens_. This means that all values can be stored in variables, passed as arguments to other functions, and returned as values.
中有八种基本类型： _nil_、_boolean_、_number_、_string_、_function_、_userdata_、 _thread_ 和 _table_。 _Nil_ 是值 **nil** 的类型， 其主要特征就是和其它值区别开；通常用来表示一个有意义的值不存在时的状态。 _Boolean_ 是 **false** 与 **true** 两个值的类型。 **nil** 和 **false** 都会导致条件判断为假； 而其它任何值都表示为真。 _Number_ 代表了整数和实数（浮点数）。 _String_ 表示一个不可变的字节序列。 Lua 对 8 位是友好的： 字符串可以容纳任意 8 位值， 其中包含零 ('`\0`') 。 Lua 的字符串与编码无关； 它不关心字符串中具体内容。
There are eight basic types in: _nil_,_boolean_,_number_,_string_,_function_,_userdata_,_thread_, and_table_. _Nil_is the type of value **nil** whose main characteristic is to distinguish it from other values; it is usually used to represent the state when a meaningful value does not exist. _Boolean_is a type of both **false** and **true** values. Both **nil** and **false** cause the condition to be false; any other value is true. _Number_represents integers and real numbers (floating point numbers). _String_represents an immutable sequence of bytes. Lua is 8-bit friendly: a string can hold any 8-bit value, including zeros (`\0`). Lua`s string has nothing to do with encoding; it doesn`t care about the exact contents of the string.
中有这些基本表达式
There are these basic expressions in
中止对后面选项的处理
Abort processing of subsequent options
中止上一次保护函数调用， 将错误对象 `message` 返回。 函数 `error` 永远不会返回。
Aborts the last protection function call, returning the error object `message. The function `error` never returns.
中字符串的连接操作符写作两个点（'`..`'）。 如果两个操作数都是字符串或都是数字， 连接操作将以 [§3.4.3](#3.4.3) 中提到的规则把其转换为字符串。 否则，会调用元方法 `__concat` （参见
The join operator in the string is written as two dots (''..''). If both operands are strings or numbers, the concatenation operation will convert them to strings according to the rules mentioned in [§ 3.4.3](#3.4.3). Otherwise, the meta-method '__concat' is called (cf.
中字符串的连接操作符写作两个点（``..``）。 如果两个操作数都是字符串或都是数字， 连接操作将以 [§3.4.3](#3.4.3) 中提到的规则把其转换为字符串。 否则，会调用元方法 `__concat` （参见
The join operator in the string is written as two dots (``..``). If both operands are strings or numbers, the concatenation operation will convert them to strings according to the rules mentioned in [§ 3.4.3](#3.4.3). Otherwise, the meta-method `__concat` is called (cf.
重启垃圾收集器。
Restart the garbage collector.
重启垃圾收集器的自动运行。
Restart the automatic run of the garbage collector.
注册表
Registry
注册表的这个索引下是全局环境。
Under this index of the registry is the global environment.
注册表中的整数键用于引用机制 （参见 [`luaL_ref`](#luaL_ref)）， 以及一些预定义的值。 因此，整数键不要用于别的目的。
Integer keys in the registry are used for the reference mechanism (see [luaL_ref](#luaL_ref)), as well as some predefined values. Therefore, integer keys should not be used for other purposes.
注册表中这个索引下是状态机的主线程。 （主线程和状态机同时被创建出来
Under this index in the registry is the main thread of the state machine. (The main thread and the state machine are created at the same time.
注册到 Lua 中的任何函数都必须遵循正确的协议来接收参数和返回值 （参见
Any function registered to Lua must follow the correct protocol to receive parameters and return values (see
注意，`debug.debug` 输入的命令在文法上并没有内嵌到任何函数中， 因此不能直接去访问局部变量。
Note that the command entered by `debug.debug` is not embedded in any function in the grammar, so it cannot directly access local variables.
注意，标准 C 能确保 `free(NULL)` 没有副作用， 且 `realloc(NULL,size)` 等价于 `malloc(size)`。 这段代码假定 `realloc` 在缩小块长度时不会失败。 （虽然标准 C 没有对此行为做出保证，但这看起来是一个安全的假定
Note that standard C ensures that `free(NULL)`has no side effects and that `realloc(NULL,size)` is equivalent to `malloc(size)`. This code assumes that `realloc` will not fail when reducing the block length. (Although standard C does not guarantee this behavior, this seems to be a safe assumption
注意，每次执行到一个 **local** 语句都会定义出一个新的局部变量。 看看这样一个例子
Note that each execution of a **local** statement defines a new local variable. Look at such an example
注意上面这段代码是 _平衡_ 的： 到了最后，堆栈恢复成原有的配置。 这是一种良好的编程习惯。
Note that the above code is balanced: at the end, the stack is restored to its original configuration. This is a good programming practice.
注意下面这几点
Note these points below.
注意以下几点
Note the following points
注意这里，类似 `local x = x` 这样的声明， 新的 `x` 正在被声明，但是还没有进入它的作用范围， 所以第二个 `x` 指向的是外面一层的变量。
Note here that for statements like `local x = x`, the new `x` is being declared, but has not yet entered its scope, so the second `x` points to a variable from an outer layer.
注意这里那个额外的显式的对延续函数的调用： Lua 仅在需要时，这可能是由错误导致的也可能是发生了让出而需要继续运行，才会调用延续函数。 如果没有发生过任何让出，调用的函数正常返回， 那么 [`lua_pcallk`](#lua_pcallk) （以及 [`lua_callk`](#lua_callk)）也会正常返回。 （当然，这个例子中你也可以不在之后调用延续函数， 而是在原函数的调用后直接写上需要做的工作
Note the additional explicit call to the continuation function here: Lua calls the continuation function only when it is needed, which may be caused by an error, or it may be due to a concession that needs to continue running. If no yield has occurred and the called function returns normally, then [lua_pcallk](#lua_pcallk) (and [lua_callk](#lua_callk)) will also return normally. (Of course, in this example, you can also not call the continuation function later, but write the work that needs to be done directly after the call of the original function.
状态机中使用的内存分配器函数的类型。 内存分配函数必须提供一个功能类似于 `realloc` 但又不完全相同的函数。 它的参数有 `ud` ，一个由 [`lua_newstate`](#lua_newstate) 传给它的指针； `ptr` ，一个指向已分配出来/将被重新分配/要释放的内存块指针； `osize` ，内存块原来的尺寸或是关于什么将被分配出来的代码； `nsize` ，新内存块的尺寸。
The type of memory allocator function used in the state machine. The memory allocation function must provide a function similar to `realloc` but not identical. Its parameters are `ud`, a pointer passed to it by [lua_newstate](#lua_newstate); `ptr`, a pointer to a memory block that has been allocated/will be reallocated/to be freed; `Osize`, the original size of the memory block or a code about what will be allocated; `nsize`, the size of the new memory block.
追加更新模式，所有之前的数据都保留，只允许在文件尾部做写入。
In the append update mode, all previous data is retained and only writes are allowed at the end of the file.
追加模式
Append mode
追加若干返回值
Append several return values
准确说这个不是兼容性问题， 因为 Lua 并没有规定数字如何格式化成字符串， 但一些程序假定遵循某种特别的格式
To be precise, this is not a compatibility issue, because Lua does not specify how numbers are formatted into strings, but some programs assume that they follow a particular format.
字符串 `mode` 用于控制代码块是文本还是二进制（即预编译代码块）。 它可以是字符串 "`b`" （只能是二进制代码块）， "`t`" （只能是文本代码块）， 或 "`bt`" （可以是二进制也可以是文本）。 默认值为
The string `mode` is used to control whether the code block is text or binary (that is, a precompiled code block). It can be the string "`B`" (can only be a binary code block), "`t`" (can only be a text code block), or "`bt`" (can be either binary or text). The default value is
字符串处理
String processing
字符串的转换结果可能是整数也可能是浮点数， 这取决于 Lua 的转换文法（参见 [§3.1](#3.1)）。 （字符串可以有前置和后置的空格，可以带符号
The result of the string conversion may be an integer or a floating point number, depending on Lua's conversion grammar (see [§ 3.1](#3.1)). (Strings can have leading and trailing spaces, and can be signed
字符串的作用同函数
The role of the string is the same as the function
字符串缓存_ 的类型。
The type of string cache.
字符串缓存可以让 C 代码分段构造一个 Lua 字符串。 使用模式如下
String caching allows C code to segment a Lua string. The use mode is as follows
字符串可以是下列任意值
The string can be any of the following values
字符串可以在最后加一个 '`b`' ， 这会在某些系统上以二进制方式打开文件。
The string can be appended with a ``B`` at the end, which opens the file in binary on some systems.
字符串控制
String Control
字符串库假定采用单字节字符编码。
String libraries assume single-byte character encoding.
字符串库中的所有函数都在表 `string` 中。 它还将其设置为字符串元表的 `__index` 域。 因此，你可以以面向对象的形式使用字符串函数。 例如，`string.byte(s,i)` 可以写成
All functions in the string library are in the table `string. It also sets it to the `__index` field of the string meta table. Therefore, you can use string functions in object-oriented form. For example, `string.byte(s, I) `can be written
字符串连接
String concatenation
字符串中的每个字符都筛选出结构 `ar` 结构中一些域用于填充， 或是把一个值压入堆栈
Each character in the string filters out some fields in the structure`ar` structure to fill in, or to push a value onto the stack.
字符类
Character Class
字符类_ 用于表示一个字符集合。 下列组合可用于字符类
Character class_is used to represent a collection of characters. The following combinations are available for character classes
字节固定长度的字符串
Byte fixed-length string
字面串_ 可以用单引号或双引号括起。 字面串内部可以包含下列 C 风格的转义串： '`\a`' （响铃）， '`\b`' （退格）， '`\f`' （换页）， '`\n`' （换行）， '`\r`' （回车）， '`\t`' （横项制表）， '`\v`' （纵向制表）， '`\\`' （反斜杠）， '`\"`' （双引号）， 以及 '`\'`' (单引号)。 在反斜杠后跟一个真正的换行等价于在字符串中写一个换行符。 转义串 '`\z`' 会忽略其后的一系列空白符，包括换行； 它在你需要对一个很长的字符串常量断行为多行并希望在每个新行保持缩进时非常有用。
The literal string_can be enclosed in single or double quotes. The literal string can contain the following C- style escape strings: ``\a`` (bell), ``\B ``(backspace), ``\f`` (page change), ``\n`` (line change), ``\r`` (carriage return), ``\t`` (horizontal item tabulation), ``\v`` (vertical tabulation), ``\ ``(backslash), ``\``(double quotation marks), and ```` (single quotation mark). A true line break followed by a backslash is equivalent to writing a line break in the string. The escape string ``\z`` ignores a series of blank characters after it, including line breaks; it is useful when you need to break multiple lines for a long string constant and want to keep indenting each new line.
字面串还可以用一种 _长括号_ 括起来的方式定义。 我们把两个正的方括号间插入 _n_ 个等号定义为 _第 _n_ 级开长括号_。 就是说，0 级开的长括号写作 `[[` ， 一级开长括号写作 `[=[` ， 如此等等。 _闭长括号_也作类似定义； 举个例子，4 级反的长括号写作 `]====]` 。 一个 _长字面串_ 可以由任何一级的开长括号开始，而由第一个碰到的同级的闭长括号结束。 这种方式描述的字符串可以包含任何东西，当然特定级别的反长括号除外。 整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。 其中碰到的任何形式的换行串（回车、换行、回车加换行、换行加回车），都会被转换为单个换行符。
Literal strings can also be defined in a way that_long brackets_are enclosed. We define the_n_equal sign inserted between two positive square brackets as the_n_level open long bracket_. That is to say, level 0 long brackets are written as `[[`, level 1 long brackets are written as `[=[`, and so on. _Closed long brackets_are similarly defined; For example, the long brackets for level 4 inversion are written `]====]`. A_long literal string_can begin with an open-length parenthesis of any level and end with a closed-length parenthesis of the first encountered sibling. A string described this way can contain anything, except, of course, for a specific level of backparentheses. The entire lexical analysis process will not be restricted by branches, will not handle any escape characters, and will ignore any long parentheses at different levels. Any form of line feed string encountered (carriage return, line feed, carriage return plus line feed, line feed plus carriage return) will be converted to a single line feed.
字面串中的每个不被上述规则影响的字节都呈现为本身。 然而，Lua 是用文本模式打开源文件解析的， 一些系统的文件操作函数对某些控制字符的处理可能有问题。 因此，对于非文本数据，用引号括起来并显式按转义符规则来表述更安全。
Each byte in the literal string that is not affected by the above rules is presented as itself. However, Lua uses text mode to open source file parsing, and some systems' file manipulation functions may have problems with the handling of certain control characters. Therefore, for non-text data, it is safer to enclose it in quotation marks and explicitly express it according to escape character rules.
最大值的整数。
The integer of the maximum value.
最后调用 `luaL_pushresult(&b)` 。 最后这次调用会在栈顶留下最终的字符串。
Last call `luaL_pushresult(& B) `. This last call leaves the final string at the top of the stack.
最后调用 `luaL_pushresultsize(&b, sz)`， 这里的 `sz` 指已经复制到缓存内的字符串长度。
Finally, call `luaL_pushresultsize(& B, sz)`, where `sz` refers to the length of the string that has been copied into the cache.
最后一次由 `writer` 的返回值将作为这个函数的返回值返回； 0 表示没有错误。
The last return value from `writer` will be returned as the return value of this function; 0 means there is no error.
最小值的整数。
Integer of the minimum value.
遵循 [`package.searchers`](#pdf-package.searchers) 序列的指引来查找加载器。 如果改变这个序列，我们可以改变 `require` 如何查找一个模块。 下列说明基于 [`package.searchers`](#pdf-package.searchers) 的默认配置。
Follow the [`package.searchers`](#pdf-package.searchers) sequence to find the loader. If we change this sequence, we can change how `require` looks for a module. The following description is based on the default configuration of [`package.searchers`](#pdf-package.searchers).
左移
Move left
左移）操作。 行为和 "band" 操作类似。
left shift) operation. The behavior is similar to the "band" operation.
作为特例，当 `n` 等于 0 时， 此函数返回含有 `s` 第 `i` 字节的那个字符的开始位置。
As a special case, when `n` is equal to 0, this function returns the starting position of the character containing the `I` byte of`s.
作为一个特例，空的捕获 `()` 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 `"()aa()"` 作用到字符串 `"flaaap"` 上，将产生两个捕获物： 3 和
As a special case, an empty capture `()` will capture the position of the current string (it is a number). For example, if the pattern `"()aa()" "is applied to the string`" flaaap "`, two captures will be produced: 3 and
作为一门扩展式语言，Lua 没有 "main" 程序的概念： 它只能 _嵌入_ 一个宿主程序中工作， 该宿主程序被称为 _被嵌入程序_ 或者简称 _宿主_ 。 宿主程序可以调用函数执行一小段 Lua 代码，可以读写 Lua 变量，可以注册 C 函数让 Lua 代码调用。 依靠 C 函数，Lua 可以共享相同的语法框架来定制编程语言，从而适用不同的领域。 Lua 的官方发布版包含一个叫做 `lua` 的宿主程序示例， 它是一个利用 Lua 库实现的完整独立的 Lua 解释器，可用于交互式应用或批处理。
As an extended language, Lua does not have the concept of a "main" program: it can only work in a host program, which is called an embedded program or, for short, a host program_. The host program can call functions to execute a small piece of Lua code, can read and write Lua variables, and can register C functions for Lua code to call. Relying on C functions, Lua can share the same syntax framework to customize the programming language and thus apply to different domains. The official release of Lua includes an example of a host program called `lua`, which is a complete stand-alone Lua interpreter implemented using the Lua library, which can be used for interactive applications or batch processing.
作者
Author
做一次完整的垃圾收集循环。 这是默认选项。
Do a full garbage collection cycle. This is the default option.
做一个等价于 `t[k] = v` 的操作， 这里 `t` 是给出的索引处的值， `v` 是栈顶的那个值， `k` 是栈顶之下的值。
Do an operation equivalent to`t[k] = v`, where `t` is the value at the given index, `v` is the value at the top of the stack, and `k` is the value below the top of the stack.
做一个等价于 `t[k] = v` 的操作， 这里 `t` 是给出的索引处的值， 而 `v` 是栈顶的那个值。
Do an operation equivalent to`t[k] = v`, where `t` is the value at the given index and `v` is the value at the top of the stack.
做一个等价于 `t[n] = v` 的操作， 这里 `t` 是给出的索引处的值， 而 `v` 是栈顶的那个值。
Do an operation equivalent to`t[n] = v`, where `t` is the value at the given index and `v` is the value at the top of the stack.